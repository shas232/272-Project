/*!
 * ONNX Runtime Web v1.21.0-dev.20241024-d9ca84ef96
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "common/dist/esm/backend-impl.js"() {
    "use strict";
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name, backend, priority) => {
      if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name);
        if (currentBackend === void 0) {
          backends.set(name, { backend, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend) {
            throw new Error(`cannot register backend "${name}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name);
              return;
            }
          }
          backendsSortedByPriority.push(name);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend) {
            backend = resolveResult;
          }
          if (backend === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name, err } of errors) {
        if (backendHints.includes(name)) {
          console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// common/dist/esm/backend.js
var init_backend = __esm({
  "common/dist/esm/backend.js"() {
    "use strict";
    init_backend_impl();
  }
});

// common/dist/esm/version.js
var version;
var init_version = __esm({
  "common/dist/esm/version.js"() {
    "use strict";
    version = "1.20.0-dev.20241016-2b8fc5529b";
  }
});

// common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "common/dist/esm/env-impl.js"() {
    "use strict";
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// common/dist/esm/env.js
var env2;
var init_env = __esm({
  "common/dist/esm/env.js"() {
    "use strict";
    init_env_impl();
    env2 = env;
  }
});

// common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "common/dist/esm/tensor-conversion-impl.js"() {
    "use strict";
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "common/dist/esm/tensor-factory-impl.js"() {
    "use strict";
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromMLTensor = (mlTensor, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "common/dist/esm/tensor-impl-type-mapping.js"() {
    "use strict";
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array],
      ["int4", Uint8Array],
      ["uint4", Uint8Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "common/dist/esm/tensor-utils-impl.js"() {
    "use strict";
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        case "ml-tensor":
          return new Tensor({
            location: "ml-tensor",
            mlTensor: tensor.mlTensor,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "common/dist/esm/tensor-impl.js"() {
    "use strict";
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "ml-tensor": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool") {
                throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
              }
              this.mlTensorData = arg0.mlTensor;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                  throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else if (arg1 instanceof Uint8ClampedArray) {
                if (arg0 === "uint8") {
                  data = Uint8Array.from(arg1);
                } else {
                  throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                }
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else if (arg0 instanceof Uint8ClampedArray) {
              type = "uint8";
              data = Uint8Array.from(arg0);
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
          } else {
            throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
          }
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromMLTensor(mlTensor, options) {
        return tensorFromMLTensor(mlTensor, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      get mlTensor() {
        this.ensureValid();
        if (!this.mlTensorData) {
          throw new Error("The data is not stored as a WebNN MLTensor.");
        }
        return this.mlTensorData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer":
          case "ml-tensor": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.mlTensorData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "common/dist/esm/tensor.js"() {
    "use strict";
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
var init_trace = __esm({
  "common/dist/esm/trace.js"() {
    "use strict";
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
  }
});

// common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "common/dist/esm/inference-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of this.outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of this.inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of this.outputNames) {
            fetches[name] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    };
  }
});

// common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "common/dist/esm/inference-session.js"() {
    "use strict";
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "common/dist/esm/tensor-conversion.js"() {
    "use strict";
  }
});

// common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "common/dist/esm/tensor-factory.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "common/dist/esm/onnx-model.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "common/dist/esm/onnx-value.js"() {
    "use strict";
  }
});

// common/dist/esm/training-session-impl.js
var noBackendErrMsg, TrainingSession;
var init_training_session_impl = __esm({
  "common/dist/esm/training-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
    TrainingSession = class _TrainingSession {
      constructor(handler, hasOptimizerModel, hasEvalModel) {
        this.handler = handler;
        this.hasOptimizerModel = hasOptimizerModel;
        this.hasEvalModel = hasEvalModel;
      }
      get trainingInputNames() {
        return this.handler.inputNames;
      }
      get trainingOutputNames() {
        return this.handler.outputNames;
      }
      get evalInputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalInputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      get evalOutputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalOutputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      static async create(trainingOptions, sessionOptions) {
        const evalModel = trainingOptions.evalModel || "";
        const optimizerModel = trainingOptions.optimizerModel || "";
        const options = sessionOptions || {};
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        if (backend.createTrainingSessionHandler) {
          const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
          return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
        } else {
          throw new Error(noBackendErrMsg);
        }
      }
      /**
       * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
       * the given parameters to SessionHandler.FetchesType and RunOptions.
       *
       * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
       * names.
       * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
       * names.
       * @param feeds the required input
       * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
       * @param arg2 optional RunOptions object.
       * @returns
       */
      typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of outputNames) {
            fetches[name] = null;
          }
        }
        return [fetches, options];
      }
      /**
       * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
       * and changes it into a map of Tensors.
       *
       * @param results
       * @returns
       */
      convertHandlerReturnTypeToMapOfTensors(results) {
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        return returnValue;
      }
      async lazyResetGrad() {
        await this.handler.lazyResetGrad();
      }
      async runTrainStep(feeds, arg1, arg2) {
        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
        const results = await this.handler.runTrainStep(feeds, fetches, options);
        return this.convertHandlerReturnTypeToMapOfTensors(results);
      }
      async runOptimizerStep(options) {
        if (this.hasOptimizerModel) {
          await this.handler.runOptimizerStep(options || {});
        } else {
          throw new Error("This TrainingSession has no OptimizerModel loaded.");
        }
      }
      async runEvalStep(feeds, arg1, arg2) {
        if (this.hasEvalModel) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runEvalStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        } else {
          throw new Error("This TrainingSession has no EvalModel loaded.");
        }
      }
      async getParametersSize(trainableOnly = true) {
        return this.handler.getParametersSize(trainableOnly);
      }
      async loadParametersBuffer(array, trainableOnly = true) {
        const paramsSize = await this.getParametersSize(trainableOnly);
        if (array.length !== 4 * paramsSize) {
          throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
        }
        return this.handler.loadParametersBuffer(array, trainableOnly);
      }
      async getContiguousParameters(trainableOnly = true) {
        return this.handler.getContiguousParameters(trainableOnly);
      }
      async release() {
        return this.handler.dispose();
      }
    };
  }
});

// common/dist/esm/training-session.js
var TrainingSession2;
var init_training_session = __esm({
  "common/dist/esm/training-session.js"() {
    "use strict";
    init_training_session_impl();
    TrainingSession2 = TrainingSession;
  }
});

// common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  TrainingSession: () => TrainingSession2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "common/dist/esm/index.js"() {
    "use strict";
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
    init_training_session();
  }
});

// web/lib/wasm/wasm-utils-env.ts
var isNode;
var init_wasm_utils_env = __esm({
  "web/lib/wasm/wasm-utils-env.ts"() {
    "use strict";
    isNode = false;
  }
});

// web/lib/wasm/proxy-worker/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WORKER_NAME, isProxyWorker, main_default;
var init_main = __esm({
  "web/lib/wasm/proxy-worker/main.ts"() {
    "use strict";
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    WORKER_NAME = "ort-wasm-proxy-worker";
    isProxyWorker = globalThis.self?.name === WORKER_NAME;
    if (isProxyWorker) {
      self.onmessage = (ev) => {
        const { type, in: message } = ev.data;
        try {
          switch (type) {
            case "init-wasm":
              initializeWebAssembly(message.wasm).then(
                () => {
                  initRuntime(message).then(
                    () => {
                      postMessage({ type });
                    },
                    (err) => {
                      postMessage({ type, err });
                    }
                  );
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            case "init-ep": {
              const { epName, env: env3 } = message;
              initEp(env3, epName).then(
                () => {
                  postMessage({ type });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "copy-from": {
              const { buffer } = message;
              const bufferData = copyFromExternalBuffer(buffer);
              postMessage({ type, out: bufferData });
              break;
            }
            case "create": {
              const { model, options } = message;
              createSession(model, options).then(
                (sessionMetadata) => {
                  postMessage({ type, out: sessionMetadata });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "release":
              releaseSession(message);
              postMessage({ type });
              break;
            case "run": {
              const { sessionId, inputIndices, inputs, outputIndices, options } = message;
              run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                (outputs) => {
                  if (outputs.some((o) => o[3] !== "cpu")) {
                    postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                  } else {
                    postMessage(
                      { type, out: outputs },
                      extractTransferableBuffers([...inputs, ...outputs])
                    );
                  }
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "end-profiling":
              endProfiling(message);
              postMessage({ type });
              break;
            default:
          }
        } catch (err) {
          postMessage({ type, err });
        }
      };
    }
    main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: true ? "module" : "classic", name: WORKER_NAME });
  }
});

// web/lib/wasm/wasm-utils-import.ts
var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
var init_wasm_utils_import = __esm({
  "web/lib/wasm/wasm-utils-import.ts"() {
    "use strict";
    init_wasm_utils_env();
    scriptSrc = // if Nodejs, return undefined
    isNode ? void 0 : (
      // if It's ESM, use import.meta.url
      import.meta.url ?? // use `document.currentScript.src` if available
      (typeof document !== "undefined" ? document.currentScript?.src : (
        // use `self.location.href` if available
        typeof self !== "undefined" ? self.location?.href : void 0
      ))
    );
    origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
    isSameOrigin = (filename, prefixOverride) => {
      try {
        const baseUrl = prefixOverride ?? scriptSrc;
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.origin === origin;
      } catch {
        return false;
      }
    };
    normalizeUrl = (filename, prefixOverride) => {
      const baseUrl = prefixOverride ?? scriptSrc;
      try {
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.href;
      } catch {
        return void 0;
      }
    };
    fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
    preload = async (absoluteUrl) => {
      const response = await fetch(absoluteUrl, { credentials: "same-origin" });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    };
    dynamicImportDefault = async (url) => (await import(
      /* webpackIgnore: true */
      url
    )).default;
    createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
    false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
    importProxyWorker = async () => {
      if (!scriptSrc) {
        throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      }
      if (isSameOrigin(scriptSrc)) {
        return [void 0, createProxyWorker()];
      }
      const url = await preload(scriptSrc);
      return [url, createProxyWorker(url)];
    };
    embeddedWasmModule = false ? (
      // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      (true ? null : null).default
    ) : void 0;
    importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
      if (false) {
        return [void 0, embeddedWasmModule];
      } else {
        const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
        const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
        const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
        const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
        return [needPreload ? url : void 0, await dynamicImportDefault(url)];
      }
    };
  }
});

// web/lib/wasm/wasm-factory.ts
var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
var init_wasm_factory = __esm({
  "web/lib/wasm/wasm-factory.ts"() {
    "use strict";
    init_wasm_utils_import();
    initialized = false;
    initializing = false;
    aborted = false;
    isMultiThreadSupported = () => {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      try {
        if (typeof MessageChannel !== "undefined") {
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            5,
            4,
            1,
            3,
            1,
            1,
            10,
            11,
            1,
            9,
            0,
            65,
            0,
            254,
            16,
            2,
            0,
            26,
            11
          ])
        );
      } catch (e) {
        return false;
      }
    };
    isSimdSupported = () => {
      try {
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            10,
            30,
            1,
            28,
            0,
            65,
            0,
            253,
            15,
            253,
            12,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            253,
            186,
            1,
            26,
            11
          ])
        );
      } catch (e) {
        return false;
      }
    };
    initializeWebAssembly = async (flags) => {
      if (initialized) {
        return Promise.resolve();
      }
      if (initializing) {
        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      }
      if (aborted) {
        throw new Error("previous call to 'initializeWebAssembly()' failed.");
      }
      initializing = true;
      const timeout = flags.initTimeout;
      let numThreads = flags.numThreads;
      if (!isSimdSupported()) {
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
      }
      const multiThreadSupported = isMultiThreadSupported();
      if (numThreads > 1 && !multiThreadSupported) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          console.warn(
            "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
          );
        }
        console.warn(
          "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
        );
        flags.numThreads = numThreads = 1;
      }
      const wasmPaths = flags.wasmPaths;
      const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
      const mjsPathOverrideFlag = wasmPaths?.mjs;
      const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
      const wasmPathOverrideFlag = wasmPaths?.wasm;
      const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
      const wasmBinaryOverride = flags.wasmBinary;
      const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
      let isTimeout = false;
      const tasks = [];
      if (timeout > 0) {
        tasks.push(
          new Promise((resolve) => {
            setTimeout(() => {
              isTimeout = true;
              resolve();
            }, timeout);
          })
        );
      }
      tasks.push(
        new Promise((resolve, reject) => {
          const config = {
            /**
             * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
             * created.
             */
            numThreads
          };
          if (wasmBinaryOverride) {
            config.wasmBinary = wasmBinaryOverride;
          } else if (wasmPathOverride || wasmPrefixOverride) {
            config.locateFile = (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;
          }
          ortWasmFactory(config).then(
            // wasm module initialized successfully
            (module) => {
              initializing = false;
              initialized = true;
              wasm = module;
              resolve();
              if (objectUrl) {
                URL.revokeObjectURL(objectUrl);
              }
            },
            // wasm module failed to initialize
            (what) => {
              initializing = false;
              aborted = true;
              reject(what);
            }
          );
        })
      );
      await Promise.race(tasks);
      if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
      }
    };
    getInstance = () => {
      if (initialized && wasm) {
        return wasm;
      }
      throw new Error("WebAssembly is not initialized yet.");
    };
  }
});

// web/lib/wasm/wasm-utils.ts
var allocWasmString, iterateExtraOptions, checkLastError;
var init_wasm_utils = __esm({
  "web/lib/wasm/wasm-utils.ts"() {
    "use strict";
    init_wasm_factory();
    allocWasmString = (data, allocs) => {
      const wasm2 = getInstance();
      const dataLength = wasm2.lengthBytesUTF8(data) + 1;
      const dataOffset = wasm2._malloc(dataLength);
      wasm2.stringToUTF8(data, dataOffset, dataLength);
      allocs.push(dataOffset);
      return dataOffset;
    };
    iterateExtraOptions = (options, prefix, seen, handler) => {
      if (typeof options == "object" && options !== null) {
        if (seen.has(options)) {
          throw new Error("Circular reference in options");
        } else {
          seen.add(options);
        }
      }
      Object.entries(options).forEach(([key, value]) => {
        const name = prefix ? prefix + key : key;
        if (typeof value === "object") {
          iterateExtraOptions(value, name + ".", seen, handler);
        } else if (typeof value === "string" || typeof value === "number") {
          handler(name, value.toString());
        } else if (typeof value === "boolean") {
          handler(name, value ? "1" : "0");
        } else {
          throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
      });
    };
    checkLastError = (message) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const paramsOffset = wasm2.stackAlloc(8);
        wasm2._OrtGetLastError(paramsOffset, paramsOffset + 4);
        const errorCode = wasm2.HEAP32[paramsOffset / 4];
        const errorMessagePointer = wasm2.HEAPU32[paramsOffset / 4 + 1];
        const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
  }
});

// web/lib/wasm/run-options.ts
var setRunOptions;
var init_run_options = __esm({
  "web/lib/wasm/run-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    setRunOptions = (options) => {
      const wasm2 = getInstance();
      let runOptionsHandle = 0;
      const allocs = [];
      const runOptions = options || {};
      try {
        if (options?.logSeverityLevel === void 0) {
          runOptions.logSeverityLevel = 2;
        } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
        }
        if (options?.logVerbosityLevel === void 0) {
          runOptions.logVerbosityLevel = 0;
        } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
          throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if (options?.terminate === void 0) {
          runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if (options?.tag !== void 0) {
          tagDataOffset = allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm2._OrtCreateRunOptions(
          runOptions.logSeverityLevel,
          runOptions.logVerbosityLevel,
          !!runOptions.terminate,
          tagDataOffset
        );
        if (runOptionsHandle === 0) {
          checkLastError("Can't create run options.");
        }
        if (options?.extra !== void 0) {
          iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
            }
          });
        }
        return [runOptionsHandle, allocs];
      } catch (e) {
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/session-options.ts
var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
var init_session_options = __esm({
  "web/lib/wasm/session-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    getGraphOptimzationLevel = (graphOptimizationLevel) => {
      switch (graphOptimizationLevel) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
      }
    };
    getExecutionMode = (executionMode) => {
      switch (executionMode) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${executionMode}`);
      }
    };
    appendDefaultOptions = (options) => {
      if (!options.extra) {
        options.extra = {};
      }
      if (!options.extra.session) {
        options.extra.session = {};
      }
      const session = options.extra.session;
      if (!session.use_ort_model_bytes_directly) {
        session.use_ort_model_bytes_directly = "1";
      }
      if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
        options.enableMemPattern = false;
      }
    };
    setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
      for (const ep of executionProviders) {
        let epName = typeof ep === "string" ? ep : ep.name;
        switch (epName) {
          case "webnn":
            epName = "WEBNN";
            if (typeof ep !== "string") {
              const webnnOptions = ep;
              const deviceType = webnnOptions?.deviceType;
              if (deviceType) {
                const keyDataOffset = allocWasmString("deviceType", allocs);
                const valueDataOffset = allocWasmString(deviceType, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                }
              }
            }
            break;
          case "webgpu":
            epName = "JS";
            if (typeof ep !== "string") {
              const webgpuOptions = ep;
              if (webgpuOptions?.preferredLayout) {
                if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                  throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                }
                const keyDataOffset = allocWasmString("preferredLayout", allocs);
                const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);
                }
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${epName}`);
        }
        const epNameDataOffset = allocWasmString(epName, allocs);
        if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
          checkLastError(`Can't append execution provider: ${epName}.`);
        }
      }
    };
    setSessionOptions = (options) => {
      const wasm2 = getInstance();
      let sessionOptionsHandle = 0;
      const allocs = [];
      const sessionOptions = options || {};
      appendDefaultOptions(sessionOptions);
      try {
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
        const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
        const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
        const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
        }
        const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
          throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
        }
        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
        sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
          graphOptimizationLevel,
          !!sessionOptions.enableCpuMemArena,
          !!sessionOptions.enableMemPattern,
          executionMode,
          !!sessionOptions.enableProfiling,
          0,
          logIdDataOffset,
          logSeverityLevel,
          logVerbosityLevel,
          optimizedModelFilePathOffset
        );
        if (sessionOptionsHandle === 0) {
          checkLastError("Can't create session options.");
        }
        if (sessionOptions.executionProviders) {
          setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
        }
        if (sessionOptions.enableGraphCapture !== void 0) {
          if (typeof sessionOptions.enableGraphCapture !== "boolean") {
            throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
          }
          const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
          const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
          if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
            checkLastError(
              `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
            );
          }
        }
        if (sessionOptions.freeDimensionOverrides) {
          for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
            if (typeof name !== "string") {
              throw new Error(`free dimension override name must be a string: ${name}`);
            }
            if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
              throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
            }
            const nameOffset = allocWasmString(name, allocs);
            if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
              checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
            }
          }
        }
        if (sessionOptions.extra !== void 0) {
          iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
            }
          });
        }
        return [sessionOptionsHandle, allocs];
      } catch (e) {
        if (sessionOptionsHandle !== 0) {
          wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/wasm-common.ts
var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
var init_wasm_common = __esm({
  "web/lib/wasm/wasm-common.ts"() {
    "use strict";
    tensorDataTypeStringToEnum = (type) => {
      switch (type) {
        case "int8":
          return 3 /* int8 */;
        case "uint8":
          return 2 /* uint8 */;
        case "bool":
          return 9 /* bool */;
        case "int16":
          return 5 /* int16 */;
        case "uint16":
          return 4 /* uint16 */;
        case "int32":
          return 6 /* int32 */;
        case "uint32":
          return 12 /* uint32 */;
        case "float16":
          return 10 /* float16 */;
        case "float32":
          return 1 /* float */;
        case "float64":
          return 11 /* double */;
        case "string":
          return 8 /* string */;
        case "int64":
          return 7 /* int64 */;
        case "uint64":
          return 13 /* uint64 */;
        case "int4":
          return 22 /* int4 */;
        case "uint4":
          return 21 /* uint4 */;
        default:
          throw new Error(`unsupported data type: ${type}`);
      }
    };
    tensorDataTypeEnumToString = (typeProto) => {
      switch (typeProto) {
        case 3 /* int8 */:
          return "int8";
        case 2 /* uint8 */:
          return "uint8";
        case 9 /* bool */:
          return "bool";
        case 5 /* int16 */:
          return "int16";
        case 4 /* uint16 */:
          return "uint16";
        case 6 /* int32 */:
          return "int32";
        case 12 /* uint32 */:
          return "uint32";
        case 10 /* float16 */:
          return "float16";
        case 1 /* float */:
          return "float32";
        case 11 /* double */:
          return "float64";
        case 8 /* string */:
          return "string";
        case 7 /* int64 */:
          return "int64";
        case 13 /* uint64 */:
          return "uint64";
        case 22 /* int4 */:
          return "int4";
        case 21 /* uint4 */:
          return "uint4";
        default:
          throw new Error(`unsupported data type: ${typeProto}`);
      }
    };
    calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
      const elementSize = [
        -1,
        // undefined = 0
        4,
        // float = 1
        1,
        // uint8 = 2
        1,
        // int8 = 3
        2,
        // uint16 = 4
        2,
        // int16 = 5
        4,
        // int32 = 6
        8,
        // int64 = 7
        -1,
        // string = 8
        1,
        // bool = 9
        2,
        // float16 = 10
        8,
        // double = 11
        4,
        // uint32 = 12
        8,
        // uint64 = 13
        -1,
        // complex64 = 14
        -1,
        // complex128 = 15
        -1,
        // bfloat16 = 16
        -1,
        // FLOAT8E4M3FN = 17
        -1,
        // FLOAT8E4M3FNUZ = 18
        -1,
        // FLOAT8E5M2 = 19
        -1,
        // FLOAT8E5M2FNUZ = 20
        0.5,
        // uint4 = 21
        0.5
        // int4 = 22
      ][dateType];
      const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
      return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
    };
    tensorTypeToTypedArrayConstructor = (type) => {
      switch (type) {
        case "float16":
          return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${type}`);
      }
    };
    logLevelStringToEnum = (logLevel) => {
      switch (logLevel) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${logLevel}`);
      }
    };
    isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
    isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool";
    dataLocationStringToEnum = (location2) => {
      switch (location2) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        case "ml-tensor":
          return 5;
        default:
          throw new Error(`unsupported data location: ${location2}`);
      }
    };
  }
});

// web/lib/wasm/wasm-utils-load-file.ts
var loadFile;
var init_wasm_utils_load_file = __esm({
  "web/lib/wasm/wasm-utils-load-file.ts"() {
    "use strict";
    init_wasm_utils_env();
    loadFile = async (file) => {
      if (typeof file === "string") {
        if (isNode) {
          try {
            const { readFile } = __require("node:fs/promises");
            return new Uint8Array(await readFile(file));
          } catch (e) {
            if (e.code === "ERR_FS_FILE_TOO_LARGE") {
              const { createReadStream } = __require("node:fs");
              const stream = createReadStream(file);
              const chunks = [];
              for await (const chunk of stream) {
                chunks.push(chunk);
              }
              return new Uint8Array(Buffer.concat(chunks));
            }
            throw e;
          }
        } else {
          const response = await fetch(file);
          if (!response.ok) {
            throw new Error(`failed to load external data file: ${file}`);
          }
          const contentLengthHeader = response.headers.get("Content-Length");
          const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
          if (fileSize < 1073741824) {
            return new Uint8Array(await response.arrayBuffer());
          } else {
            if (!response.body) {
              throw new Error(`failed to load external data file: ${file}, no response body.`);
            }
            const reader = response.body.getReader();
            let buffer;
            try {
              buffer = new ArrayBuffer(fileSize);
            } catch (e) {
              if (e instanceof RangeError) {
                const pages = Math.ceil(fileSize / 65536);
                buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
              } else {
                throw e;
              }
            }
            let offset = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunkSize = value.byteLength;
              const chunk = new Uint8Array(buffer, offset, chunkSize);
              chunk.set(value);
              offset += chunkSize;
            }
            return new Uint8Array(buffer, 0, fileSize);
          }
        }
      } else if (file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (file instanceof Uint8Array) {
        return file;
      } else {
        return new Uint8Array(file);
      }
    };
  }
});

// web/lib/wasm/jsep/log.ts
var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
var init_log = __esm({
  "web/lib/wasm/jsep/log.ts"() {
    "use strict";
    init_wasm_common();
    logLevelPrefix = ["V", "I", "W", "E", "F"];
    doLog = (level, message) => {
      console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
    };
    configureLogger = ($configLogLevel, $debug) => {
      configLogLevel = $configLogLevel;
      debug = $debug;
    };
    LOG = (logLevel, msg) => {
      const messageLevel = logLevelStringToEnum(logLevel);
      const configLevel = logLevelStringToEnum(configLogLevel);
      if (messageLevel >= configLevel) {
        doLog(messageLevel, typeof msg === "function" ? msg() : msg);
      }
    };
    LOG_DEBUG = (...args) => {
      if (debug) {
        LOG(...args);
      }
    };
  }
});

// web/lib/wasm/jsep/tensor-view.ts
var createView;
var init_tensor_view = __esm({
  "web/lib/wasm/jsep/tensor-view.ts"() {
    "use strict";
    init_wasm_common();
    createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
  }
});

// web/lib/wasm/jsep/webgpu/types.ts
var init_types = __esm({
  "web/lib/wasm/jsep/webgpu/types.ts"() {
    "use strict";
  }
});

// web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
var init_gpu_data_manager = __esm({
  "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
    "use strict";
    init_log();
    init_types();
    bucketFreelist = /* @__PURE__ */ new Map([
      [64, 250],
      [128, 200],
      [256, 200],
      [512, 200],
      [2048, 230],
      [4096, 200],
      [8192, 50],
      [16384, 50],
      [32768, 50],
      [65536, 50],
      [131072, 50],
      [262144, 50],
      [524288, 50],
      [1048576, 50],
      [2097152, 30],
      [4194304, 20],
      [8388608, 10],
      [12582912, 10],
      [16777216, 10],
      [26214400, 15],
      [33554432, 22],
      [44236800, 2],
      [58982400, 6],
      // we don't want to cache the bucket sizes below but not caching them
      // results in some major performance hits for models like sd-turbo.
      [67108864, 6],
      [134217728, 6],
      [167772160, 6]
    ]);
    bucketArr = [];
    calcNormalizedBufferSize = (size) => Math.ceil(size / 16) * 16;
    calcBucketBufferSize = (size) => {
      for (let idx = 0; idx < bucketArr.length; idx++) {
        const sizeForBucket = bucketArr[idx];
        if (size <= sizeForBucket) {
          return sizeForBucket;
        }
      }
      return Math.ceil(size / 16) * 16;
    };
    guid = 1;
    createNewGpuDataId = () => guid++;
    downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
      const bufferSize = calcNormalizedBufferSize(originalSize);
      const gpuReadBuffer = backend.device.createBuffer(
        // eslint-disable-next-line no-bitwise
        { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
      );
      try {
        const commandEncoder = backend.getCommandEncoder();
        backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          gpuBuffer,
          0,
          gpuReadBuffer,
          0,
          bufferSize
        );
        backend.flush();
        await gpuReadBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = gpuReadBuffer.getMappedRange();
        if (getTargetBuffer) {
          const targetBuffer = getTargetBuffer();
          targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
          return targetBuffer;
        } else {
          return new Uint8Array(arrayBuffer.slice(0, originalSize));
        }
      } finally {
        gpuReadBuffer.destroy();
      }
    };
    GpuDataManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.buffersForUploadingPending = [];
        this.buffersPending = [];
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        for (const [key] of bucketFreelist) {
          bucketArr.push(key);
          this.freeBuffers.set(key, []);
          this.freeUniformBuffers.set(key, []);
        }
        this.sessionCount = 0;
      }
      upload(id, data) {
        const srcArrayBuffer = data.buffer;
        const srcOffset = data.byteOffset;
        const srcLength = data.byteLength;
        const size = calcNormalizedBufferSize(srcLength);
        const gpuDataCache = this.storageCache.get(id);
        if (!gpuDataCache) {
          throw new Error("gpu data for uploading does not exist");
        }
        if (gpuDataCache.originalSize !== srcLength) {
          throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
        }
        const gpuBufferForUploading = this.backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
        );
        const arrayBuffer = gpuBufferForUploading.getMappedRange();
        new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
        gpuBufferForUploading.unmap();
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
        this.buffersForUploadingPending.push(gpuBufferForUploading);
      }
      memcpy(sourceId, destinationId) {
        const sourceGpuDataCache = this.storageCache.get(sourceId);
        if (!sourceGpuDataCache) {
          throw new Error("source gpu data for memcpy does not exist");
        }
        const destinationGpuDataCache = this.storageCache.get(destinationId);
        if (!destinationGpuDataCache) {
          throw new Error("destination gpu data for memcpy does not exist");
        }
        if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
          throw new Error("inconsistent source and destination gpu data size");
        }
        const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          sourceGpuDataCache.gpuData.buffer,
          0,
          destinationGpuDataCache.gpuData.buffer,
          0,
          size
        );
      }
      registerExternalBuffer(buffer, originalSize, previous) {
        let id;
        if (previous) {
          id = previous[0];
          if (buffer === previous[1]) {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
            );
            return id;
          } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
            throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
          }
        } else {
          id = createNewGpuDataId();
        }
        this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
        LOG_DEBUG(
          "verbose",
          () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
        );
        return id;
      }
      unregisterExternalBuffer(id) {
        if (id !== void 0) {
          this.storageCache.delete(id);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
        }
      }
      // eslint-disable-next-line no-bitwise
      create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
        const bufferSize = calcBucketBufferSize(size);
        let gpuBuffer;
        const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
        const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
        if (isStorage || isUniform) {
          const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
          const buffers = freeBuffers.get(bufferSize);
          if (!buffers) {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          } else {
            if (buffers.length > 0) {
              gpuBuffer = buffers.pop();
            } else {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            }
          }
        } else {
          gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
        }
        const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
        this.storageCache.set(gpuData.id, { gpuData, originalSize: size });
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
        return gpuData;
      }
      get(id) {
        return this.storageCache.get(id)?.gpuData;
      }
      release(id) {
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          if (this.storageCache.size === 0) {
            return 0;
          } else {
            throw new Error("releasing data does not exist");
          }
        }
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
        this.storageCache.delete(id);
        this.buffersPending.push(cachedData.gpuData.buffer);
        return cachedData.originalSize;
      }
      async download(id, getTargetBuffer) {
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          throw new Error("data does not exist");
        }
        await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
      }
      refreshPendingBuffers() {
        for (const buffer of this.buffersForUploadingPending) {
          buffer.destroy();
        }
        this.buffersForUploadingPending = [];
        if (this.buffersPending.length === 0) {
          return;
        }
        if (this.backend.sessionStatus === "default") {
          for (const buffer of this.buffersPending) {
            const maxInFreeList = bucketFreelist.get(buffer.size);
            if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              const freelist = this.freeBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              const freelist = this.freeUniformBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else {
              buffer.destroy();
            }
          }
          this.buffersPending = [];
        } else {
          let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          if (!capturedBuffers) {
            capturedBuffers = [];
            this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
          }
          for (const buffer of this.buffersPending) {
            capturedBuffers.push(buffer);
          }
          this.buffersPending = [];
        }
      }
      dispose() {
        this.freeBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.freeUniformBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache.forEach((storage) => {
          storage.gpuData.buffer.destroy();
        });
        this.capturedPendingBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
      }
      onCreateSession() {
        this.sessionCount += 1;
      }
      onReleaseSession(sessionId) {
        const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
        if (pendingBuffers) {
          pendingBuffers.forEach((buffer) => {
            buffer.destroy();
          });
          this.capturedPendingBuffers.delete(sessionId);
        }
        this.sessionCount -= 1;
        if (this.sessionCount === 0) {
          LOG_DEBUG("warning", () => "[WebGPU] Clearing webgpu buffer cache");
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.storageCache = /* @__PURE__ */ new Map();
        }
      }
    };
    createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/wasm/jsep/util.ts
var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/wasm/jsep/util.ts"() {
    "use strict";
    MatMulUtil = class {
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape(
            [adims[arank - 2], adims[arank - 1]],
            [bdims[brank - 2], bdims[brank - 1]]
          );
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          const max = Math.max(aLen, bLen);
          if (aLen && bLen) {
            cdims[crank - i] = Math.max(aLen, bLen);
          } else {
            if (max > 1) {
              return void 0;
            }
            cdims[crank - i] = 0;
          }
        }
        return cdims;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape, finalShape) {
        const inputRank = shape.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
    };
    ShapeUtil = class _ShapeUtil {
      /**
       * calculate the size (number of elements)
       */
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      /**
       * convert dims corresponding to type change to pack. ex. uint8 data to uint32
       */
      static convertShape(dims, size = 4) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        }
        const newDims = new Array(rank);
        let i = rank - 1;
        while (i >= 0) {
          if (dims[i] % size === 0) {
            newDims[i] = dims[i] / size;
            break;
          }
          if (size % dims[i] !== 0) {
            throw new Error("cannot convert shape");
          }
          newDims[i] = 1;
          size /= dims[i];
          i--;
        }
        for (i--; i >= 0; i--) {
          newDims[i] = dims[i];
        }
        return newDims;
      }
      /**
       * calculate the size (number of elements) from the given axis (inclusive)
       */
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      /**
       * calculate the size (number of elements) to the given axis (exclusive)
       */
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      /**
       * calculate the size (number of elements) from and to the given axis [start, end)
       */
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] < 0) {
            throw new Error(
              // eslint-disable-next-line max-len
              "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
            );
          }
          size *= dims[i];
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      /**
       * normailze axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad2) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + (isChannelLast ? 1 : 2)],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(
              _PoolConvUtil.adjustPadAndReturnShape(
                inputDims[dim + 2],
                strides[dim],
                dilations[dim],
                kernelShape[dim],
                pads,
                dim,
                dim + inputDims.length - 2,
                autoPad
              )
            );
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/wasm/jsep/webgpu/ops/common.ts
var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, internalVariable, ShaderHelperImpl, createShaderHelper, getBroadcastDims;
var init_common = __esm({
  "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    WORKGROUP_SIZE = 64;
    getWgslMappedType = (type, components) => {
      if (components === 3) {
        throw new Error("vec3 has same alignment as vec4, use vec4 instead");
      }
      switch (type) {
        case 10 /* float16 */:
          return components > 1 ? `vec${components}<f16>` : "f16";
        case 1 /* float */:
          return components > 1 ? `vec${components}<f32>` : "f32";
        case 6 /* int32 */:
          return components > 1 ? `vec${components}<i32>` : "i32";
        case 12 /* uint32 */:
          return components > 1 ? `vec${components}<u32>` : "u32";
        case 7 /* int64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "i32"];
        case 13 /* uint64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "u32"];
        case 9 /* bool */:
          if (components !== 4) {
            throw new Error("bool must be vec4");
          }
          return ["u32", "vec4<bool>"];
        case 22 /* int4 */:
          return "i32";
        case 21 /* uint4 */:
          return "u32";
        default:
          throw new Error(`Unknown data type: ${type}`);
      }
    };
    tensorTypeToWsglStorageType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[0];
    };
    tensorTypeToWsglValueType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[1];
    };
    createTensorShapeVariables = (...dims) => {
      const programUniforms = [];
      dims.forEach((dim) => {
        if (dim.length !== 0) {
          programUniforms.push(
            { type: 12 /* uint32 */, data: dim },
            { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
          );
        }
      });
      return programUniforms;
    };
    getMaxComponents = (size) => {
      if (size % 4 === 0) {
        return 4;
      } else if (size % 2 === 0) {
        return 2;
      }
      return 1;
    };
    fillVector = (dataType = "f32", components, value = "0") => {
      if (!components || components === 1) {
        return `${dataType}(${value})`;
      }
      return `vec${components}<${dataType}>(${value})`;
    };
    castToF32 = (dataType, components, value) => {
      if (dataType === "f32") {
        return value;
      }
      if (components === 1) {
        return `f32(${value})`;
      }
      return `vec${components}<f32>(${value})`;
    };
    sumVector = (name, components) => {
      if (components === 4) {
        return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
      } else if (components === 2) {
        return `(${name}.x + ${name}.y)`;
      } else if (components === 3) {
        return `(${name}.x + ${name}.y + ${name}.z)`;
      }
      return name;
    };
    getElementAt = (name, index, length, type) => {
      if (name.startsWith("uniforms.") && length > 4) {
        if (typeof index === "string") {
          if (type === "f16") {
            return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
          } else {
            return `${name}[(${index}) / 4][(${index}) % 4]`;
          }
        } else {
          if (type === "f16") {
            return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
          } else {
            return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
          }
        }
      } else {
        return length > 1 ? `${name}[${index}]` : name;
      }
    };
    createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
      const useUniform = typeof shapeOrRank === "number";
      const rank = useUniform ? shapeOrRank : shapeOrRank.length;
      const rankIdentity = [...new Array(rank).keys()];
      const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
      const mappedType = getWgslMappedType(tensorType, components);
      const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
      const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
      const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
      const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
      const implementationUsed = {
        offsetToIndices: false,
        indicesToOffset: false,
        broadcastedIndicesToOffset: false,
        set: false,
        setByIndices: false,
        get: false,
        getByIndices: false
      };
      const uniformPrefix = useUniform ? "uniforms." : "";
      const shape = `${uniformPrefix}${name}_shape`;
      const strides = `${uniformPrefix}${name}_strides`;
      let o2iSnippet = "";
      for (let i = 0; i < rank - 1; i++) {
        o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
      }
      o2iSnippet += `indices[${rank - 1}] = current;`;
      const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
      const offsetToIndices = (varOffset) => {
        implementationUsed.offsetToIndices = true;
        return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
      };
      const offsets = [];
      if (rank >= 2) {
        for (let i = rank - 1; i >= 0; i--) {
          offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
        }
      }
      const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
      const indicesToOffset = (varIndices) => {
        implementationUsed.indicesToOffset = true;
        return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
      };
      const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
      const indicesGet = (varIndices, idx) => {
        if (rank < 2) {
          return `${varIndices}`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}`;
        }
      };
      const indicesSet = (varIndices, idx, value) => {
        if (rank < 2) {
          return `${varIndices}=${value};`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}=${value};`;
        }
      };
      const broadcastedIndicesToOffsetImplementation = {};
      const broadcastedIndicesToOffset = (varIndices, output) => {
        implementationUsed.broadcastedIndicesToOffset = true;
        const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
        if (implKey in broadcastedIndicesToOffsetImplementation) {
          return `${implKey}(${varIndices})`;
        }
        const offsets2 = [];
        for (let i = rank - 1; i >= 0; i--) {
          const idx = output.indicesGet("outputIndices", i + output.rank - rank);
          offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
        }
        broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
        return `${implKey}(${varIndices})`;
      };
      const setByOffset = (offset, value) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]=${value};`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByOffset = (offset) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `i32(${name}[${offset}].x)`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `u32(${name}[${offset}].x)`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
      const getImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
      })();
      const get = (...indices2) => {
        if (indices2.length !== rank) {
          throw new Error(`indices length must be ${rank}`);
        }
        const normalizedIndices = indices2.map(normalizeDim).join(",");
        if (rank === 0) {
          return getByOffset("0u");
        } else if (rank === 1) {
          return getByOffset(normalizedIndices[0]);
        } else {
          implementationUsed.get = true;
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}(${normalizedIndices})`;
        }
      };
      const getByIndices = (varIndices) => {
        if (rank < 2) {
          return getByOffset(varIndices);
        } else {
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}ByIndices(${varIndices})`;
        }
      };
      const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
      const setImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
      })();
      const set = (...indicesAndValue) => {
        if (indicesAndValue.length !== rank + 1) {
          throw new Error(`indices length must be ${rank}`);
        }
        const value = indicesAndValue[rank];
        if (typeof value !== "string") {
          throw new Error("value must be string");
        }
        const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
        if (rank === 0) {
          return setByOffset("0u", value);
        } else if (rank === 1) {
          return setByOffset(normalizedIndices[0], value);
        } else {
          implementationUsed.set = true;
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}(${normalizedIndices}, ${value})`;
        }
      };
      const setByIndices = (varIndices, value) => {
        if (rank < 2) {
          return setByOffset(varIndices, value);
        } else {
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}ByIndices(${varIndices}, ${value});`;
        }
      };
      const impl = () => {
        const impls = [];
        let needShapeStrides = false;
        if (implementationUsed.offsetToIndices) {
          impls.push(offsetToIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.indicesToOffset) {
          impls.push(indicesToOffsetImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.broadcastedIndicesToOffset) {
          Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
          needShapeStrides = true;
        }
        if (implementationUsed.set) {
          impls.push(setImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.setByIndices) {
          impls.push(setByIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.get) {
          impls.push(getImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.getByIndices) {
          impls.push(getByIndicesImplementation);
          needShapeStrides = true;
        }
        if (!useUniform && needShapeStrides) {
          impls.unshift(
            `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
            `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
          );
        }
        return impls.join("\n");
      };
      return {
        impl,
        type,
        offsetToIndices,
        indicesToOffset,
        broadcastedIndicesToOffset,
        indices,
        indicesGet,
        indicesSet,
        set,
        setByOffset,
        setByIndices,
        get,
        getByOffset,
        getByIndices,
        // isVec4,
        usage,
        name,
        strides,
        shape,
        rank
      };
    };
    inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
    outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
    internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
    ShaderHelperImpl = class {
      constructor(normalizedDispatchGroup, limits) {
        this.normalizedDispatchGroup = normalizedDispatchGroup;
        this.limits = limits;
        this.internalVariables = [];
        this.variables = [];
        this.uniforms = [];
        this.variableIndex = 0;
      }
      guardAgainstOutOfBoundsWorkgroupSizes(size) {
        const sizeInCode = typeof size === "number" ? `${size}u` : size;
        return `if (global_idx >= ${sizeInCode}) { return; }`;
      }
      mainStart(workgroupSize = WORKGROUP_SIZE) {
        const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
        const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
        const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
        if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
          );
        }
        if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
          );
        }
        const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
        const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
        const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
        return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
      }
      appendVariableUniforms(variable) {
        if (variable.rank !== 0) {
          if (variable.shape.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
          if (variable.strides.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
        }
      }
      declareVariable(variable, bindingIndex) {
        if (variable.usage === "internal") {
          throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
        }
        this.variables.push(variable);
        this.appendVariableUniforms(variable);
        const access = variable.usage === "input" ? "read" : "read_write";
        const storageType = variable.type.storage;
        return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
      }
      declareVariables(...variables) {
        return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
      }
      registerInternalVariable(variable) {
        if (variable.usage !== "internal") {
          throw new Error(
            "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
          );
        }
        this.internalVariables.push(variable);
        this.appendVariableUniforms(variable);
      }
      registerInternalVariables(...variables) {
        variables.forEach((v) => this.registerInternalVariable(v));
        return this;
      }
      registerUniform(name, type, length = 1) {
        this.uniforms.push({ name, type, length });
        return this;
      }
      registerUniforms(additionalUniforms) {
        this.uniforms = this.uniforms.concat(additionalUniforms);
        return this;
      }
      uniformDeclaration() {
        if (this.uniforms.length === 0) {
          return "";
        }
        const uniformSnippets = [];
        for (const { name, type, length } of this.uniforms) {
          if (length && length > 4) {
            if (type === "f16") {
              uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
            } else {
              uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
            }
          } else {
            const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
            uniformSnippets.push(`${name}:${typeTemp}`);
          }
        }
        return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
      }
      /**
       * Get additional implementation that needs to be added to the shader source.
       */
      get additionalImplementations() {
        return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
      }
      /**
       * Get the variable info of the shader program.
       */
      get variablesInfo() {
        if (this.uniforms.length === 0) {
          return void 0;
        }
        const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
        return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
      }
    };
    createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
    getBroadcastDims = (inShape, outShape) => {
      const inRank = inShape.length;
      const dims = [];
      for (let i = 0; i < inRank; i++) {
        const dim = inRank - 1 - i;
        const a = inShape[dim] || 1;
        const b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
          dims.unshift(dim);
        }
      }
      return dims;
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/transpose.ts
var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
var init_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
    };
    getAdjustedPerm = (inputRank, perm) => perm && perm.length !== inputRank ? [...new Array(inputRank).keys()].reverse() : perm;
    getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
    permFunctionBody = (perm, rank, input, output) => {
      let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
      for (let i = 0; i < rank; ++i) {
        reverseFunc += input.indicesSet("a", perm[i], `i[${i}]`);
      }
      return reverseFunc += "return a;}";
    };
    squeezeShape = (shape, adjustedPerm) => {
      const newShape = [];
      const newPerm = [];
      for (let i = 0; i < shape.length; ++i) {
        if (shape[i] !== 1) {
          newShape.push(shape[i]);
        }
        if (shape[adjustedPerm[i]] !== 1) {
          newPerm.push(adjustedPerm[i]);
        }
      }
      return { newShape, newPerm };
    };
    createTransposeProgramInfo = (inputTensor, permAttr) => {
      const inputDataType = inputTensor.dataType;
      const inputRank = inputTensor.dims.length;
      const perm = getAdjustedPerm(inputRank, permAttr);
      const outputShape = getOutputShape(inputTensor.dims, perm);
      const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
      const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
      const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
      const useShared = newShape.length === 2 && newPerm[0] > newPerm[1] || channelsLast || channelsFirst;
      let newInputShape = useShared ? newShape : inputTensor.dims;
      let newOutputShape = outputShape;
      if (useShared) {
        newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
        newOutputShape = [newInputShape[1], newInputShape[0]];
      }
      const input = inputVariable("a", inputDataType, newInputShape.length);
      const output = outputVariable("output", inputDataType, newOutputShape.length);
      const tileSize = 16;
      let getShaderSource;
      if (useShared) {
        getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
      } else {
        getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
      }
      return {
        name: useShared ? "TransposeShared" : "Transpose",
        shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
        getRunData: () => {
          const outputSize = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: useShared ? { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) } : { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(newInputShape, newOutputShape)
            ]
          };
        },
        getShaderSource
      };
    };
    transpose = (context, attributes) => {
      validateInputs(context.inputs);
      context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
    };
    parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
var init_reduce_shared = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_reduce();
    init_transpose();
    reduceOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate * candidate",
      logSumExp: "bestValue + exp(candidate)",
      l1: "bestValue + abs(candidate)",
      l2: "bestValue + candidate * candidate",
      logSum: "bestValue + candidate"
    };
    reduceSharedOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate",
      logSumExp: "bestValue + candidate",
      l1: "bestValue + candidate",
      l2: "bestValue + candidate",
      logSum: "bestValue + candidate"
    };
    reduceInitValues = {
      max: "_A[offset]",
      min: "_A[offset]",
      mean: "0",
      sum: "0",
      prod: "1",
      sumSquare: "0",
      logSumExp: "0",
      l1: "0",
      l2: "0",
      logSum: "0"
    };
    reduceOutputValues = {
      max: "bestValue",
      min: "bestValue",
      sum: "bestValue",
      prod: "bestValue",
      sumSquare: "bestValue",
      logSumExp: "log(bestValue)",
      l1: "bestValue",
      l2: "sqrt(bestValue)",
      logSum: "log(bestValue)"
    };
    getInnerMostAxes = (numInnerAxes, rank) => {
      const res = [];
      for (let i = rank - numInnerAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    };
    computeOutAndReduceShapes = (shape, axes) => {
      const outputShape = [];
      const rank = shape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputShape.push(shape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => shape[dim]);
      return [outputShape, reduceShape];
    };
    expandShapeToKeepDim = (shape, axes) => {
      const rank = shape.length + axes.length;
      const expandShape = [];
      let shapeIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          expandShape.push(shape[shapeIdx++]);
        } else {
          expandShape.push(1);
        }
      }
      return expandShape;
    };
    areAxesInnerMostDims = (axes, rank) => {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    };
    getAxesPermutation = (axes, rank) => {
      const res = [];
      if (!areAxesInnerMostDims(axes, rank)) {
        for (let i = 0; i < rank; ++i) {
          if (axes.indexOf(i) === -1) {
            res.push(i);
          }
        }
        axes.forEach((axis) => res.push(axis));
      }
      return res;
    };
    createReduceSharedProgramInfo = (name, shaderCache, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
      const inputShape = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const reduceSize = ShapeUtil.size(reduceShape);
      const input = inputVariable("_A", inputs[0].dataType, inputShape);
      const output = outputVariable("output", outputDataType, outputShape);
      const workgroupSize = 32;
      const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
      const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
        "outputIndex",
        `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
      )};
         }
        }`;
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: outputSize },
          programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
        })
      };
    };
    reduceCommon = (context, name, attributes, reduceType) => {
      const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
      let updatedAxes = updatedAttributes.axes;
      if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
        updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
      }
      const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
      let axes = normalizeAxes;
      let input = context.inputs[0];
      const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
      if (permutedAxes.length > 0) {
        input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
          inputs: [0],
          outputs: [-1]
        })[0];
        axes = getInnerMostAxes(axes.length, input.dims.length);
      }
      const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
      let finalOutputShape = outputShape;
      if (updatedAttributes.keepDims) {
        finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
      }
      context.compute(
        createReduceSharedProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["type"] },
          [input],
          reduceType,
          context.inputs[0].dataType,
          finalOutputShape,
          reduceShape
        ),
        { inputs: [input] }
      );
    };
    reduceMeanShared = (context, attributes) => {
      reduceCommon(context, "ReduceMeanShared", attributes, "mean");
    };
    reduceL1Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL1Shared", attributes, "l1");
    };
    reduceL2Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL2Shared", attributes, "l2");
    };
    reduceLogSumExpShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
    };
    reduceMaxShared = (context, attributes) => {
      reduceCommon(context, "ReduceMaxShared", attributes, "max");
    };
    reduceMinShared = (context, attributes) => {
      reduceCommon(context, "ReduceMinShared", attributes, "min");
    };
    reduceProdShared = (context, attributes) => {
      reduceCommon(context, "ReduceProdShared", attributes, "prod");
    };
    reduceSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumShared", attributes, "sum");
    };
    reduceSumSquareShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
    };
    reduceLogSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce.ts
var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
var init_reduce = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    init_reduce_shared();
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("Reduce op requires 1 or 2 inputs.");
      }
      if (inputs.length === 2 && inputs[1].dims.length !== 1) {
        throw new Error("Invalid axes input dims.");
      }
    };
    noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
    createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
      const outputShape = [];
      const inputShape = inputs[0].dims;
      const inputRank = inputShape.length;
      const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
      const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
      inputShape.forEach((d, i) => {
        if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
          if (keepDims) {
            outputShape.push(1);
          }
        } else {
          outputShape.push(d);
        }
      });
      const outputRank = outputShape.length;
      const outputSize = ShapeUtil.size(outputShape);
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const input = inputVariable("_A", inputs[0].dataType, inputRank);
        const output = outputVariable("output", outputDataType, outputRank);
        const ops = reduceOp(input, output, axes);
        let reduceOps2 = ops[2];
        for (let k = 0, l = 0; k < inputRank; k++) {
          if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
            if (keepDims) {
              l++;
            }
            reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
          } else {
            idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
            l++;
          }
        }
        return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
      };
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    createReduceAttributesFromInputs = (inputs, attributes) => {
      const axes = [];
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
      }
      return createAttributeWithCacheKey({
        axes,
        keepDims: attributes.keepDims,
        noopWithEmptyAxes: attributes.noopWithEmptyAxes
      });
    };
    runReduceProgram = (context, name, attributes, reduceOp) => {
      const inputs = context.inputs;
      const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
      context.compute(
        createReduceProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
          [inputs[0]],
          updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
          updatedAttributes.axes,
          inputs[0].dataType,
          updatedAttributes.keepDims,
          updatedAttributes.noopWithEmptyAxes
        ),
        { inputs: [0] }
      );
    };
    reduceLogSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
    };
    reduceL1Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += abs(${input.getByIndices("input_indices")});`,
        ""
      ];
      runReduceProgram(context, "ReduceL1", attributes, reduceOp);
    };
    reduceL2Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
        "value = sqrt(value);"
      ];
      runReduceProgram(context, "ReduceL2", attributes, reduceOp);
    };
    reduceLogSumExpNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += exp(${input.getByIndices("input_indices")});`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
    };
    reduceMaxNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(input.indicesSet("input_indices", k, 0));
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = max(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMax", attributes, reduceOp);
    };
    reduceMeanNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output, axes) => {
        let size = 1;
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= context.inputs[0].dims[k];
          }
        }
        return [
          "var sum = f32(0);",
          "",
          `sum += f32(${input.getByIndices("input_indices")});`,
          `let value = ${output.type.value}(sum / ${size});`
        ];
      };
      runReduceProgram(context, "ReduceMean", attributes, reduceOp);
    };
    reduceMinNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = min(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMin", attributes, reduceOp);
    };
    reduceProdNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(1);`,
        "",
        `value *= ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceProd", attributes, reduceOp);
    };
    reduceSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceSum", attributes, reduceOp);
    };
    reduceSumSquareNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += t * t;`,
        ""
      ];
      runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
    };
    useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
      if (axes.length === 0) {
        return noopWithEmptyAxes;
      }
      let outputSize = 1;
      let reduceSize = 1;
      for (let dim = 0; dim < axes.length; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputSize *= shape[dim];
        } else {
          reduceSize *= shape[dim];
        }
      }
      return reduceSize < 32 && outputSize > 1024;
    };
    reduceMean = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMeanNaive(context, attributes);
      } else {
        reduceMeanShared(context, attributes);
      }
    };
    reduceL1 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL1Naive(context, attributes);
      } else {
        reduceL1Shared(context, attributes);
      }
    };
    reduceL2 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL2Naive(context, attributes);
      } else {
        reduceL2Shared(context, attributes);
      }
    };
    reduceLogSumExp = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumExpNaive(context, attributes);
      } else {
        reduceLogSumExpShared(context, attributes);
      }
    };
    reduceMax = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMaxNaive(context, attributes);
      } else {
        reduceMaxShared(context, attributes);
      }
    };
    reduceMin = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMinNaive(context, attributes);
      } else {
        reduceMinShared(context, attributes);
      }
    };
    reduceProd = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceProdNaive(context, attributes);
      } else {
        reduceProdShared(context, attributes);
      }
    };
    reduceSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumNaive(context, attributes);
      } else {
        reduceSumShared(context, attributes);
      }
    };
    reduceSumSquare = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumSquareNaive(context, attributes);
      } else {
        reduceSumSquareShared(context, attributes);
      }
    };
    reduceLogSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumNaive(context, attributes);
      } else {
        reduceLogSumShared(context, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/argminmax.ts
var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
var init_argminmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
    "use strict";
    init_wasm_common();
    init_attribute_with_cache_key();
    init_reduce();
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */) {
        throw new Error("Invalid input type.");
      }
    };
    argMin = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "ArgMin",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    argMax = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "argMax",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/attention.ts
var validateAttentionInputs, initVarStub, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
var init_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_types();
    init_common();
    validateAttentionInputs = (inputs, attributes) => {
      const input = inputs[0];
      const weights = inputs[1];
      const bias = inputs[2];
      const maskIndex = inputs[3];
      const past = inputs[4];
      const attentionBias = inputs[5];
      if (past && attentionBias) {
        throw new Error("Attention cannot have both past and attention_bias");
      }
      if (input.dims.length !== 3) {
        throw new Error('Input "input" must have 3 dimensions');
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[1];
      const inputHiddenSize = input.dims[2];
      if (bias.dims.length !== 1) {
        throw new Error('Input "bias" is expected to have 1 dimensions');
      }
      if (weights.dims.length !== 2) {
        throw new Error('Input "weights" is expected to have 2 dimensions');
      }
      if (weights.dims[0] !== inputHiddenSize) {
        throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
      }
      if (bias.dims[0] !== weights.dims[1]) {
        throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
      }
      let qHiddenSize = bias.dims[0] / 3;
      let kHiddenSize = qHiddenSize;
      let vHiddenSize = kHiddenSize;
      if (attributes.qkvHiddenSizes.length > 0) {
        if (attributes.qkvHiddenSizes.length !== 3) {
          throw new Error("qkv_hidden_sizes attribute should have 3 elements");
        }
        for (const sz of attributes.qkvHiddenSizes) {
          if (sz % attributes.numHeads !== 0) {
            throw new Error("qkv_hidden_sizes should be divisible by num_heads");
          }
        }
        qHiddenSize = attributes.qkvHiddenSizes[0];
        kHiddenSize = attributes.qkvHiddenSizes[1];
        vHiddenSize = attributes.qkvHiddenSizes[2];
      }
      const kvSequenceLength = sequenceLength;
      if (qHiddenSize !== kHiddenSize) {
        throw new Error("qkv_hidden_sizes first element should be same as the second");
      }
      if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
        throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
      }
      let pastSequenceLength = 0;
      if (past) {
        if (kHiddenSize !== vHiddenSize) {
          throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
        }
        if (past.dims.length !== 5) {
          throw new Error('Input "past" must have 5 dimensions');
        }
        if (past.dims[0] !== 2) {
          throw new Error('Input "past" first dimension must be 2');
        }
        if (past.dims[1] !== batchSize) {
          throw new Error('Input "past" second dimension must be batch_size');
        }
        if (past.dims[2] !== attributes.numHeads) {
          throw new Error('Input "past" third dimension must be num_heads');
        }
        if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
          throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
        }
        if (!attributes.pastPresentShareBuffer) {
          pastSequenceLength = past.dims[3];
        }
      }
      const totalSequenceLength = kvSequenceLength + pastSequenceLength;
      const maxSequenceLength = -1;
      const maskType = 0 /* none */;
      if (maskIndex) {
        throw new Error("Mask not supported");
      }
      if (past) {
        throw new Error("past is not supported");
      }
      if (attentionBias) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" must have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize,
        hiddenSize: qHiddenSize,
        vHiddenSize,
        headSize: Math.floor(qHiddenSize / attributes.numHeads),
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias: false,
        passPastInKv: false,
        qkvFormat: 1 /* qkvBNSH */
      };
    };
    initVarStub = (seqLensInput, totalSequenceLengthInput, initPastSequenceLength) => {
      if (totalSequenceLengthInput && seqLensInput) {
        return `
      let total_sequence_length_input = u32(${totalSequenceLengthInput.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${seqLensInput?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `;
      } else {
        return `
    ${initPastSequenceLength ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `;
      }
    };
    createInPlaceSoftmaxProgramInfo = (input, batchSize, numHeads, pastSequenceLength, sequenceLength, totalSequenceLength, seqLens, totalSequenceLengthInput) => {
      const components = getMaxComponents(seqLens ? 1 : totalSequenceLength);
      let WG = 64;
      const totalSequenceLengthComp = totalSequenceLength / components;
      if (totalSequenceLengthComp < WG) {
        WG = 32;
      }
      const elementsPerThread = Math.ceil(totalSequenceLength / components / WG);
      const programUniforms = [
        { type: 12 /* uint32 */, data: batchSize },
        { type: 12 /* uint32 */, data: numHeads },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLengthComp },
        { type: 12 /* uint32 */, data: elementsPerThread }
      ];
      const dataType = tensorTypeToWsglStorageType(input.dataType, components);
      const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
      const inputDependencies = ["type"];
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const getShaderSource = (shaderHelper) => {
        const inputHelper = outputVariable("x", input.dataType, input.dims, components);
        const inputHelpers = [inputHelper];
        const seqLensInputHelper = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputHelper) {
          inputHelpers.push(seqLensInputHelper);
        }
        const totalSequenceLengthInputHelper = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputHelper) {
          inputHelpers.push(totalSequenceLengthInputHelper);
        }
        const elemValueType = tensorTypeToWsglValueType(input.dataType);
        const uniforms = [
          { name: "batch_size", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "sequence_length", type: "u32" },
          { name: "total_sequence_length", type: "u32" },
          { name: "elements_per_thread", type: "u32" }
        ];
        return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputHelpers)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${initVarStub(seqLensInputHelper, totalSequenceLengthInputHelper, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${seqLens ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "thread_max_vector";
            case 2:
              return "max(thread_max_vector.x, thread_max_vector.y)";
            case 4:
              return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "sum_vector";
            case 2:
              return "sum_vector.x + sum_vector.y";
            case 4:
              return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(1.0) / ${elemValueType}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${seqLens ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${inputHelper.type.value}(${elemValueType}(0));
        }` : ""};
  }`;
      };
      return {
        name: "AttentionProbsSoftmax",
        shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
        getShaderSource,
        getRunData: () => ({
          outputs: [],
          dispatchGroup: { x: Math.ceil(totalSequenceLength / WG), y: sequenceLength, z: batchSize * numHeads },
          programUniforms
        })
      };
    };
    createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, pastSequenceLength, seqLens, totalSequenceLengthInput) => {
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
      const presentKey = outputCount > 1 && pastKey;
      const kvNumHeads = parameters.kvNumHeads ? parameters.kvNumHeads : parameters.numHeads;
      const presentKeyShape = presentKey ? [parameters.batchSize, kvNumHeads, totalSequenceLength, parameters.headSize] : void 0;
      const nReps = parameters.nReps ? parameters.nReps : 1;
      const alpha = parameters.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : parameters.scale;
      const components = getMaxComponents(parameters.headSize);
      const vectorizedHeadSize = parameters.headSize / components;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(totalSequenceLength / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: parameters.sequenceLength },
        { type: 12 /* uint32 */, data: vectorizedHeadSize },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 1 /* float */, data: alpha },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: parameters.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastKey) {
        inputDependencies.push("type");
      }
      if (attentionBias) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
      if (presentKey) {
        outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const qInput = inputVariable("q", q.dataType, q.dims, components);
        const kInput = inputVariable("key", key.dataType, key.dims, components);
        const inputVars = [qInput, kInput];
        if (feedPastKey) {
          const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
          inputVars.push(pastKeyInput);
        }
        if (attentionBias) {
          inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputVariable) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputVariable) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", q.dataType, probsShape);
        const outputVars = [output];
        if (presentKey) {
          outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
        }
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${feedPastKey && presentKey ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${presentKey ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
          if (feedPastKey && presentKey) {
            return `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
          } else {
            return `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`;
          }
        })()}
      ${presentKey ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
          switch (components) {
            case 1:
              return "value";
            case 2:
              return "value.x + value.y";
            case 4:
              return "value.x + value.y + value.z + value.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
      };
      return {
        name: "AttentionProbs",
        shaderCache: {
          hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
          inputDependencies
        },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
      const nReps = params.nReps ? params.nReps : 1;
      const repeatedVHiddenSize = params.vHiddenSize * nReps;
      const presentValue = outputCount > 1 && pastValue;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const presentValueShape = presentValue ? [params.batchSize, kvNumHeads, totalSequenceLength, params.headSize] : void 0;
      const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(params.vHeadSize / TILE_SIZE),
        y: Math.ceil(params.sequenceLength / TILE_SIZE),
        z: params.batchSize * params.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: params.sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: params.vHeadSize },
        { type: 12 /* uint32 */, data: params.numHeads },
        { type: 12 /* uint32 */, data: params.headSize },
        { type: 12 /* uint32 */, data: repeatedVHiddenSize },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: params.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastValue) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
      if (presentValue) {
        outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
        const vHelper = inputVariable("v", v.dataType, v.dims);
        const inputVars = [probsHelper, vHelper];
        if (feedPastValue) {
          inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLens) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInput) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", probs.dataType, outputShape);
        const outputVars = [output];
        if (presentValue) {
          outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
        }
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "v_hidden_size", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileV: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${feedPastValue && presentValue ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${presentValue ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
          if (feedPastValue && presentValue) {
            return `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `;
          } else {
            return `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`;
          }
        })()}
        ${presentValue ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
      };
      return {
        name: "AttentionScore",
        shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
      const pastSequenceLength = outputCount > 1 ? parameters.pastSequenceLength : 0;
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
      const inputsK = [q, k];
      if (outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
        inputsK.push(pastKey);
      }
      if (attentionBias) {
        inputsK.push(attentionBias);
      }
      if (seqLens) {
        inputsK.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsK.push(totalSequenceLengthInput);
      }
      const probs = context.compute(
        createAttentionProbsProgramInfo(
          outputCount,
          q,
          k,
          pastKey,
          attentionBias,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: inputsK, outputs: outputCount > 1 ? [-1, 1] : [-1] }
      )[0];
      context.compute(
        createInPlaceSoftmaxProgramInfo(
          probs,
          parameters.batchSize,
          parameters.numHeads,
          pastSequenceLength,
          parameters.sequenceLength,
          totalSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: seqLens && totalSequenceLengthInput ? [probs, seqLens, totalSequenceLengthInput] : [probs], outputs: [] }
      );
      const inputsV = [probs, v];
      if (outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
        inputsV.push(pastValue);
      }
      if (seqLens) {
        inputsV.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsV.push(totalSequenceLengthInput);
      }
      context.compute(
        createVxAttentionScoreProgramInfo(
          outputCount,
          probs,
          v,
          pastValue,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        {
          inputs: inputsV,
          outputs: outputCount > 1 ? [0, 2] : [0]
        }
      );
    };
    prepare = (context, parameters) => {
      const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
      const M = parameters.sequenceLength;
      const K = parameters.inputHiddenSize;
      const N = parameters.headSize;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(parameters.headSize / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
      const programUniforms = [
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: K },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
        const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
        const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
        const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
        const dataType = input.type.storage;
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "ldb", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
      };
      return context.compute(
        {
          name: "AttentionPrepare",
          shaderCache: { inputDependencies: ["type", "type", "type"] },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
            ],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        },
        { inputs, outputs: [-1, -1, -1] }
      );
    };
    attention = (context, attributes) => {
      const params = validateAttentionInputs(context.inputs, attributes);
      const [q, k, v] = prepare(context, params);
      return applyAttention(
        context,
        q,
        k,
        v,
        context.inputs[4],
        void 0,
        void 0,
        void 0,
        context.inputs[5],
        params
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
var init_batch_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs4 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs");
      }
      const checkShapeEqual = (actual, expected, message) => {
        const r = expected.length;
        if (r !== actual.length) {
          throw new Error(`${message}: num dimensions != ${r}`);
        }
        expected.forEach((v, i) => {
          if (v !== actual[i]) {
            throw new Error(`${message}: dim[${i}] do not match`);
          }
        });
      };
      if (inputs[0].dims.length > 1) {
        const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
        checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
        checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
        checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
        checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
      } else {
        checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
        checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
        checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
        checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
      }
    };
    createBatchNormInferenceProgramInfo = (inputs, attributes) => {
      const { epsilon, spatial, format } = attributes;
      const yShape = inputs[0].dims;
      const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
      const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
      const outputSize = ShapeUtil.size(yShape) / components;
      const useShapesUniforms = spatial;
      const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
      const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
      const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
      const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
      const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
      const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
      const calcCOffset = () => {
        let cOffset = "";
        if (spatial) {
          cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
        } else {
          if (format === "NCHW") {
            cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
          } else {
            cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
            for (let i = 1; i < scale.rank; i++) {
              cOffset += `cIndices[${i}] = outputIndices[${i}];`;
            }
            cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
          }
        }
        return cOffset;
      };
      const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BatchNormalization",
        shaderCache: {
          hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
          inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
        },
        getShaderSource: getInferenceModeShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
        })
      };
    };
    parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    batchNorm = (context, attributes) => {
      const { inputs, outputCount } = context;
      const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
      if (env2.webgpu.validateInputContent) {
        validateInputs4(inputs, updatedAttributes);
      }
      if (attributes.trainingMode) {
        throw new Error("BatchNormalization trainingMode is not supported yet.");
      } else {
        context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-add.ts
var validateInputs5, createBiasAddProgramInfo, biasAdd;
var init_bias_add = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
    "use strict";
    init_util();
    init_common();
    validateInputs5 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![320, 640, 1280].includes(inputs[0].dims[2])) {
        throw new Error("number of channels should be 320, 640 or 1280");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasAddProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims;
      const channels = inputs[0].dims[2];
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, outputShape, 4);
      const bias = inputVariable("bias", dataType, [channels], 4);
      const residual = inputVariable("residual", dataType, outputShape, 4);
      const output = outputVariable("output", dataType, outputShape, 4);
      const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BiasAdd",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasAdd = (context) => {
      validateInputs5(context.inputs);
      context.compute(createBiasAddProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/unary-op.ts
var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
var init_unary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
      const vecSize = Math.ceil(datasize / 4);
      let expression = "";
      if (typeof funcCall === "string") {
        expression = `${funcCall}(a)`;
      } else {
        expression = funcCall("a");
      }
      const input = inputVariable("inputData", inputDataType, [vecSize], 4);
      const output = outputVariable("outputData", outputDataType, [vecSize], 4);
      const uniforms = [{ name: "vec_size", type: "u32" }];
      if (additionalUniformsType) {
        uniforms.push(...additionalUniformsType);
      }
      return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
    };
    createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
      const programUniforms = [
        { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
      ];
      if (additionalUniforms) {
        programUniforms.push(...additionalUniforms);
      }
      return {
        name,
        shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
        getShaderSource: (shaderHelper) => createElementwiseProgramShader(
          shaderHelper,
          ShapeUtil.size(input.dims),
          input.dataType,
          outputDataType,
          funcCall,
          additionalImplementation,
          additionalUniformsType
        ),
        getRunData: (inputTensors) => ({
          outputs: [{ dims: input.dims, dataType: outputDataType }],
          dispatchGroup: {
            x: Math.ceil(
              ShapeUtil.size(inputTensors[0].dims) / 64 / 4
              /* vec size */
            )
          },
          programUniforms
        })
      };
    };
    abs = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
    };
    acos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
    };
    acosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
    };
    asin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
    };
    asinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
    };
    atan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
    };
    atanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
    };
    parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    cast = (context, attributes) => {
      let func;
      switch (attributes.to) {
        case 10 /* float16 */:
          func = "vec4<f16>";
          break;
        case 1 /* float */:
          func = "vec4<f32>";
          break;
        case 12 /* uint32 */:
          func = "vec4<u32>";
          break;
        case 6 /* int32 */:
          func = "vec4<i32>";
          break;
        case 9 /* bool */:
          func = "vec4<bool>";
          break;
        default:
          throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
      }
      context.compute(
        createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
      );
    };
    generateClipAttributesFromInputs = (inputs) => {
      let min;
      let max;
      const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
      const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
      switch (inputs[0].dataType) {
        case 1 /* float */:
          min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
          max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
          break;
        case 10 /* float16 */:
          min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
          max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
          break;
        default:
          throw new Error("Unsupport data type");
      }
      return createAttributeWithCacheKey({ min, max });
    };
    clip = (context, clipAttributes) => {
      const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Clip",
          (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
          void 0,
          attributes.cacheKey,
          void 0,
          [
            { type: context.inputs[0].dataType, data: attributes.min },
            { type: context.inputs[0].dataType, data: attributes.max }
          ],
          [
            { name: "min", type: dataType },
            { name: "max", type: dataType }
          ]
        ),
        { inputs: [0] }
      );
    };
    ceil = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
    };
    cos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
    };
    cosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
    };
    parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    elu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Elu",
          (a) => `elu_vf32(${a})`,
          `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
          attributes.cacheKey
        )
      );
    };
    erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
    erf = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
    };
    exp = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
    };
    floor = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
    };
    gelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Gelu",
          (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
          erfImpl(dataType)
        )
      );
    };
    leakyRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "LeakyRelu",
          (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
          `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
    };
    not = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
    };
    neg = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
    };
    reciprocal = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
    };
    relu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Relu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
        )
      );
    };
    sigmoid = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
    };
    parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
      attributes
    );
    hardSigmoid = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "HardSigmoid",
          (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
          void 0,
          attributes.cacheKey
        )
      );
    };
    sin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
    };
    sinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
    };
    sqrt = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
    };
    tan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
    };
    tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
    tanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
    };
    fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
    fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
    fastGelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "FastGelu",
          fastGeluExpression,
          fastGeluImpl(dataType),
          void 0,
          context.inputs[0].dataType
        )
      );
    };
    thresholdedRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "ThresholdedRelu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
          `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
      return 0;
    };
    log = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
    };
    quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
    quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
    quickgelu = (context, attributes) => {
      const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "QuickGelu",
          quickGeluExpression,
          quickGeluImpl(dType, attributes.alpha),
          attributes.cacheKey,
          context.inputs[0].dataType
        )
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
var init_bias_split_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
    "use strict";
    init_util();
    init_common();
    init_unary_op();
    validateInputs6 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
        throw new Error("hidden state should be 2560, 5120 or 10240");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasSplitGeluProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims.slice();
      outputShape[2] = outputShape[2] / 2;
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
      const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
      const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
      const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
      return {
        name: "BiasSplitGelu",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasSplitGelu = (context) => {
      validateInputs6(context.inputs);
      context.compute(createBiasSplitGeluProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/binary-op.ts
var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
var init_binary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
      let expressionScalar;
      let expressionVector;
      if (typeof funcCall === "string") {
        expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
      } else if (typeof funcCall === "function") {
        expressionScalar = expressionVector = funcCall;
      } else {
        expressionScalar = funcCall.scalar;
        expressionVector = funcCall.vector;
      }
      const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("aData", typeA, dimsA.length, 4);
      const b = inputVariable("bData", typeB, dimsB.length, 4);
      let assignment;
      if (vectorize) {
        if (doBroadcast) {
          const isAOneElement = ShapeUtil.size(dimsA) === 1;
          const isBOneElement = ShapeUtil.size(dimsB) === 1;
          const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
          if (isAOneElement || isBOneElement) {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(
                isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
              )
            );
          } else {
            assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
              "global_idx",
              expressionVector(
                sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
              )
            )}
          `;
          }
        } else {
          assignment = output.setByOffset(
            "global_idx",
            expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
          );
        }
      } else {
        if (!doBroadcast) {
          throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
        }
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `aData[indexA${x}][componentA${x}]`;
          const expressionB = `bData[indexB${x}][componentB${x}]`;
          return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
      const isBroadcast = !ShapeUtil.areEqual(a.dims, b.dims);
      let outputShape = a.dims;
      let outputSize = ShapeUtil.size(a.dims);
      let vectorize = false;
      let sharedDimensionDivisibleBy4 = false;
      const cacheKeyAux = [isBroadcast];
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(a.dims, b.dims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
        const isAOneElement = ShapeUtil.size(a.dims) === 1;
        const isBOneElement = ShapeUtil.size(b.dims) === 1;
        const aLastDimDivisibleBy4 = a.dims.length > 0 && a.dims[a.dims.length - 1] % 4 === 0;
        const bLastDimDivisibleBy4 = b.dims.length > 0 && b.dims[b.dims.length - 1] % 4 === 0;
        cacheKeyAux.push(isAOneElement);
        cacheKeyAux.push(isBOneElement);
        cacheKeyAux.push(aLastDimDivisibleBy4);
        cacheKeyAux.push(bLastDimDivisibleBy4);
        let sharedDimension = 1;
        for (let i = 1; i < outputShape.length; i++) {
          const dimA = a.dims[a.dims.length - i] ?? 1;
          const dimB = b.dims[b.dims.length - i] ?? 1;
          if (dimA === dimB) {
            sharedDimension *= dimA;
          } else {
            break;
          }
        }
        if (sharedDimension % 4 === 0) {
          sharedDimensionDivisibleBy4 = true;
          vectorize = true;
        } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
          vectorize = true;
        }
      } else {
        vectorize = true;
      }
      cacheKeyAux.push(vectorize);
      return {
        name,
        shaderCache: {
          hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
          inputDependencies: ["rank", "rank"]
        },
        getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
          shaderHelper,
          a.dims,
          b.dims,
          outputShape,
          vectorize,
          isBroadcast,
          sharedDimensionDivisibleBy4,
          funcCall,
          a.dataType,
          b.dataType,
          outputDataType,
          additionalImplementation
        ),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* component size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
            ...createTensorShapeVariables(a.dims, b.dims, outputShape)
          ]
        })
      };
    };
    runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
      context.compute(
        createBinaryOpProgramInfo(
          name,
          cacheKey ?? "",
          context.inputs[0],
          context.inputs[1],
          funcCall,
          additionalImplementation,
          outputDataType
        )
      );
    };
    add = (context) => {
      runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
    };
    div = (context) => {
      runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
    };
    equal = (context) => {
      runBinaryOp(
        context,
        "Equal",
        { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    mul = (context) => {
      runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
    };
    pow = (context) => {
      const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
      const roundStr = type === "i32" ? "round" : "";
      runBinaryOp(
        context,
        "Pow",
        { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
        `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
      );
    };
    sub = (context) => {
      runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
    };
    greater = (context) => {
      runBinaryOp(
        context,
        "Greater",
        { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    less = (context) => {
      runBinaryOp(
        context,
        "Less",
        { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    greaterOrEqual = (context) => {
      runBinaryOp(
        context,
        "GreaterOrEqual",
        { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    lessOrEqual = (context) => {
      runBinaryOp(
        context,
        "LessOrEqual",
        { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/concat.ts
var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
var init_concat = __esm({
  "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs7 = (inputs, axis) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const referenceIndex = 0;
      const referenceInput = inputs[referenceIndex];
      const inputType = referenceInput.dataType;
      const inputRank = referenceInput.dims.length;
      inputs.forEach((input, i) => {
        if (i === referenceIndex) {
          return;
        }
        if (input.dataType !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputRank) {
          throw new Error("input tensors should have the same shape");
        }
        input.dims.forEach((dim, i2) => {
          if (i2 !== axis && dim !== referenceInput.dims[i2]) {
            throw new Error("non concat dimensions must match");
          }
        });
      });
    };
    calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
    assignOutputData = (inputs, output) => {
      const numberOfTensors = inputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
        }
      }
      return codeLines.join("\n");
    };
    createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
      const outputSize = ShapeUtil.size(outputShape);
      const sizeInConcatAxis = new Array(inputs.length);
      const inputVars = new Array(inputs.length);
      let previousSum = 0;
      const inputDependencies = [];
      const inputRanks = [];
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
      for (let i = 0; i < inputs.length; ++i) {
        previousSum += inputs[i].dims[adjustedAxis];
        sizeInConcatAxis[i] = previousSum;
        inputRanks.push(inputs[i].dims.length);
        inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
        inputDependencies.push("rank");
        programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
      }
      for (let i = 0; i < inputs.length; ++i) {
        programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const output = outputVariable("output", dataType, outputShape.length);
      const indicesAxis = output.indicesGet("indices", adjustedAxis);
      const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
      const getShaderSource = (shaderHelper) => `

  ${(() => {
        shaderHelper.registerUniform("outputSize", "u32");
        for (let i = 0; i < inputs.length; i++) {
          shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
        }
        return shaderHelper.declareVariables(...inputVars, output);
      })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
      return {
        name: "Concat",
        shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    concat = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      validateInputs7(inputs, adjustedAxis);
      const outputShape = inputShape.slice();
      outputShape[adjustedAxis] = inputs.reduce(
        (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
        0
      );
      const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
      context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
        inputs: nonEmptyInputs
      });
    };
    parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    getActivationSnippet = (attributes, valueType, baseType = "f32") => {
      switch (attributes.activation) {
        case "Relu":
          return `value = max(value, ${valueType}(0.0));`;
        case "Sigmoid":
          return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
        case "Clip":
          return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
        case "HardSigmoid":
          return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
        case "LeakyRelu":
          return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
        case "Tanh":
          return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
        case "":
          return "";
        default:
          throw new Error(`Unsupported activation ${attributes.activation}`);
      }
    };
    appendActivationUniformsData = (attributes, programUniform) => {
      if (attributes.activation === "Clip") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.clipMax },
          { type: 1 /* float */, data: attributes.clipMin }
        );
      } else if (attributes.activation === "HardSigmoid") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        );
      } else if (attributes.activation === "LeakyRelu") {
        programUniform.push({ type: 1 /* float */, data: attributes.alpha });
      }
    };
    appendActivationUniforms = (attributes, uniforms) => {
      if (attributes.activation === "Clip") {
        uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
      } else if (attributes.activation === "HardSigmoid") {
        uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
      } else if (attributes.activation === "LeakyRelu") {
        uniforms.push({ name: "alpha", type: "f32" });
      }
    };
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes?.activation || "";
      if (activation === "HardSigmoid") {
        const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
        return { activation, alpha, beta };
      } else if (activation === "Clip") {
        const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
        return { activation, clipMax, clipMin };
      } else if (activation === "LeakyRelu") {
        const [alpha] = attributes?.activation_params || [0.01];
        return { activation, alpha };
      }
      return { activation };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
var typeSnippet, biasSnippet;
var init_activation_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
    "use strict";
    typeSnippet = (component, dataType) => {
      switch (component) {
        case 1:
          return dataType;
        case 2:
          return `vec2<${dataType}>`;
        case 3:
          return `vec3<${dataType}>`;
        case 4:
          return `vec4<${dataType}>`;
        default:
          throw new Error(`${component}-component is not supported.`);
      }
    };
    biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
var utilFunctions;
var init_conv_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
    "use strict";
    utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
var init_matmul_packed_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    init_activation_util();
    writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      } else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      }
    };
    calculateResultSnippet = (transposeA, innerElementSize) => {
      if (transposeA) {
        return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
      } else {
        return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
      }
    };
    makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
      const tileAOuter = workgroupSize[1] * workPerThread[1];
      const tileBOuter = workgroupSize[0] * workPerThread[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      const innerElementSize = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
        throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
      }
      return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
    };
    writeDataToSubASnippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      } else {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      }
    };
    readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
    makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
      const tileAOuter = workPerThread[1] * workgroupSize[1];
      const tileBOuter = workPerThread[0] * workgroupSize[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
        throw new Error(
          `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
        );
      }
      const rowPerThreadA = tileAHight / workgroupSize[1];
      const colPerThreadA = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
      return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
    };
    matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, batchShapes, isChannelsLast = false) => {
      const [batchAShape, batchBShape, batchShape] = batchShapes;
      const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
      const broadCastADims = getBroadcastDims(batchAShape, batchShape);
      const broadCastBDims = getBroadcastDims(batchBShape, batchShape);
      const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
      const getAIndices = () => {
        const aRank = aVariable.rank;
        const batchRank = batchVariable.rank;
        let resStr = `var aIndices: ${aVariable.type.indices};`;
        for (let i = aRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
          resStr += `
aIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
        }
        broadCastADims.forEach((i) => {
          resStr += `
aIndices[${i}] = 0;`;
        });
        resStr += `
aIndices[${aRank - 2}] = u32(row);
                   aIndices[${aRank - 1}] = u32(colIn);`;
        return resStr;
      };
      const getBIndices = () => {
        const bRank = bVariable.rank;
        const batchRank = batchVariable.rank;
        let resStr = `var bIndices: ${bVariable.type.indices};`;
        for (let i = bRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
          resStr += `
bIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
        }
        broadCastBDims.forEach((i) => {
          resStr += `
bIndices[${i}] = 0;`;
        });
        resStr += `
bIndices[${bRank - 2}] = u32(row);
                   bIndices[${bRank - 1}] = u32(colIn);`;
        return resStr;
      };
      const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${getAIndices()}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${getBIndices()}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
      return source;
    };
    createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outerDimsA = aShape.slice(0, -2);
      const outerDimsB = bShape.slice(0, -2);
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const dimAOuter = aShape[aShape.length - 2];
      const dimInner = aShape[aShape.length - 1];
      const dimBOuter = bShape[bShape.length - 1];
      const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const workgroupSize = [8, 8, 1];
      const dispatch = [
        Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
        Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
      ];
      const components = isVec4 ? 4 : 1;
      const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
      const aRank = aShapeTemp.length;
      const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
      const bRank = bShapeTemp.length;
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length > 2;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const batchRank = outerDims.length;
        const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const A = inputVariable("a", inputs[0].dataType, aRank, components);
        const B = inputVariable("b", inputs[1].dataType, bRank, components);
        const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
        const inputVariables = [A, B];
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
        }
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const declareFunctions = matMulReadWriteFnSource(
          components,
          hasBias,
          applyActivation,
          [batchDims, A, B, output],
          [outerDimsA, outerDimsB, outerDims],
          isChannelsLast
        );
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
      };
      return {
        name: "MatMul",
        shaderCache: {
          hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
var init_conv2d_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
      const getXSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "resData = x[xIndex];";
          case 3:
            return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
          case 4:
            return "resData = x[xIndex / 4];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
          case 4:
            return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
      const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
      const sampleW = `${getWSnippet(innerElementSizeW)}`;
      const resType = typeSnippet(innerElementSize, dataType);
      const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
      const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
      const applyActivation = getActivationSnippet(attributes, resType, dataType);
      const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
      return userCode;
    };
    createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const tileAOuter = workGroupSize[1] * elementsPerThread[1];
      const tileBOuter = workGroupSize[0] * elementsPerThread[0];
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const fitAOuter = dimAOuter % tileAOuter === 0;
      const fitBOuter = dimBOuter % tileBOuter === 0;
      const fitInner = dimInner % tileInner === 0;
      const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "pad", type: "i32", length: 2 },
          { name: "stride", type: "i32", length: 2 },
          { name: "dilation", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
          isChannelsLast,
          fitAOuter,
          fitBOuter,
          fitInner,
          hasBias,
          attributes,
          elementsSize[0],
          elementsSize[1],
          elementsSize[2],
          t
        )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          t,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DMatMul",
        shaderCache: {
          hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
var init_conv3d_naive_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    init_fuse_utils();
    init_activation_util();
    arrayProduct = (arr) => {
      let product = 1;
      for (let i = 0; i < arr.length; i++) {
        product *= arr[i];
      }
      return product;
    };
    parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
    getEffectiveFilterSize = (filterSize, dilation) => {
      if (dilation <= 1) {
        return filterSize;
      }
      return filterSize + (filterSize - 1) * (dilation - 1);
    };
    computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
      const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
      return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
    };
    computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
      }
      const outShape = [0, 0, 0, outChannels];
      for (let index = 0; index < 3; index++) {
        if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
          outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
        }
      }
      return outShape;
    };
    get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
      let padInfo;
      let outDepth;
      let outHeight;
      let outWidth;
      if (pad2 === "VALID") {
        pad2 = 0;
      }
      if (typeof pad2 === "number") {
        padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (Array.isArray(pad2)) {
        if (!pad2.every((val, _, arr) => val === arr[0])) {
          throw Error(`Unsupported padding parameter: ${pad2}`);
        }
        padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2[0]
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (pad2 === "SAME_UPPER") {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, front, back };
      } else {
        throw Error(`Unknown padding parameter: ${pad2}`);
      }
      return { padInfo, outDepth, outHeight, outWidth };
    };
    computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
      let batchSize, inDepth, inHeight, inWidth, inChannels;
      if (dataFormat === "channelsLast") {
        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
      const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
      const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
      const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
      const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
      const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
        pad2,
        inDepth,
        inHeight,
        inWidth,
        strideDepth,
        strideHeight,
        strideWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth
      );
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape = [0, 0, 0, 0, 0];
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inDepth,
        inHeight,
        inWidth,
        inChannels,
        outDepth,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideDepth,
        strideHeight,
        strideWidth,
        filterDepth,
        filterHeight,
        filterWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationDepth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    };
    createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
      const isChannelLast = dataFormat === "channelsLast";
      const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const isVec4 = false;
      const workGroupSize = [64, 1, 1];
      const dispatchLayout = { x: outputShape.map((_, i) => i) };
      const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
      LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: pads },
        { type: 12 /* uint32 */, data: attributes.strides },
        { type: 12 /* uint32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length === 3;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "pads", type: "u32", length: pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length },
          { name: "dilations", type: "u32", length: attributes.dilations.length }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        let declareFunctions = "";
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        const resType = typeSnippet(innerElementSize, t);
        const applyActivation = getActivationSnippet(attributes, resType, t);
        return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
      };
      return {
        name: "Conv3DNaive",
        shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
var init_conv_grouped = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += b[output_channel];" : "";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const isChannelLast = attributes.format === "NHWC";
      const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
      const outputChannelsPerGroup = outputChannels / attributes.group;
      const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: attributes.dilations },
        { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(
        ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
      );
      const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
      programUniforms.push(
        ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
      );
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "dilations", type: "u32", length: attributes.dilations.length },
          { name: "strides", type: "u32", length: 2 },
          { name: "pads", type: "u32", length: 2 },
          { name: "output_channels_per_group", type: "u32" }
        ];
        appendActivationUniforms(attributes, uniforms);
        const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
      };
      return {
        name: "GroupedConv",
        shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const components = getMaxComponents(outputShape[3]);
      const outputNumber = getMaxComponents(outputShape[2]);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
      const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
      const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
      const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "pads", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
      };
      return {
        name: "GroupedConv-Vectorize",
        shaderCache: {
          hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
          inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul.ts
var createNaiveMatmulProgramInfo, validateInputs8, matMul;
var init_matmul = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_matmul_packed_webgpu();
    init_common();
    init_fuse_utils();
    createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const M = aShape[aShape.length - 2];
      const N = bShape[bShape.length - 1];
      const K = aShape[aShape.length - 1];
      const components = getMaxComponents(N);
      const aComponents = getMaxComponents(K);
      const outputNumber = getMaxComponents(M);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const hasBias = inputs.length > 2;
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const outputShapeInShader = [batchSize, M, N];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
      const getShaderSource = (shaderHelper) => {
        const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
        const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
        const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const inputVariables = [a, b];
        let processBias = "";
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
        }
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const broadCastADims = getBroadcastDims(outerDimsA, outerDims);
        const broadCastBDims = getBroadcastDims(outerDimsB, outerDims);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const getIndices = (variable, broadCastDims) => {
          const rank = variable.rank;
          const name = variable.name;
          if (rank === 2) {
            return `var ${name}_indices = ${variable.type.indices}(0u, 0u);`;
          }
          const batchRank = batchDims.rank;
          let resStr = `var ${name}_indices: ${variable.type.indices};`;
          for (let i = rank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
${name}_indices[${i}] = ${batchRank > 1 ? `batch_indices[${j}]` : "batch_indices"};`;
          }
          broadCastDims.forEach((i) => {
            resStr += `
${name}_indices[${i}] = 0;`;
          });
          resStr += `${name}_indices[${rank - 2}] = 0u;
                     ${name}_indices[${rank - 1}] = 0u;`;
          return resStr;
        };
        const calcResult = () => {
          let calcStr = `var a_data: ${a.type.value};`;
          for (let i = 0; i < aComponents; i++) {
            calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
          }
          for (let i = 0; i < outputNumber; i++) {
            calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
            for (let j = 0; j < aComponents; j++) {
              calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
            }
          }
          return calcStr;
        };
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}
    ${getIndices(a, broadCastADims)}
    let a_offset = ${a.indicesToOffset("a_indices")};
    ${getIndices(b, broadCastBDims)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
      };
      return {
        name: "MatMulNaive",
        shaderCache: {
          hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
          inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    validateInputs8 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
    };
    matMul = (context) => {
      validateInputs8(context.inputs);
      const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const N = outputShape[outputShape.length - 1];
      const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
      if (N < 8 && K < 8) {
        context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      } else {
        context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv.ts
var calculateOutputShape, weightTransposeAttribute, validateInputs9, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
var init_conv = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
    "use strict";
    init_util();
    init_conv2d_mm_webgpu();
    init_conv3d_naive_webgpu();
    init_matmul_packed_webgpu();
    init_conv_grouped();
    init_fuse_utils();
    init_matmul();
    init_transpose();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputShape = inputSpatialShapeWithPad.map(
        (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
      );
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      return outputShape;
    };
    weightTransposeAttribute = [2, 3, 1, 0];
    validateInputs9 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length > 5) {
        throw new Error("greater than 5D is not supported");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (kernelShape.length < inputs[1].dims.length - 2) {
        kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
      }
      for (let i = 2; i < inputs[1].dims.length; ++i) {
        if (kernelShape[i - 2] === 0) {
          kernelShape[i - 2] = inputs[1].dims[i];
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.format === "NHWC",
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads });
      return newAttributes;
    };
    parseConvAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernel_shape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.w_is_const();
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputShape = calculateOutputShape(
        inputs[0].dims,
        inputs[1].dims,
        attributes.dilations,
        attributes.pads,
        attributes.strides,
        isChannelsLast
      );
      if (attributes.group !== 1) {
        const convInputs2 = [inputs[0]];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          convInputs2.push(transposedWeight2);
        } else {
          convInputs2.push(inputs[1]);
        }
        if (inputs.length === 3) {
          convInputs2.push(inputs[2]);
        }
        const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
        if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
          context.compute(
            createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
            { inputs: convInputs2 }
          );
        } else {
          context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
            inputs: convInputs2
          });
        }
        return;
      }
      const hasBias = inputs.length === 3;
      const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
      const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
      if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
        const batch = outputShape[0];
        let xReshaped, wReshaped, matmulOutputShape;
        const matmulInputs = [];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          if (sameSize) {
            const sharedDim = inputHeight * inputWidth * inputChannels;
            xReshaped = inputs[0].reshape([1, batch, sharedDim]);
            wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
            matmulOutputShape = [1, batch, outChannels];
          } else {
            xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
            wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
            matmulOutputShape = [batch, outHeight * outWidth, outChannels];
          }
          matmulInputs.push(xReshaped);
          matmulInputs.push(wReshaped);
        } else {
          xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
          wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
          matmulOutputShape = [batch, outChannels, outHeight * outWidth];
          matmulInputs.push(wReshaped);
          matmulInputs.push(xReshaped);
        }
        if (hasBias) {
          matmulInputs.push(inputs[2]);
        }
        const N = matmulOutputShape[2];
        const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(
            createNaiveMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        } else {
          context.compute(
            createMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        }
        return;
      }
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convInputs = [inputs[0], transposedWeight];
      if (hasBias) {
        convInputs.push(inputs[2]);
      }
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      context.compute(
        createConv2DMatMulProgramInfo(
          convInputs,
          attributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads,
          squeezeOutputShapeFunction
        ),
        { inputs: convInputs }
      );
    };
    conv1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
      const strides = [1].concat(attributes.strides);
      const dilations = [1].concat(attributes.dilations);
      const kernelShape = [1].concat(attributes.kernelShape);
      const adjustedAttributes = getAdjustedConvAttributes(
        { ...attributes, pads, strides, dilations, kernelShape },
        inputs
      );
      conv2d(
        context,
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      );
    };
    conv3d = (context, inputs, attributes) => {
      const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
      const convInfo = computeConv3DInfo(
        inputs[0].dims,
        inputs[1].dims,
        attributes.strides,
        attributes.dilations,
        pads,
        false,
        format
      );
      context.compute(
        createConv3DNaiveProgramInfo(
          inputs,
          adjustedAttributes,
          convInfo.outShape,
          [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
          [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
          format
        )
      );
    };
    conv = (context, attributes) => {
      validateInputs9(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        conv1d(context, attributes);
      } else if (context.inputs[0].dims.length === 5) {
        conv3d(context, context.inputs, attributes);
      } else {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
        conv2d(context, context.inputs, adjustedAttributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts
var conv2dTransposeCommonSnippet, createConv2DTransposeMatMulProgramInfo;
var init_conv_backprop_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dTransposeCommonSnippet = (isChannelsLast, addBias = false, attributes, type, innerElementSize = 4) => {
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";
          case 4:
            return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${type}(v0, v1, v2, v3);
            `;
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readASnippet = `
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      let outRow = ${row} / outWidth;
      let outCol = ${row} % outWidth;

      let WRow = ${col} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${col} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${xHeight}) || fract(xR) > 0.0) {
        return ${type}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${xWidth}) || fract(xC) > 0.0) {
        return ${type}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${col} % inChannels;
      ${coordASnippet}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${innerElementSize}];`;
      const sampleA = isChannelsLast ? `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${readASnippet}
      }
      return ${type}(0.0);` : `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${readASnippet}
      }
      return ${type}(0.0);`;
      const sampleW = `
      let col = colIn * ${innerElementSize};
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${isChannelsLast ? "row < uniforms.dim_inner && col < uniforms.dim_b_outer" : "row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${getWSnippet(innerElementSize)}
      }
      return ${type}(0.0);
      `;
      const applyActivation = getActivationSnippet(attributes, type);
      const userCode = `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleA : sampleW}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleW : sampleA}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${type}) {
    let col = colIn * ${innerElementSize};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${innerElementSize}] = value;
    }
  }`;
      return userCode;
    };
    createConv2DTransposeMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && inChannels % 4 === 0 && inChannels % 3 && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? 4 : 1;
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const components = isVec4 ? 4 : 1;
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (filterDims[0] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (filterDims[1] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
      ];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations },
        { type: 6 /* int32 */, data: filterDims },
        { type: 6 /* int32 */, data: pads }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, components);
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, 1);
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const inputVariables = [x, w];
        let declareFunctions = "";
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${bias.type.value} {
            return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
          }`;
        }
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "dilations", type: "i32", length: 2 },
          { name: "filter_dims", type: "i32", length: filterDims.length },
          { name: "pads", type: "i32", length: pads.length }
        ];
        appendActivationUniforms(attributes, uniforms);
        const elemType = tensorTypeToWsglStorageType(inputs[0].dataType, 1);
        if (elemType !== "f16" && elemType !== "f32") {
          throw new Error(`elemType ${elemType} is not supported.`);
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)};
        ${declareFunctions}
        ${conv2dTransposeCommonSnippet(isChannelsLast, hasBias, attributes, x.type.value, innerElementSize)}
        ${isVec4 ? makeMatMulPackedVec4Source(
          elementsPerThread,
          workGroupSize,
          elemType,
          void 0,
          !isChannelsLast,
          tileInner
        ) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          elemType,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DTransposeMatMul",
        shaderCache: { hint: `${attributes.cacheKey};${elementsPerThread};${workGroupSize};${isVec4}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
var createConvTranspose2DOpProgramShaderSource, createConvTranspose2DProgramInfo;
var init_conv_backprop_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    createConvTranspose2DOpProgramShaderSource = (shaderHelper, inputs, outputShape, hasBias, is1DimensionDispatch, isVec4 = false, dataType, uniforms, isChannelsLast = false) => {
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      const workPerThread = isVec4 ? 2 : 1;
      let declareFunctions = `
  fn setOutputAtIndex(flatIndex : u32, value : ${isVec4 ? `vec4<${dataType}>` : dataType}) {
    result[flatIndex] = ${isVec4 ? `vec4<${dataType}>` : dataType}(value);
  }`;
      if (hasBias) {
        declareFunctions += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${isVec4 ? `vec4<${dataType}>` : dataType} {
      return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
    }`;
      }
      const components = isVec4 ? 4 : 1;
      const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
      const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, components);
      const inputVariables = [dy, w];
      if (hasBias) {
        inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
      }
      const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
      const codeSnippet4 = `{
        let batch: u32 = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${is1DimensionDispatch ? "global_id.y" : "workgroup_id.y"} * ${workPerThread};
        let d1: u32 = ${is1DimensionDispatch ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${dataType}>, ${workPerThread}>;
        for (var i = 0; i < ${workPerThread}; i++) {
          dotProd[i] = vec4<${dataType}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${dataType}(dyCorner.x) + ${dataType}(wR)) / ${dataType}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${dataType}(dyCorner.y) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let dyC2 = (${dataType}(dyCorner.y) + 1.0 + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dy.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<${dataType}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${channelDim}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${workPerThread}; i = i + 1) {
          let value = dotProd[i] + ${hasBias ? "bias[c+i]" : `vec4<${dataType}>(0.0)`};
          ${output.set("batch", "r", "c + i", "d1", "value")};
        }
      }`;
      const codeSnippet = `
          let outputIndices = ${output.offsetToIndices("global_idx")};
          let batch = ${output.indicesGet("outputIndices", 0)};
          let d1 = ${output.indicesGet("outputIndices", channelDim)};
          let r = ${output.indicesGet("outputIndices", rowDim)};
          let c = ${output.indicesGet("outputIndices", colDim)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${dataType}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${isChannelsLast ? dy.get("batch", "idyR", "idyC", "inputChannel") : dy.get("batch", "inputChannel", "idyR", "idyC")};
                let wValue = ${w.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${hasBias ? "bias[d1]" : `${dataType}(0.0)`};
          ${output.setByOffset("global_idx", "value")};
        `;
      return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
  ${declareFunctions}

    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${isVec4 ? codeSnippet4 : codeSnippet}}`;
    };
    createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const outputShape = attributes.outputShape;
      const outputSize = ShapeUtil.size(outputShape);
      const dispatch = [Math.ceil(outputSize / 64), 1, 1];
      LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
      const isChannelsLast = attributes.format === "NHWC";
      const inputDependencies = ["rank", "rank"];
      const strides = [attributes.strides[0], attributes.strides[1]];
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const dilations = [attributes.dilations[0], attributes.dilations[1]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor(attributes.pads[1] + attributes.pads[3]) / 2
      ];
      const isVec4 = false;
      const group = attributes.group;
      const wShape = inputs[1].dims;
      const inputChannelsPerGroup = wShape[0] / group;
      const outputChannelsPerGroup = wShape[1];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: strides },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: dilations },
        { type: 12 /* uint32 */, data: effectiveFilterDims },
        { type: 6 /* int32 */, data: pads },
        { type: 12 /* uint32 */, data: inputChannelsPerGroup },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
      ];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const is1DimensionDispatch = dispatch[1] === 1 && dispatch[2] === 1;
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "u32", length: strides.length },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "dilations", type: "u32", length: filterDims.length },
          { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
          { name: "pads", type: "i32", length: pads.length },
          { name: "input_channels_per_group", type: "u32" },
          { name: "output_channels_per_group", type: "u32" }
        ];
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        return `${createConvTranspose2DOpProgramShaderSource(
          shaderHelper,
          inputs,
          outputShape,
          hasBias,
          is1DimensionDispatch,
          isVec4,
          dataType,
          uniforms,
          isChannelsLast
        )}`;
      };
      return {
        name: "ConvTranspose2D",
        shaderCache: { hint: `${attributes.cacheKey};`, inputDependencies },
        getRunData: () => ({
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs10, weightTransposePerm, convTranspose2d, convTranspose1d, convTranspose;
var init_conv_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
    "use strict";
    init_conv_backprop_mm_webgpu();
    init_conv_backprop_webgpu();
    init_fuse_utils();
    init_transpose();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateOutputShape = outputShape.length === 0;
      if (outputPadding.length < spatialRank) {
        outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
      }
      const batchSize = inputShape[0];
      const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
      for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
        const inSize = inputShape[j];
        const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateOutputShape) {
          outputShape.push(
            strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
        kernelShape.length = 0;
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const isChannelsLast = attributes.format === "NHWC";
      kernelShape.splice(0, 0, inputs[1].dims[0]);
      kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const outputPadding = attributes.outputPadding.slice();
      const inputShape = inputs[0].dims;
      let dilations = attributes.dilations.slice();
      if (dilations.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        dilations = new Array(spatialRank).fill(1);
      }
      let strides = attributes.strides.slice();
      if (strides.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        strides = new Array(spatialRank).fill(1);
      }
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        dilations,
        attributes.autoPad,
        attributes.group,
        pads,
        strides,
        isChannelsLast,
        outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
      return newAttributes;
    };
    parseConvTransposeAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernelShape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.wIsConst();
      const outputPadding = attributes.outputPadding;
      const outputShape = attributes.outputShape;
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        outputPadding,
        outputShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    validateInputs10 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
        throw new Error("currently only support 2-dimensional conv");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
      if (dilationsSet && attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
      if (stridesSet && attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
      if (padsSet && attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
      if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
    };
    weightTransposePerm = [2, 3, 1, 0];
    convTranspose2d = (context, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
      const isChannelsLast = attributes.format === "NHWC";
      const outputShape = adjustedAttributes.outputShape;
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      if (adjustedAttributes.group !== 1 || outChannels === 1 && inputChannels === 1) {
        context.compute(createConvTranspose2DProgramInfo(inputs, adjustedAttributes));
        return;
      }
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposePerm), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convTransposeInputs = [inputs[0], transposedWeight];
      const hasBias = inputs.length === 3;
      if (hasBias) {
        if (!isChannelsLast && inputs[2].dims.length === 1) {
          convTransposeInputs.push(inputs[2].reshape([inputs[2].dims[0], 1, 1]));
        } else {
          convTransposeInputs.push(inputs[2]);
        }
      }
      context.compute(
        createConv2DTransposeMatMulProgramInfo(
          convTransposeInputs,
          adjustedAttributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads
        ),
        { inputs: convTransposeInputs }
      );
    };
    convTranspose1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      let kernelShape = attributes.kernelShape;
      if (kernelShape.length === 0 || kernelShape[0] === 0) {
        kernelShape = [context.inputs[1].dims[2]];
      }
      let dilations = attributes.dilations;
      if (dilations.length === 0 || dilations[0] === 0) {
        dilations = [1];
      }
      let strides = attributes.strides;
      if (strides.length === 0 || strides[0] === 0) {
        strides = [1];
      }
      let pads = attributes.pads;
      if (pads.length === 0) {
        pads = [0, 0];
      }
      pads = [0, pads[0], 0, pads[1]];
      strides = [1].concat(strides);
      dilations = [1].concat(dilations);
      kernelShape = [1].concat(kernelShape);
      const adjustedAttributes = getAdjustedConvTransposeAttributes(
        { ...attributes, pads, strides, dilations, kernelShape },
        inputs
      );
      context.compute(
        createConvTranspose2DProgramInfo(
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        )
      );
    };
    convTranspose = (context, attributes) => {
      validateInputs10(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        convTranspose1d(context, attributes);
      } else {
        convTranspose2d(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/cumsum.ts
var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
var init_cumsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
      const outputSize = ShapeUtil.size(inputShape);
      const rank = inputShape.length;
      const input = inputVariable("input", inputType, rank);
      const output = outputVariable("output", inputType, rank);
      const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
      const axis = ShapeUtil.normalizeAxis(axisValue, rank);
      const getShaderSource = (shaderHelper) => {
        const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
        const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
        const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
        const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
        return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
      };
      return {
        name: "CumSum",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: inputShape, dataType: inputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 12 /* uint32 */, data: axis },
            ...createTensorShapeVariables(inputShape, inputShape)
          ]
        }),
        getShaderSource
      };
    };
    cumsum = (context, attributes) => {
      const inputShape = context.inputs[0].dims;
      const inputType = context.inputs[0].dataType;
      const axis = context.inputs[1];
      context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
    };
    parseCumSumAttributes = (attributes) => {
      const exclusive = attributes.exclusive === 1;
      const reverse = attributes.reverse === 1;
      return createAttributeWithCacheKey({ exclusive, reverse });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
var validateInputs11, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
var init_depth_to_space = __esm({
  "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs11 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("DepthToSpace requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("DepthToSpace requires 4D input.");
      }
    };
    permFunctionBody2 = (perm, rank, input, output) => {
      const reverseFunc = [];
      reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
      }
      reverseFunc.push("return a;}");
      return reverseFunc.join("\n");
    };
    createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
      let n, h, w, c;
      let shape;
      let perm;
      const isChannelLast = attributes.format === "NHWC";
      const blocksize = attributes.blocksize;
      const isDCRmode = attributes.mode === "DCR";
      if (isChannelLast) {
        [n, h, w, c] = inputTensor.dims;
        shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
        perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
      } else {
        [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
        shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
        perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      }
      const reshapedInputTensor = inputTensor.reshape(shape);
      const reshapedInputRank = reshapedInputTensor.dims.length;
      const inputDataType = inputTensor.dataType;
      const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
      const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
      return {
        name: "DepthToSpace",
        shaderCache: {
          hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
          inputDependencies: ["rank"]
        },
        getRunData: (inputs) => {
          const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
          const outputSize = ShapeUtil.size(outputShape);
          const shapeBeforePerm = reshapedInputTensor.dims;
          const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
          return {
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
            ]
          };
        },
        getShaderSource
      };
    };
    depthToSpace = (context, attributes) => {
      validateInputs11(context.inputs);
      context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
    };
    parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
      blocksize: attributes.blocksize,
      mode: attributes.mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/einsum.ts
var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
var init_einsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    symbolPattern = "[a-zA-Z]|\\.\\.\\.";
    termPattern = "(" + symbolPattern + ")+";
    termPatternOnly = "^" + termPattern + "$";
    lhsPattern = "(" + termPattern + ",)*" + termPattern;
    lhsPatternOnly = "^" + lhsPattern + "$";
    EinsumTerm = class {
      constructor(inputIndex = -1) {
        this.symbolToIndices = /* @__PURE__ */ new Map();
        this.inputIndex = inputIndex;
      }
      // Add a symbol to the term
      addSymbol(symbol, index) {
        let value = this.symbolToIndices.get(symbol);
        if (value === void 0) {
          value = [index];
        } else {
          value.push(index);
        }
        this.symbolToIndices.set(symbol, value);
      }
      // -1 for output and 0, 1, 2, ... for inputs
    };
    EinsumEquation = class {
      constructor(inputs, equation) {
        this.equation = equation;
        this.hasEllipsis = false;
        this.symbolToInfo = /* @__PURE__ */ new Map();
        this.lhs = new Array();
        this.outputDims = [];
        let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
        if (!lhs.match(RegExp(lhsPatternOnly))) {
          throw new Error("Invalid LHS term");
        }
        const inputTerms = lhs.split(",");
        inputTerms.forEach((inputTerm, index) => {
          const dims = inputs[index].dims.slice();
          if (!inputTerm.match(RegExp(termPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const einsumTerm = this.processTerm(inputTerm, true, dims, index);
          this.lhs.push(einsumTerm);
        });
        if (rhs === "") {
          rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
        } else {
          if (!rhs.match(RegExp(termPattern))) {
            throw new Error("Invalid RHS");
          }
        }
        const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
        rhsSymbols?.forEach((symbol) => {
          if (symbol === "...") {
            this.outputDims = this.outputDims.concat(this.ellipsisDims);
          } else {
            const info = this.symbolToInfo.get(symbol);
            if (info === void 0) {
              throw new Error("Invalid RHS symbol");
            }
            this.outputDims.push(info.dimValue);
          }
        });
        this.rhs = this.processTerm(rhs, false, this.outputDims);
      }
      // End of EinsumEqation constructor
      // Add a symbol to the equation
      addSymbol(symbol, dimValue, inputIndex) {
        let info = this.symbolToInfo.get(symbol);
        if (info !== void 0) {
          if (info.dimValue !== dimValue && info.count !== 1) {
            throw new Error("Dimension mismatch");
          } else {
            info.count++;
            info.inputIndices.push(inputIndex);
          }
        } else {
          info = { count: 1, dimValue, inputIndices: [inputIndex] };
        }
        this.symbolToInfo.set(symbol, info);
      }
      // Process one input/output term
      processTerm(term, isInput, dims, index = -1) {
        const rank = dims.length;
        let ellipsis = false;
        let ellipsisDims = [];
        let nextDim = 0;
        if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
          throw new Error("Invalid LHS term");
        }
        const indexSymbols = term.match(RegExp(symbolPattern, "g"));
        const einsumTerm = new EinsumTerm(index);
        indexSymbols?.forEach((symbol, i) => {
          if (symbol === "...") {
            if (ellipsis) {
              throw new Error("Only one ellipsis is allowed per input term");
            }
            ellipsis = true;
            const ellipsisDimLength = rank - indexSymbols.length + 1;
            if (ellipsisDimLength < 0) {
              throw new Error("Ellipsis out of bounds");
            }
            ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
            if (this.hasEllipsis) {
              if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                throw new Error("Ellipsis dimensions mismatch");
              }
            } else if (isInput) {
              this.hasEllipsis = true;
              this.ellipsisDims = ellipsisDims;
            } else {
              throw new Error("Ellipsis must be specified in the LHS");
            }
            for (let j = 0; j < ellipsisDims.length; j++) {
              const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
              einsumTerm.addSymbol(symbol2, i + j);
              this.addSymbol(symbol2, dims[nextDim++], index);
            }
          } else {
            einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
            this.addSymbol(symbol, dims[nextDim++], index);
          }
        });
        return einsumTerm;
      }
      // Output dimensions of the equation
    };
    appendMax = (name) => name + "_max";
    createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
      const ranks = inputShapes.map((dims) => dims.length);
      const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
      const outputSize = ShapeUtil.size(outputShape);
      const output = outputVariable("output", dataType, outputShape.length);
      const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
        (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
      );
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const initProd = "var prod = 1.0;";
        const initSum = "var sum = 0.0;";
        const updateSum = "sum += prod;";
        const reduceOpsSetIndices = [];
        const reduceOpsLoopHeaders = [];
        const reduceOpsLoopFooters = [];
        const reduceOpCompute = [];
        const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
        einsumEquation.symbolToInfo.forEach((info, symbol) => {
          if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
            const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
            if (outputIndex !== void 0) {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    idxCopy.push(
                      `${inputVars[i].indicesSet(
                        `input${i}Indices`,
                        index,
                        output.indicesGet("outputIndices", outputIndex)
                      )}`
                    );
                  });
                }
              });
            }
          } else {
            einsumEquation.lhs.forEach((term, i) => {
              if (info.inputIndices.includes(i)) {
                const indices = term.symbolToIndices.get(symbol);
                if (indices === void 0) {
                  throw new Error("Invalid symbol error");
                }
                indices.forEach((index) => {
                  reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                });
                reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
              }
            });
            reduceOpsLoopHeaders.push(
              `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
            );
            reduceOpsLoopFooters.push("}");
          }
        });
        const reduceOps2 = isReduceOpsWithoutLoop ? [
          ...idxCopy,
          `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
        ] : [
          ...idxCopy,
          initSum,
          ...reduceOpsLoopHeaders,
          ...reduceOpsSetIndices,
          initProd,
          ...reduceOpCompute,
          updateSum,
          ...reduceOpsLoopFooters
        ];
        return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
      };
      return {
        name: "Einsum",
        shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
        getRunData: () => {
          const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
          programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
          const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
          programUniforms.push(...createTensorShapeVariables(outputShape));
          return {
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    einsum = (context, attributes) => {
      const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
      const outputShape = einsumEquation.outputDims;
      const inputShapes = context.inputs.map((input, _) => input.dims);
      context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
    };
    parseEinsumAttributes = (attributes) => {
      const equation = attributes.equation.replace(/\s+/g, "");
      return createAttributeWithCacheKey({ equation });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/expand.ts
var validateInputs12, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
var init_expand = __esm({
  "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Expand requires 2 input.");
      }
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
      let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
      for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
        if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
          throw new Error("Expand requires shape to be broadcastable to input");
        }
      }
    };
    getAdjustedShape = (shape1, shape2) => {
      const diff = shape1.length - shape2.length;
      const shape = [];
      for (let i = 0; i < diff; ++i) {
        shape.push(shape1[i]);
      }
      for (let i = 0; i < shape2.length; ++i) {
        shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
      }
      return shape;
    };
    calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
    createExpandProgramInfo = (inputs) => {
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      const outputShape = calculateOutputShape2(inputShape, shape);
      const dataType = inputs[0].dataType;
      const components = dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", dataType, inputShape.length, components);
        const output = outputVariable("output", dataType, outputShape.length, components);
        let assignment;
        if (dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
        } else {
          assignment = `
        let outputIndices = ${output.offsetToIndices("global_idx")};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        ${output.setByOffset("global_idx", input.getByOffset("inputOffset"))}
      }`;
        }
        return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        ...createTensorShapeVariables(inputShape, outputShape)
      ];
      return {
        name: "Expand",
        shaderCache: { hint: `${outputShape.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    expand = (context) => {
      validateInputs12(context.inputs);
      context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
var createFastGeluProgramInfo, fastGelu2;
var init_fast_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_unary_op();
    createFastGeluProgramInfo = (inputTensors) => {
      const dataType = inputTensors[0].dataType;
      const outputSize = ShapeUtil.size(inputTensors[0].dims);
      const biasLength = ShapeUtil.size(inputTensors[1].dims);
      const useVec4 = biasLength % 4 === 0;
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", dataType, [1], 4);
        const bias = inputVariable("bias", dataType, [1], 4);
        const y = outputVariable("y", dataType, [1], 4);
        const uniforms = [
          { name: "output_vec_size", type: "u32" },
          { name: "bias_size", type: "u32" }
        ];
        const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
        const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
        return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
      };
      return {
        name: "FastGeluWithBias",
        shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
        getShaderSource,
        getRunData: (inputs) => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
            { type: 12 /* uint32 */, data: biasLength }
          ],
          dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
        })
      };
    };
    fastGelu2 = (context) => {
      if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
        fastGelu(context);
      } else {
        context.compute(createFastGeluProgramInfo(context.inputs));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather.ts
var validateInputs13, createGatherProgramInfo, parseGatherAttributes, gather;
var init_gather = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs13 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
    };
    createGatherProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(axis, 1, ...indicesShape);
      const axisDimLimit = inputShape[axis];
      const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const calcDataIndices = (x) => {
          const indicesRank = indicesShape.length;
          let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
          for (let i = 0; i < indicesRank; i++) {
            calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
          }
          calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
          for (let i = 0, j = 0; i < inputRank; i++) {
            if (i === axis) {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
              j += indicesRank;
            } else {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
              j++;
            }
          }
          return calcStr;
        };
        let assignment;
        if (inputs[0].dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
        } else {
          assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
        }
        return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
      };
      return {
        name: "Gather",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gather = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs13(inputs);
      context.compute(createGatherProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
var validateInputs14, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
var init_gather_block_quantized = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs14 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
      }
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
      const blockSize = attributes.blockSize;
      const data = inputs[0];
      const scales = inputs[2];
      const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
      if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
        throw new Error(
          "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
        );
      }
      if (zeroPoint) {
        if (zeroPoint.dataType !== data.dataType) {
          throw new Error("Zero point must have the same data type as the input tensor.");
        }
        if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
          );
        }
      }
    };
    createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(gatherAxis, 1, ...indicesShape);
      const outputSize = ShapeUtil.size(outputShape);
      const outputType = inputs[2].dataType;
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 22 /* int4 */;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: quantizeAxis },
        { type: 12 /* uint32 */, data: gatherAxis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
        const output = outputVariable("output", outputType, outputShape.length);
        const inputVariables = [data, indices, scales];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "quantize_axis", type: "u32" },
          { name: "gather_axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
          if (indicesShape.length > 1) {
            return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
          } else {
            return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
          }
        })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
          if (!zeroPoint) {
            return "var zero_point = 0";
          } else {
            return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
          }
        })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
      };
      return {
        name: "GatherBlockQuantized",
        shaderCache: {
          hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
          inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    gatherBlockQuantized = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs14(inputs, attributes);
      context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
    };
    parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
      blockSize: attributes.blockSize,
      gatherAxis: attributes.gatherAxis,
      quantizeAxis: attributes.quantizeAxis
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
var validateInputs15, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
var init_gather_elements = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs15 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("GatherElements requires 2 inputs.");
      }
      if (inputs[0].dims.length < 1) {
        throw new Error("GatherElements requires that the data input be rank >= 1.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
      }
    };
    createGatherElementsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputOutputDataType = inputs[0].dataType;
      const inputRank = inputShape.length;
      const indicesShape = inputs[1].dims;
      const indicesDataType = inputs[1].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const axisDimLimit = inputShape[axis];
      const outputShape = indicesShape.slice(0);
      const outputSize = ShapeUtil.size(outputShape);
      const input = inputVariable("input", inputOutputDataType, inputRank);
      const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
      const output = outputVariable("output", inputOutputDataType, outputShape.length);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis }
      ];
      programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
      const inputDependencies = ["rank", "rank"];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
      return {
        name: "GatherElements",
        shaderCache: { inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gatherElements = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs15(inputs);
      context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gemm.ts
var validateInputs16, createGemmProgramInfo, parseGemmAttributes, gemm;
var init_gemm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs16 = (inputs) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("Invaid input number.");
      }
      if (inputs.length === 3 && inputs[2].dims.length > 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("Input types are mismatched");
      }
    };
    createGemmProgramInfo = (inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N, K] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K },
        { type: 1 /* float */, data: attributes.alpha },
        { type: 1 /* float */, data: attributes.beta }
      ];
      const inputDependencies = ["type", "type"];
      if (inputs.length === 3) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        let line = "";
        if (attributes.transA && attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        const dataType = a.type.value;
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    output[global_idx] = value;
  }`;
      };
      return {
        name: "Gemm",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGemmAttributes = (attributes) => {
      const transA = attributes.transA;
      const transB = attributes.transB;
      const alpha = attributes.alpha;
      const beta = attributes.beta;
      return {
        transA,
        transB,
        alpha,
        beta,
        cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
      };
    };
    gemm = (context, attributes) => {
      validateInputs16(context.inputs);
      context.compute(createGemmProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
var init_multihead_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_types();
    init_attention();
    init_common();
    init_transpose();
    getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
    validateInputs17 = (inputs, attributes) => {
      const query = inputs[0];
      const key = getInput(inputs, 1);
      const value = getInput(inputs, 2);
      const bias = getInput(inputs, 3);
      const keyPaddingMask = getInput(inputs, 4);
      const attentionBias = getInput(inputs, 5);
      const pastKey = getInput(inputs, 6);
      const pastValue = getInput(inputs, 7);
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      let maxSequenceLength = 0;
      const headSize = Math.floor(hiddenSize / attributes.numHeads);
      if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
          throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
          throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastKey.dims[2] !== pastValue.dims[2]) {
          throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
        maxSequenceLength = pastKey.dims[2];
      } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat;
      if (key && ShapeUtil.size(key.dims) > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (key.dims[2] !== query.dims[2]) {
            throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
          }
          qkvFormat = 2 /* qkvBSNH */;
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          qkvFormat = 5 /* qKvBSNHxBSN2H */;
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          qkvFormat = 0 /* unknown */;
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
        }
        if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      if (bias && ShapeUtil.size(bias.dims) > 0) {
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimension');
        }
        if (key) {
          if (key.dims.length === 5 && key.dims[3] === 2) {
            throw new Error("bias is not allowed for packed kv.");
          }
        }
      }
      const totalSequenceLength = pastSequenceLength + kvSequenceLength;
      let maskType = 0 /* none */;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        maskType = 8 /* maskUnknown */;
        const maskDims = keyPaddingMask.dims;
        if (maskDims.length === 1) {
          if (maskDims[0] === batchSize) {
            maskType = 1 /* mask1dKeySeqLen */;
          } else if (maskDims[0] === 3 * batchSize + 2) {
            maskType = 3 /* mask1DKeySeqLenStart */;
          }
        } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
          maskType = 5 /* mask2dKeyPadding */;
        }
        if (maskType === 8 /* maskUnknown */) {
          throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
        }
        throw new Error("Mask not supported");
      }
      let passPastInKv = false;
      let vHiddenSize = hiddenSize;
      if (value && ShapeUtil.size(value.dims) > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const broadcastResPosBias = false;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        throw new Error("Key padding mask is not supported");
      }
      if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" is expected to have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
    weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
      const outputShape = [batchSize, sequenceLength, hiddenSize];
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: biasOffset },
        { type: 12 /* uint32 */, data: hiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
        const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
        const biasInput = inputVariable("bias", bias.dataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "bias_offset", type: "u32" },
          { name: "hidden_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
      };
      return context.compute(
        {
          name: "MultiHeadAttentionAddBias",
          shaderCache: { inputDependencies: ["type", "type"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [qkv, bias], outputs: [-1] }
      )[0];
    };
    maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
      let reshapedInput = input;
      if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
        if (input.dims.length === 3) {
          reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
        }
        if (numHeads === 1 || sequenceLength === 1) {
          return reshapedInput;
        }
        return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      } else {
        if (sequenceLength === 1) {
          throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
        } else {
          reshapedInput = addBiasTranspose(
            context,
            input,
            bias,
            batchSize,
            sequenceLength,
            numHeads * headSize,
            biasOffset
          );
          reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
          if (numHeads === 1 || sequenceLength === 1) {
            return reshapedInput;
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        }
      }
    };
    multiHeadAttention = (context, attributes) => {
      const params = validateInputs17(context.inputs, attributes);
      const query = context.inputs[0];
      const key = getInput(context.inputs, 1);
      const value = getInput(context.inputs, 2);
      const bias = getInput(context.inputs, 3);
      const keyPaddingMask = getInput(context.inputs, 4);
      const attentionBias = getInput(context.inputs, 5);
      const pastKey = getInput(context.inputs, 6);
      const pastValue = getInput(context.inputs, 7);
      if (query.dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (key?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        query,
        bias,
        0
      );
      if (kvBNSH) {
        return applyAttention(context, Q, key, value, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
      }
      if (!key || !value) {
        throw new Error("key and value must be provided");
      }
      const K = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.headSize,
        key,
        bias,
        params.hiddenSize
      );
      const V = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.vHeadSize,
        value,
        bias,
        2 * params.hiddenSize
      );
      applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/split.ts
var validateInputs18, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
var init_split = __esm({
  "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs18 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
    };
    createSplitAttributesFromInputs = (inputs, attributes) => {
      const splitSizes = [];
      let numOutputs = attributes.numOutputs;
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
        numOutputs = splitSizes.length;
      }
      return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
    };
    calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
    writeBufferDataImpl = (outputs) => {
      const numberOfTensors = outputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
        }
      }
      return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
    };
    createSplitProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const dataType = inputs[0].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const outputs = new Array(attributes.numOutputs);
      const input = inputVariable("input", dataType, inputShape.length);
      const sizeInSplitAxis = new Array(attributes.numOutputs);
      const outputsTensorInfo = [];
      const outputShapes = [];
      let previousSum = 0;
      const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
      for (let i = 0; i < attributes.numOutputs; i++) {
        previousSum += attributes.splitSizes[i];
        sizeInSplitAxis[i] = previousSum;
        const outputShape = inputShape.slice();
        outputShape[axis] = attributes.splitSizes[i];
        outputShapes.push(outputShape);
        outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
        outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
      }
      programUniforms.push(
        { type: 12 /* uint32 */, data: sizeInSplitAxis },
        ...createTensorShapeVariables(inputShape, ...outputShapes)
      );
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
      return {
        name: "Split",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: outputsTensorInfo,
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    split = (context, attributes) => {
      validateInputs18(context.inputs);
      const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
      context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSplitAttributes = (attributes) => {
      const axis = attributes.axis;
      const splitSizes = attributes.splitSizes;
      const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
      if (numOutputs !== splitSizes.length) {
        throw new Error("numOutputs and splitSizes lengh must be equal");
      }
      return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
var validateInputs19, weightTransposeAttribute3, maybeTransposeToBNSH, groupQueryAttention;
var init_group_query_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_attention();
    init_multihead_attention();
    init_split();
    init_transpose();
    validateInputs19 = (inputs, attributes) => {
      if (attributes.doRotary && inputs.length <= 7) {
        throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
      }
      const query = inputs[0];
      const key = inputs[1];
      const value = inputs[2];
      const pastKey = inputs[3];
      const pastValue = inputs[4];
      if (attributes.localWindowSize !== -1) {
        throw new Error("Local attention is not supported");
      }
      if (attributes.softcap !== 0) {
        throw new Error("Softcap is not supported");
      }
      if (attributes.rotaryInterleaved !== 0) {
        throw new Error("Rotary interleaved is not supported");
      }
      if (attributes.smoothSoftmax) {
        throw new Error("Smooth softmax is not supported");
      }
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const dmmhaPacking = false;
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      let hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      const packedQKV = !key || key.dims.length === 0;
      const headSize = !packedQKV ? Math.floor(hiddenSize / attributes.numHeads) : Math.floor(hiddenSize / (attributes.numHeads + 2 * attributes.kvNumHeads));
      if (packedQKV) {
        hiddenSize = headSize * attributes.numHeads;
      }
      const hasPastKey = pastKey && pastKey.dims.length !== 0;
      const hasPastValue = pastValue && pastValue.dims.length !== 0;
      const isPastkvBSNH = hasPastKey && pastKey.dims.length === 4 && pastKey.dims[0] === batchSize && pastKey.dims[1] !== attributes.kvNumHeads && pastKey.dims[2] === attributes.kvNumHeads && pastKey.dims[3] === headSize;
      if (isPastkvBSNH) {
        throw new Error("BSNH pastKey/pastValue is not supported");
      }
      if (hasPastKey && hasPastValue) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
      } else if (hasPastKey || hasPastValue) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat = 1 /* qkvBNSH */;
      if (key && key.dims.length > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (query.dims[2] % key.dims[2] !== 0) {
            throw new Error('Dimension 2 of "query" should be a multiple of "key"');
          }
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        }
        if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      const maskType = 0 /* none */;
      let passPastInKv = false;
      let vHiddenSize = attributes.kvNumHeads ? headSize * attributes.kvNumHeads : hiddenSize;
      if (value && value.dims.length > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const seqlLens = inputs.length > 4 ? inputs[5] : void 0;
      if (seqlLens && seqlLens.dims.length !== 1 && seqlLens.dims[0] !== batchSize) {
        throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
      }
      const totalSequenceLength = -1;
      const maxSequenceLength = -1;
      const broadcastResPosBias = false;
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
        numHeads: attributes.numHeads,
        kvNumHeads: attributes.kvNumHeads,
        nReps: attributes.numHeads / attributes.kvNumHeads,
        pastPresentShareBuffer: false,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    maybeTransposeToBNSH = (context, input, params) => {
      let reshapedInput = input;
      const numHeads = params.kvNumHeads;
      if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
        reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
        reshapedInput = context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      }
      return reshapedInput;
    };
    groupQueryAttention = (context, attributes) => {
      const params = validateInputs19(context.inputs, attributes);
      if (context.inputs[0].dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (context.inputs[1]?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const q = context.inputs[0];
      const k = context.inputs[1] && context.inputs[1].dims.length > 0 ? context.inputs[1] : void 0;
      const v = context.inputs[2] && context.inputs[2].dims.length > 0 ? context.inputs[2] : void 0;
      const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
      const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
      const seqLens = context.inputs.length > 4 ? context.inputs[5] : void 0;
      const totalSequenceLengthInput = context.inputs.length > 5 ? context.inputs[6] : void 0;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const splitAttributes = createAttributeWithCacheKey({
        axis: 2,
        numOutputs: 3,
        splitSizes: [params.numHeads * params.headSize, kvNumHeads * params.headSize, kvNumHeads * params.headSize]
      });
      const [query, key, value] = !k && !v ? context.compute(createSplitProgramInfo([q], splitAttributes), { inputs: [q], outputs: [-1, -1, -1] }) : [q, k, v];
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        query,
        void 0,
        0
      );
      applyAttention(
        context,
        Q,
        maybeTransposeToBNSH(context, key, params),
        maybeTransposeToBNSH(context, value, params),
        void 0,
        void 0,
        pastKey,
        pastValue,
        void 0,
        params,
        seqLens,
        totalSequenceLengthInput
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
var init_instance_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_transpose();
    init_common();
    computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
      const components = getMaxComponents(h);
      const f32Type = components === 1 ? "f32" : `vec${components}f`;
      const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
      const unitsOfWork = n * c;
      const inputShape = [n, c, h / components];
      const outputShape = [n, c, 2];
      const inputDependencies = ["rank", "type", "type"];
      const programUniforms = [];
      programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", input.dataType, 3, components);
        const s = inputVariable("scale", scale.dataType, scale.dims);
        const b = inputVariable("bias", bias.dataType, bias.dims);
        const output = outputVariable("output", 1 /* float */, 3, 2);
        const variables = [x, s, b, output];
        const workgroupSize = 64;
        return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
      };
      return context.compute(
        {
          name: "InstanceNormComputeChannelScaleShift",
          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
          shaderCache: { hint: `${components};${epsilon}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
            dispatchGroup: { x: unitsOfWork },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [input, scale, bias], outputs: [-1] }
      )[0];
    };
    createInstanceNormProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const axis = 2;
      const N = xShape[0];
      const C = xShape[1];
      const H = ShapeUtil.sizeFromDimension(xShape, axis);
      const components = getMaxComponents(H);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const channelScaleShift = computeChannelScaleShift(
        context,
        inputs[0],
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const inputShape = [N, C, H / components];
      const scaleShape = [N, C];
      const inputDependencies = ["type", "none"];
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
        const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
        const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
        const variables = [x, scale, output];
        return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalization",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
            ]
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const N = xShape[0];
      const C = xShape[xShape.length - 1];
      const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
      const components = getMaxComponents(C);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: H },
        { type: 12 /* uint32 */, data: Math.floor(C / components) }
      ];
      const inputDependencies = ["type", "type"];
      const transposedXPerm = [0, xShape.length - 1];
      for (let i = 0; i < xShape.length - 2; i++) {
        transposedXPerm.push(i + 1);
      }
      const transposedX = context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
        inputs: [context.inputs[0]],
        outputs: [-1]
      })[0];
      const channelScaleShift = computeChannelScaleShift(
        context,
        transposedX,
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
        const scaleData = (num) => {
          const index = num === 0 ? "x" : "y";
          const f32Type = components === 1 ? "f32" : `vec${components}f`;
          switch (components) {
            case 1:
              return `${dataType}(${f32Type}(scale.${index}))`;
            case 2:
              return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
            case 4:
              return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
            default:
              throw new Error(`Not supported compoents ${components}`);
          }
        };
        const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
        const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalizationNHWC",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    instanceNorm = (context, attributes) => {
      if (attributes.format === "NHWC") {
        createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
      } else {
        createInstanceNormProgramInfo(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
var validateInputs20, createLayerNormProgramInfo, layerNorm;
var init_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs20 = (inputs) => {
      if (!inputs || inputs.length < 2) {
        throw new Error("layerNorm requires at least 2 inputs.");
      }
    };
    createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
      const simplified = attributes.simplified;
      const xShape = inputs[0].dims;
      const scale = inputs[1];
      const bias = !simplified && inputs[2];
      const outputShape = xShape;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
      const normCount = ShapeUtil.sizeToDimension(xShape, axis);
      const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
      const scaleSize = ShapeUtil.size(scale.dims);
      const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
      if (scaleSize !== normSize || bias && biasSize !== normSize) {
        throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
      }
      const meanInvStdDevDim = [];
      for (let i = 0; i < xShape.length; ++i) {
        if (i < axis) {
          meanInvStdDevDim.push(xShape[i]);
        } else {
          meanInvStdDevDim.push(1);
        }
      }
      const components = getMaxComponents(normSize);
      const inputDependencies = ["type", "type"];
      const programUniforms = [
        { type: 12 /* uint32 */, data: normCount },
        { type: 1 /* float */, data: normSize },
        { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      if (bias) {
        inputDependencies.push("type");
      }
      const hasMeanDataOutput = outputCount > 1;
      const hasInvStdOutput = outputCount > 2;
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("scale", scale.dataType, scale.dims, components)
        ];
        if (bias) {
          variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanDataOutput) {
          variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        const uniforms = [
          { name: "norm_count", type: "u32" },
          { name: "norm_size", type: "f32" },
          { name: "norm_size_vectorized", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (hasMeanDataOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (hasInvStdOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      return {
        name: "LayerNormalization",
        shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
        getRunData: () => ({
          outputs,
          dispatchGroup: { x: Math.ceil(
            normCount / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    layerNorm = (context, attributes) => {
      validateInputs20(context.inputs);
      context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
var validateInputs21, createMatMulNBitsProgramInfo, createMatMulNBitsBlockSize32ProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
var init_matmulnbits = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs21 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("MatMulNBits requires 3 or 4 inputs");
      }
      const a = inputs[0];
      const aRank = a.dims.length;
      if (a.dims[aRank - 1] !== attributes.k) {
        throw new Error("The last dim of input shape does not match the k value");
      }
      const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
      const blobSize = attributes.blockSize / 8 * attributes.bits;
      const b = inputs[1];
      if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
        throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
      }
      const scales = inputs[2];
      const scalesShape = scales.dims;
      if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
        throw new Error("scales input size error.");
      }
      if (inputs.length === 4) {
        const zeroPoints = inputs[3];
        const zeroPointsShape = zeroPoints.dims;
        const expectedZeroPointsSize = attributes.bits > 4 ? attributes.n * nBlocksPerCol : attributes.n * Math.floor((nBlocksPerCol + 1) / 2);
        if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
          throw new Error("zeroPoints input size error.");
        }
      }
    };
    createMatMulNBitsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const components = getMaxComponents(dimBOuter);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
      const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const workgroupSize = 64;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank, components);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const qDqDataType = (() => {
          switch (aComponents) {
            case 1:
              return `array<${dataType2}, 8>`;
            case 2:
              return `mat4x2<${dataType2}>`;
            case 4:
              return `mat2x4<${dataType2}>`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        })();
        const processOneWord = () => {
          let calcStr = `
          // reuse a data
            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};
            var a_data: ${qDqDataType};
            for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
              a_data[j] = ${a.getByOffset("input_offset")};
              input_offset++;
            }
          `;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${qDqDataType}(${Array.from(
              { length: 4 },
              (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
            ).join(", ")});
            b_dequantized_values = ${(() => {
              if (aComponents === 1) {
                return `${qDqDataType}(${Array.from(
                  { length: 8 },
                  (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                ).join(", ")});`;
              } else {
                return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
              }
            })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
              { length: 8 / aComponents },
              (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
            ).join(" + ")};
          `;
          }
          return calcStr;
        };
        const prepareScaleAndZeroPoint = () => {
          let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            `;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
          }
          return calcStr;
        };
        const prepareBData = () => {
          let calcStr = `col_index = col * ${components};`;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
          }
          calcStr += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
          return calcStr;
        };
        return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${8 / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
      };
      return {
        name: "MatMulNBits",
        shaderCache: {
          hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    createMatMulNBitsBlockSize32ProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const workgroupSize = 128;
      const workgroupY = dimBOuter % 8 === 0 ? 8 : dimBOuter % 4 === 0 ? 4 : 1;
      const workgroupX = workgroupSize / workgroupY;
      const tileSize = workgroupX * bComponents * 8;
      const aLengthPerTile = tileSize / aComponents;
      const blocksPerTile = tileSize / attributes.blockSize;
      const dispatchSize = ShapeUtil.size(outputShape) / workgroupY;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const readA = () => {
          switch (aComponents) {
            case 1:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
            case 2:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
            case 4:
              return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        };
        return `
        var<workgroup> sub_a: array<${a.type.value}, ${aLengthPerTile}>;
        var<workgroup> inter_results: array<array<${output.type.value}, ${workgroupX}>, ${workgroupY}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupX, workgroupY, 1])}
          let output_indices = ${output.offsetToIndices(`workgroup_index * ${workgroupY}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${blocksPerTile} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${aLengthPerTile};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${aLengthPerTile}; a_offset += ${workgroupSize})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${a.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${blocksPerTile} + local_id.x;
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${dataType2}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            let scale = ${scales.getByOffset(`b_row * n_blocks_per_col + block`)};
            let b_data = ${b.getByIndices(`${b.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${attributes.blockSize / aComponents};
            for (var i: u32 = 0; i < ${bComponents}; i++) {
              ${readA()}
              let b_value = ${bComponents === 1 ? `b_data` : `b_data[i]`};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${dataType2}>(${Array.from(
          { length: 4 },
          (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
        ).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${dataType2}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from(
          { length: 2 },
          (_, i) => `${`dot(a_data${i}, b_dequantized_values[${i}])`}`
        ).join(" + ")};
              word_offset += ${8 / aComponents};
            }
            workgroupBarrier();
          }

          if (local_idx < ${workgroupY}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            for (var b = 0u; b < ${workgroupX}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${output.setByIndices(`${output.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
      };
      return {
        name: "BlockwiseMatMulNBits32",
        shaderCache: {
          hint: `${attributes.blockSize};${aComponents};${bComponents};${workgroupX};${workgroupY}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    matMulNBits = (context, attributes) => {
      validateInputs21(context.inputs, attributes);
      if (attributes.blockSize === 32 && context.adapterInfo.isVendor("intel") && context.adapterInfo.isArchitecture("gen-12lp")) {
        context.compute(createMatMulNBitsBlockSize32ProgramInfo(context.inputs, attributes));
      } else {
        context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
      }
    };
    parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/pad.ts
var validateInputs22, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
var init_pad = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs22 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("Too few inputs");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
        throw new Error("Input type must be float or float16.");
      }
      if (inputs.length >= 2) {
        let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
        if (inputs.length === 4) {
          validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
        }
        if (!validPads) {
          throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
        }
      }
    };
    getPadConstant = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
      }
      return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
    };
    getPadReflect = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadEdge = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadWrap = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadSnippet = (output, inputRank, attributes) => {
      switch (attributes.mode) {
        case 0:
          return getPadConstant(output, inputRank, attributes.pads.length);
        case 1:
          return getPadReflect(output, inputRank, attributes.pads.length);
        case 2:
          return getPadEdge(output, inputRank, attributes.pads.length);
        case 3:
          return getPadWrap(output, inputRank, attributes.pads.length);
        default:
          throw new Error("Invalid mode");
      }
    };
    createPadProgramInfo = (inputs, attributes) => {
      const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
      const inputDims = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: attributes.pads }
      ];
      const isValueFromInput = inputs.length >= 3 && inputs[2].data;
      if (attributes.mode === 0) {
        programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
      }
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
      const inputDependencies = ["rank"];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("x", inputs[0].dataType, inputDims.length);
        const dataType = input.type.value;
        const padSnippet = getPadSnippet(output, inputDims.length, attributes);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "pads", type: "i32", length: attributes.pads.length }
        ];
        if (attributes.mode === 0) {
          uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
        }
        return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
      };
      return {
        name: "Pad",
        shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createPadAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const bigInt64Pads = inputs[1].getBigInt64Array();
        const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
        const inputRank = inputs[0].dims.length;
        const updatePads = new Int32Array(2 * inputRank).fill(0);
        if (inputs.length >= 4) {
          const axes = inputs[3].getBigInt64Array();
          for (let i = 0; i < axes.length; i++) {
            updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
            updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
          }
        } else {
          bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
        }
        const pads = [];
        updatePads.forEach((v) => pads.push(v));
        return { mode: attributes.mode, value, pads };
      } else {
        return attributes;
      }
    };
    pad = (context, attributes) => {
      validateInputs22(context.inputs);
      const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
      context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/pool.ts
var validateInputs23, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
var init_pool = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_common();
    validateInputs23 = (inputs) => {
      if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
        throw new Error("Pool ops requires 1 input.");
      }
    };
    getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inputShapeAsChannelFirst = input.dims.slice();
      if (isChannelsLast) {
        inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
      }
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
      const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShapeAsChannelFirst,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
      outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
      return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
    };
    getUniformAndPadInfo = (outputShape, attributes) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputSize = ShapeUtil.size(outputShape);
      const kernelSize = ShapeUtil.size(attributes.kernelShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: kernelSize }
      ];
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "kernelSize", type: "u32" }
      ];
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const pwStartEndNotZero = !!(pwStart + pwEnd);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kw },
          { type: 12 /* uint32 */, data: sw },
          { type: 12 /* uint32 */, data: pwStart },
          { type: 12 /* uint32 */, data: pwEnd }
        );
        uniforms.push(
          { name: "kw", type: "u32" },
          { name: "sw", type: "u32" },
          { name: "pwStart", type: "u32" },
          { name: "pwEnd", type: "u32" }
        );
        let phStartEndNotZero = false;
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          phStartEndNotZero = !!(phStart + phEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kh },
            { type: 12 /* uint32 */, data: sh },
            { type: 12 /* uint32 */, data: phStart },
            { type: 12 /* uint32 */, data: phEnd }
          );
          uniforms.push(
            { name: "kh", type: "u32" },
            { name: "sh", type: "u32" },
            { name: "phStart", type: "u32" },
            { name: "phEnd", type: "u32" }
          );
        }
        return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kernelStrides },
          { type: 12 /* uint32 */, data: attributes.pads },
          { type: 12 /* uint32 */, data: attributes.strides }
        );
        uniforms.push(
          { name: "kernelStrides", type: "u32", length: kernelStrides.length },
          { name: "pads", type: "u32", length: attributes.pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length }
        );
        const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
        return [programUniforms, uniforms, !!hasPads, false, false];
      }
    };
    generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
      const isChannelsLast = attributes.format === "NHWC";
      const dataType = x.type.value;
      const output = outputVariable("output", x.type.tensor, outputShapeRank);
      if (attributes.kernelShape.length <= 2) {
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        const dimIdxW = rank - (isChannelsLast ? 2 : 1);
        if (pwStartEndNotZero) {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        } else {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        }
        if (attributes.kernelShape.length === 2) {
          const dimIdxH = rank - (isChannelsLast ? 3 : 2);
          if (phStartEndNotZero) {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
          } else {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
          }
          codeHEnd = `
              }
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const stridesRank = attributes.kernelShape.length;
        const padsRank = attributes.pads.length;
        let padCode = "";
        if (hasPads) {
          padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
        } else {
          padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
          "uniforms.strides",
          `j - ${rank - stridesRank}u`,
          stridesRank
        )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      }
    };
    createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
    createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
    createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
    parsePoolCommonAttributes = (attributes) => ({
      format: attributes.format,
      autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
      ceilMode: attributes.ceil_mode,
      kernelShape: attributes.kernel_shape,
      strides: attributes.strides,
      pads: attributes.pads
    });
    createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const x = inputVariable("x", input.dataType, input.dims.length);
      const dataType = x.type.value;
      const op1 = "value += x_val;";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= ${dataType}(uniforms.kernelSize);`;
      } else {
        op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
      }
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      const inputDependencies = ["rank"];
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          0,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    parseAveragePoolAttributes = (attributes) => {
      const countIncludePad = attributes.count_include_pad === 0 ? false : true;
      const attr = parsePoolCommonAttributes(attributes);
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
      return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
    };
    averagePool = (context, attributes) => {
      validateInputs23(context.inputs);
      context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
    };
    globalPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: []
    };
    parseGlobalAveragePoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalAveragePool = (context, attributes) => {
      validateInputs23(context.inputs);
      context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
    };
    createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const op1 = `
      value = max(x_val, value);
    `;
      const op2 = "";
      const x = inputVariable("x", input.dataType, input.dims.length);
      const inputDependencies = ["rank"];
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          input.dataType === 10 /* float16 */ ? -65504 : -1e5,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    maxPool = (context, attributes) => {
      validateInputs23(context.inputs);
      context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
    };
    parseMaxPoolAttributes = (attributes) => {
      const storageOrder = attributes.storage_order;
      const dilations = attributes.dilations;
      const attr = parsePoolCommonAttributes(attributes);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
      return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
    };
    parseGlobalMaxPoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalMaxPool = (context, attributes) => {
      validateInputs23(context.inputs);
      context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
var validateInputs24, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
var init_quantize_linear = __esm({
  "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs24 = (inputs, attributes) => {
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("DequantizeLinear requires 2 or 3 inputs.");
      }
      if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
        throw new Error("x-scale and x-zero-point must have the same shape.");
      }
      if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("x and x-zero-point must have the same data type.");
      }
      if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
        throw new Error("In the case of dequantizing int32 there is no zero point.");
      }
      if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
        throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
      }
      if (inputs.length > 2) {
        if (inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[1].dims.length !== inputs[2].dims.length) {
          throw new Error("scale and zero-point inputs must have the same rank.");
        }
        if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("scale and zero-point inputs must have the same shape.");
        }
      }
      if (attributes.blockSize > 0) {
        if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
          throw new Error("blockSize must be set only for block quantization.");
        }
        if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
        }
        if (inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
        }
        const dI = inputs[0].dims[attributes.axis];
        const si = inputs[1].dims[attributes.axis];
        if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
          throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
        }
      }
    };
    createDequantizeLinearProgramInfo = (inputs, attributes) => {
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 3 /* int8 */;
      const outputShape = inputs[0].dims;
      const dataType = inputs[1].dataType;
      const outputSize = ShapeUtil.size(outputShape);
      const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
      const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
      const scaleShape = inputs[1].dims;
      const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
      const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
      const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
      const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
      const maxComponents = getMaxComponents(outputSize);
      const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
      const components = useComponents ? maxComponents : 1;
      const inputComponent = useComponents && !isPacked ? maxComponents : 1;
      const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
      const scale = inputVariable("scale", dataType, scaleShape.length);
      const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
      const output = outputVariable("output", dataType, outputShape.length, components);
      const inputVariables = [input, scale];
      if (zeroPoint) {
        inputVariables.push(zeroPoint);
      }
      const inputShapes = [inputShape, scaleShape];
      if (zeroPointInput) {
        inputShapes.push(zeroPointShape);
      }
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize / components },
        { type: 12 /* uint32 */, data: axis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputShapes, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
          if (isPacked) {
            return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
          } else {
            return `let x_value = ${input.getByOffset("global_idx")};`;
          }
        })()};

          // Set scale input
          ${(() => {
          if (perLayerQuantization) {
            return `let scale_value= ${scale.getByOffset("0")}`;
          } else if (perAxisQuantization) {
            return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
          } else {
            return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
          }
        })()};

          // Set zero-point input
          ${(() => {
          if (zeroPoint) {
            if (perLayerQuantization) {
              if (isPacked) {
                return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
              }
            } else if (perAxisQuantization) {
              if (isPacked) {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
              } else {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
              }
            } else {
              if (isPacked) {
                return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
              }
            }
          } else {
            return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
          }
        })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
      };
      return {
        name: "DequantizeLinear",
        shaderCache: {
          hint: attributes.cacheKey,
          inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
          programUniforms
        })
      };
    };
    dequantizeLinear = (context, attributes) => {
      validateInputs24(context.inputs, attributes);
      context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
    };
    parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
  }
});

// web/lib/wasm/jsep/webgpu/ops/range.ts
var validateInputsContent, createRangeProgramInfo, range;
var init_range = __esm({
  "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_common();
    validateInputsContent = (start, limit, delta) => {
      const sameStartLimit = start === limit;
      const increasingRangeNegativeStep = start < limit && delta < 0;
      const decreasingRangePositiveStep = start > limit && delta > 0;
      if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
        throw new Error("Range these inputs' contents are invalid.");
      }
    };
    createRangeProgramInfo = (start, limit, delta, dataType) => {
      const numElements = Math.abs(Math.ceil((limit - start) / delta));
      const outputShape = [numElements];
      const outputSize = numElements;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: dataType, data: start },
        { type: dataType, data: delta },
        ...createTensorShapeVariables(outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", dataType, outputShape.length);
        const wgslType = output.type.value;
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "start", type: wgslType },
          { name: "delta", type: wgslType }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
      };
      return {
        name: "Range",
        shaderCache: { hint: `${dataType}` },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    range = (context) => {
      let start = 0;
      let limit = 0;
      let delta = 0;
      if (context.inputs[0].dataType === 6 /* int32 */) {
        start = context.inputs[0].getInt32Array()[0];
        limit = context.inputs[1].getInt32Array()[0];
        delta = context.inputs[2].getInt32Array()[0];
      } else if (context.inputs[0].dataType === 1 /* float */) {
        start = context.inputs[0].getFloat32Array()[0];
        limit = context.inputs[1].getFloat32Array()[0];
        delta = context.inputs[2].getFloat32Array()[0];
      }
      if (env2.webgpu.validateInputContent) {
        validateInputsContent(start, limit, delta);
      }
      context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/resize.ts
var validateScales, updateScales, validateInputs25, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
var init_resize = __esm({
  "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateScales = (scales, attributes) => {
      scales.every(
        (value) => value > 0 || (() => {
          throw new Error("Resize requires scales input values to be positive");
        })
      );
      if (scales.length > 0) {
        if (attributes.mode === "linear") {
          if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
            throw new Error(
              `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
            );
          }
        } else if (attributes.mode === "cubic") {
          if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
            throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
          }
        }
      }
    };
    updateScales = (scales, axes, rank) => {
      axes.every(
        (value) => value >= 0 && value < rank || (() => {
          throw new Error("Resize requires axes input values to be positive and less than rank");
        })
      );
      const newScales = new Array(rank).fill(1);
      axes.forEach((value, index) => newScales[value] = scales[index]);
      return newScales;
    };
    validateInputs25 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
      const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
      const rank = inputs[0].dims.length;
      if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
        inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
      } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
        throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
      }
      if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length === 1 && inputs[scalesInputIndex].dims[0] > 0) {
        inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
        if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
          throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
        }
        validateScales(scales, attributes);
        if (attributes.axes.length > 0) {
          updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
        }
      }
      if (sizesInputIndex > 0 && inputs.length > sizesInputIndex && inputs[sizesInputIndex].dims.length === 1 && inputs[sizesInputIndex].dims[0] > 0) {
        inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
        if (sizes.length !== 0 && sizes.length !== rank && opsetVersion >= 18 && sizes.length !== attributes.axes.length) {
          throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
        }
      }
      if (attributes.axes.length > 0) {
        if (scales.length !== 0 && scales.length !== attributes.axes.length) {
          throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
        }
        if (sizes.length !== 0 && sizes.length !== attributes.axes.length) {
          throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
        }
      }
      if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
        throw new Error("Resize requires only of scales or sizes to be specified");
      }
    };
    getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
      switch (coordinateTransferMode) {
        case "asymmetric":
          return `return ${dType}(xResized) / ${dType}(xScale);`;
        case "pytorch_half_pixel":
          return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
        case "tf_half_pixel_for_nn":
          return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
        case "align_corners":
          return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${dType}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${dType}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${dType}(lengthResized - 1);
                    return whole + fract;
                  }`;
        case "tf_crop_and_resize":
          return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
        case "half_pixel_symmetric":
          return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        case "half_pixel":
          return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        default:
          throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
      }
    })() + "}";
    getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
      switch (nearestMode) {
        case "round_prefer_ceil":
          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
        case "floor":
          return "return floor(xOriginal);";
        case "ceil":
          return "return ceil(xOriginal);";
        case "round_prefer_floor":
          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
        case "simple":
        default:
          if (opsetVersion < 11) {
            return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
          }
          throw new Error(`Nearest mode ${nearestMode} is not supported`);
      }
    })() + "}";
    updateRoI = (roi, axes, rank) => {
      const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
      const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
      if (axes.length > 0) {
        axes.forEach((v, i) => {
          roiTmp[v] = roiLocal[i];
          roiTmp[i + rank] = roiLocal[axes.length + i];
        });
        return roiTmp;
      }
      return roiLocal;
    };
    initOutputShape = (inputShape, scales, sizes, axes) => {
      let outputShape = [];
      if (sizes.length > 0) {
        if (axes.length > 0) {
          inputShape.forEach((v) => outputShape.push(v));
          if (Math.max(...axes) > inputShape.length) {
            throw new Error("axes is out of bound");
          }
          axes.forEach((v, i) => outputShape[v] = sizes[i]);
        } else {
          sizes.forEach((v) => outputShape.push(v));
        }
      } else {
        if (scales.length === 0) {
          throw new Error("Resize requires either scales or sizes.");
        } else {
          outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
        }
      }
      return outputShape;
    };
    adjustOutputShape = (inputShape, scales, attributes) => {
      const scaleInPolicy = (() => {
        switch (attributes.keepAspectRatioPolicy) {
          case "not_larger":
            return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
          case "not_smaller":
            return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
          default:
            throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
        }
      })();
      scales.fill(1, 0, scales.length);
      const adjustedOutputShape = inputShape.slice();
      if (attributes.axes.length > 0) {
        attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
        attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
      } else {
        scales.fill(scaleInPolicy, 0, scales.length);
        adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
      }
      return adjustedOutputShape;
    };
    calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
    calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", " input_index")}
      }
      return input_indices;
    }`;
    checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
    setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
    bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
    };
    bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
      const is2D = inputShape.length === 2;
      const isNchw = true;
      const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
      const dType = input.type.value;
      const createCubicInterpolationFunction = (idx) => {
        const direction = idx === heightIdx ? "row" : "col";
        return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
          if (excludeOutside) {
            return `coefs[i + 1] = 0.0;
                        continue;`;
          } else if (useExtrapolation) {
            return `return ${extrapolationValue};`;
          } else {
            return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
          }
        })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
      };
      return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
    };
    trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
    };
    createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
      const inputShape = inputTensor.dims;
      const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
      let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
      let scales = scalesInput.slice();
      if (scalesInput.length === 0) {
        scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
        if (attributes.keepAspectRatioPolicy !== "stretch") {
          outputShape = adjustOutputShape(inputShape, scales, attributes);
        }
      }
      const output = outputVariable("output", inputTensor.dataType, outputShape.length);
      const input = inputVariable("input", inputTensor.dataType, inputShape.length);
      const outputSize = ShapeUtil.size(outputShape);
      const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
      const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
      const extrapolationValue = attributes.extrapolationValue;
      const dataType = input.type.value;
      const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
              input,
              output,
              inputShape,
              outputShape,
              scales.length,
              roi.length,
              useExtrapolation
            )};
              `;
          case "linear":
            return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else if (inputShape.length === 3 || inputShape.length === 5) {
                return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else {
                throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
              }
            })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bicubicInterpolation(
                  input,
                  output,
                  inputShape,
                  outputShape,
                  scales,
                  roi,
                  attributes.cubicCoeffA,
                  useExtrapolation,
                  attributes.extrapolationValue,
                  attributes.excludeOutside
                )}`;
              } else {
                throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
              }
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
          case "linear":
            return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
          case "cubic":
            return "output[global_idx] = bicubicInterpolation(output_indices);";
          default:
            throw Error(`Unsupported resize mode: ${attributes.mode}`);
        }
      })()};
`}
      }`;
      return {
        name: "Resize",
        shaderCache: {
          hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? scales : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${inputShape}`,
          inputDependencies: ["rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 1 /* float */, data: scales },
            { type: 1 /* float */, data: roi },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    getOpsetVersionFromCustomDataBuffer = (context) => {
      const customDataBuffer = context.customDataBuffer;
      const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
      const opsetVersion = customDataBuffer32[0];
      return opsetVersion;
    };
    resize = (context, attributes) => {
      const scales = [];
      const sizes = [];
      const roi = [];
      const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
      if (attributes.antialias !== 0) {
        throw Error("Only default value (0) for Antialias attribute is supported");
      }
      validateInputs25(context.inputs, attributes, opsetVersion, scales, sizes, roi);
      context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
        inputs: [0]
      });
    };
    parseResizeAttributes = (attributes) => {
      const antialias = attributes.antialias;
      const axes = attributes.axes;
      const coordinateTransformMode = attributes.coordinateTransformMode;
      const cubicCoeffA = attributes.cubicCoeffA;
      const excludeOutside = attributes.excludeOutside !== 0;
      const extrapolationValue = attributes.extrapolationValue;
      const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
      const mode = attributes.mode;
      const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
      return createAttributeWithCacheKey({
        antialias,
        axes,
        coordinateTransformMode,
        cubicCoeffA,
        excludeOutside,
        extrapolationValue,
        keepAspectRatioPolicy,
        mode,
        nearestMode
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
var validateInputs26, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
var init_rotary_embedding = __esm({
  "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs26 = (inputs, attributes) => {
      const [input, positionIds, cosCache, sinCache] = inputs;
      const { numHeads, rotaryEmbeddingDim } = attributes;
      if (input.dims.length !== 3 && input.dims.length !== 4) {
        throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
      }
      if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
        throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
      }
      if (cosCache.dims.length !== 2) {
        throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
      }
      if (sinCache.dims.length !== 2) {
        throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
      }
      if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
        throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
      }
      if (rotaryEmbeddingDim > 0 && numHeads === 0) {
        throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[input.dims.length - 2];
      const maxSequenceLength = cosCache.dims[0];
      const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
      const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
      if (rotaryEmbeddingDim > headSize) {
        throw new Error("rotary_embedding_dim must be less than or equal to head_size");
      }
      if (positionIds.dims.length === 2) {
        if (batchSize !== positionIds.dims[0]) {
          throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
        }
        if (sequenceLength !== positionIds.dims[1]) {
          throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
        }
      }
      if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
        throw new Error(
          `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
        );
      }
      if (sequenceLength > maxSequenceLength) {
        throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
      }
    };
    createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
      const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
      const batchSize = inputs[0].dims[0];
      const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
      const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
      const hiddenSize = batchStride / sequenceLength;
      const halfRotaryEmbeddingDim = inputs[2].dims[1];
      const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
      const globalShape = new Array(
        batchSize,
        sequenceLength,
        hiddenSize / headSize,
        headSize - halfRotaryEmbeddingDim
      );
      const globalStrides = ShapeUtil.computeStrides(globalShape);
      const programUniforms = [
        { type: 1 /* float */, data: scale },
        { type: 12 /* uint32 */, data: globalShape },
        { type: 12 /* uint32 */, data: globalStrides },
        // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
        // i.e. BSNH
        ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
        ...inputs[0].dims.length === 4 ? new Array({
          type: 12 /* uint32 */,
          data: [batchStride, headSize, sequenceLength * headSize, 1]
        }) : [],
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
        const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
        const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
        const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
        shaderHelper.registerUniforms([
          { name: "scale", type: "f32" },
          { name: "global_shape", type: "u32", length: globalShape.length },
          { name: "global_strides", type: "u32", length: globalStrides.length },
          { name: "input_output_strides", type: "u32", length: globalStrides.length }
        ]);
        return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
      };
      return {
        name: "RotaryEmbedding",
        shaderCache: {
          hint: createAttributeWithCacheKey({
            interleaved
          }).cacheKey,
          inputDependencies: ["rank", "rank", "rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
          programUniforms
        })
      };
    };
    rotaryEmbedding = (context, attributes) => {
      validateInputs26(context.inputs, attributes);
      context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
var validateInputs27, createSkipLayerNormProgramInfo, skipLayerNorm;
var init_skip_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs27 = (inputs) => {
      if (!inputs || inputs.length < 3) {
        throw new Error("layerNorm requires at least 3 inputs.");
      }
      const input = inputs[0];
      const skip = inputs[1];
      const gamma = inputs[2];
      if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
        throw new Error("All inputs must have the same data type");
      }
      if (input.dims.length !== 3 && input.dims.length !== 2) {
        throw new Error("Input must be 2D or 3D");
      }
      if (skip.dims.length !== 3 && skip.dims.length !== 2) {
        throw new Error("Skip must be 2D or 3D");
      }
      const hiddenSize = input.dims[input.dims.length - 1];
      const sequenceLength = input.dims[input.dims.length - 2];
      if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
        throw new Error("Skip must have the same hidden size as input");
      }
      if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
        throw new Error("Skip must have the same sequence length as input");
      }
      if (gamma.dims.length !== 1) {
        throw new Error("Gamma must be 1D");
      }
      if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
        throw new Error("Gamma must have the same hidden size as input");
      }
      if (inputs.length > 3) {
        const beta = inputs[3];
        if (beta.dims.length !== 1) {
          throw new Error("Beta must be 1D");
        }
        if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
          throw new Error("Beta must have the same hidden size as input");
        }
      }
      if (inputs.length > 4) {
        const bias = inputs[4];
        if (bias.dims.length !== 1) {
          throw new Error("Bias must be 1D");
        }
        if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
          throw new Error("Bias must have the same hidden size as input");
        }
      }
    };
    createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
      const simplified = attributes.simplified;
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const outputShape = inputShape;
      const outputSize = inputSize;
      const hiddenSize = inputShape.slice(-1)[0];
      const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
      const hasBetaInput = !simplified && inputs.length > 3;
      const hasBiasInput = inputs.length > 4;
      const hasMeanOutput = isTraining && outputCount > 1;
      const hasInvStdDevOutput = isTraining && outputCount > 2;
      const hasInputSkipBiasSumOutput = outputCount > 3;
      const workgroupSize = 64;
      const components = getMaxComponents(hiddenSize);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: components },
        { type: 12 /* uint32 */, data: hiddenSize },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      const getShaderSource = (shaderHelper) => {
        const uniformsArray = [
          { name: "output_size", type: "u32" },
          { name: "components", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
          inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
        ];
        if (hasBetaInput) {
          variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
        }
        if (hasBiasInput) {
          variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanOutput) {
          variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdDevOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInputSkipBiasSumOutput) {
          variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
        }
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
        return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (outputCount > 1) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 2) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 3) {
        outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
      }
      return {
        name: "SkipLayerNormalization",
        shaderCache: {
          hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
          inputDependencies: inputs.map((_input, _index) => "type")
        },
        getShaderSource,
        getRunData: () => ({
          outputs,
          dispatchGroup: {
            x: Math.ceil(outputSize / hiddenSize)
          },
          programUniforms
        })
      };
    };
    skipLayerNorm = (context, attributes) => {
      const isTraining = false;
      validateInputs27(context.inputs);
      const outputs = [0];
      if (context.outputCount > 1) {
        outputs.push(isTraining ? 1 : -3);
      }
      if (context.outputCount > 2) {
        outputs.push(isTraining ? 2 : -3);
      }
      if (context.outputCount > 3) {
        outputs.push(3);
      }
      context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
        outputs
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/slice.ts
var validateInputs28, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
var init_slice = __esm({
  "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs28 = (inputs, attributes) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      if (attributes.axes.length !== 0) {
        if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
          throw new Error("axes, starts and ends must have the same length");
        }
      } else if (attributes.starts.length !== attributes.ends.length) {
        throw new Error("starts and ends must have the same length");
      }
      inputs.slice(1).forEach((_, idx) => {
        if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      });
    };
    readInput = (inputs, idx) => {
      const input = [];
      if (inputs.length > idx) {
        if (inputs[idx].dataType === 7 /* int64 */) {
          inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
        } else if (inputs[idx].dataType === 6 /* int32 */) {
          inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
        } else {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      }
      return input;
    };
    createSliceAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const starts = readInput(inputs, 1);
        const ends = readInput(inputs, 2);
        let axes = readInput(inputs, 3);
        if (axes.length === 0) {
          axes = [...Array(inputs[0].dims.length).keys()];
        }
        return createAttributeWithCacheKey({ starts, ends, axes });
      } else {
        return attributes;
      }
    };
    fixStartEndValues = (value, index, inputShape, axes, steps) => {
      let newValue = value;
      if (value < 0) {
        newValue += inputShape[axes[index]];
      }
      if (steps[index] < 0) {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
      } else {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
      }
    };
    calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
    createSliceProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
      let steps = readInput(inputs, 4);
      steps.forEach(
        (step) => step !== 0 || (() => {
          throw new Error("step cannot be 0");
        })
      );
      if (steps.length === 0) {
        steps = Array(axes.length).fill(1);
      }
      const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
      const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
      if (axes.length !== starts.length || axes.length !== ends.length) {
        throw new Error("start, ends and axes should have the same number of elements");
      }
      if (axes.length !== inputShape.length) {
        for (let i = 0; i < inputShape.length; ++i) {
          if (!axes.includes(i)) {
            starts.splice(i, 0, 0);
            ends.splice(i, 0, inputShape[i]);
            steps.splice(i, 0, 1);
          }
        }
      }
      const signs = steps.map((step) => Math.sign(step));
      steps.forEach((step, i, array) => {
        if (step < 0) {
          const numSteps = (ends[i] - starts[i]) / step;
          const newEnd = starts[i];
          const newStart = newEnd + numSteps * steps[i];
          starts[i] = newStart;
          ends[i] = newEnd;
          array[i] = -step;
        }
      });
      const outputShape = inputShape.slice(0);
      axes.forEach((axis, _) => {
        outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
      });
      const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
      const outputSize = ShapeUtil.size(outputShape);
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "starts", type: "u32", length: starts.length },
        { name: "signs", type: "i32", length: signs.length },
        { name: "steps", type: "u32", length: steps.length }
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: starts },
        { type: 6 /* int32 */, data: signs },
        { type: 12 /* uint32 */, data: steps },
        ...createTensorShapeVariables(inputs[0].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
      return {
        name: "Slice",
        shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [outputTensorInfo],
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    slice = (context, attributes) => {
      validateInputs28(context.inputs, attributes);
      const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
      context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSliceAttributes = (attributes) => {
      const starts = attributes.starts;
      const ends = attributes.ends;
      const axes = attributes.axes;
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/softmax.ts
var validateInputs29, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
var init_softmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_transpose();
    init_common();
    validateInputs29 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax op requires 1 input.");
      }
    };
    createSoftmaxProgramInfo = (context, attributes) => {
      const input = context.inputs[0];
      const inputShape = input.dims;
      const outputSize = ShapeUtil.size(inputShape);
      const WG = 64;
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const isTransposeRequired = axis < inputShape.length - 1;
      let transposedInput;
      let perm = [];
      if (isTransposeRequired) {
        perm = Array.from({ length: inputRank }, (_, i) => i);
        perm[axis] = inputRank - 1;
        perm[inputRank - 1] = axis;
        transposedInput = context.compute(createTransposeProgramInfo(input, perm), {
          inputs: [input],
          outputs: [-1]
        })[0];
      } else {
        transposedInput = input;
      }
      const transposedInputShape = transposedInput.dims;
      const cols = transposedInputShape[inputRank - 1];
      const rows = outputSize / cols;
      const components = getMaxComponents(cols);
      const packedCols = cols / components;
      const maxVector = (name, components2) => {
        if (components2 === 4) {
          return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
        } else if (components2 === 2) {
          return `max(${name}.x, ${name}.y)`;
        } else if (components2 === 3) {
          return `max(max(${name}.x, ${name}.y), ${name}.z)`;
        }
        return name;
      };
      const x = inputVariable("x", transposedInput.dataType, transposedInput.dims, components);
      const output = outputVariable("result", transposedInput.dataType, transposedInput.dims, components);
      const valueType = x.type.value;
      const threadMaxDecl = tensorTypeToWsglStorageType(transposedInput.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
      const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;
      const result = context.compute(
        {
          name: "Softmax",
          shaderCache: { hint: `${components}`, inputDependencies: ["type"] },
          getRunData: () => ({
            outputs: [{ dims: transposedInputShape, dataType: transposedInput.dataType }],
            dispatchGroup: { x: rows },
            programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
          }),
          getShaderSource
        },
        {
          inputs: [transposedInput],
          outputs: [isTransposeRequired ? -1 : 0]
        }
      )[0];
      if (isTransposeRequired) {
        context.compute(createTransposeProgramInfo(result, perm), {
          inputs: [result]
        });
      }
    };
    softmax = (context, attributes) => {
      validateInputs29(context.inputs);
      createSoftmaxProgramInfo(context, attributes);
    };
    parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/tile.ts
var getRepeats, validateInputs30, getOutputShape2, createTileProgramInfo, tile;
var init_tile = __esm({
  "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
    validateInputs30 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
        throw new Error("Tile only support float, float16, int32, and uint32 data types");
      }
      if (inputs[1].dataType !== 7 /* int64 */) {
        throw new Error("Tile `repeats` input should be of int64 data type");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("Tile `repeats` input should be 1-D");
      }
      const repeats = getRepeats(inputs[1]);
      if (repeats.length !== inputs[0].dims.length) {
        throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
      }
    };
    getOutputShape2 = (inputShape, repeats) => {
      const outputShape = [];
      for (let i = 0; i < inputShape.length; ++i) {
        outputShape.push(inputShape[i] * repeats[i]);
      }
      return outputShape;
    };
    createTileProgramInfo = (inputs, shape) => {
      const inputShape = inputs[0].dims;
      const repeats = shape == null ? getRepeats(inputs[1]) : shape;
      const outputShape = getOutputShape2(inputShape, repeats);
      const outputSize = ShapeUtil.size(outputShape);
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, inputShape.length);
      const output = outputVariable("output", dataType, outputShape.length);
      const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
      return {
        name: "Tile",
        shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputs[0].dims, outputShape)
          ]
        }),
        getShaderSource
      };
    };
    tile = (context) => {
      validateInputs30(context.inputs);
      context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/where.ts
var createWhereOpProgramShader, createWhereOpProgramInfo, where;
var init_where = __esm({
  "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
      const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
      const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
      const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
      let assignment;
      const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
      if (!isBroadcast) {
        assignment = output.setByOffset(
          "global_idx",
          expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
        );
      } else {
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `a_data[index_a${x}][component_a${x}]`;
          const expressionB = `b_data[index_b${x}][component_b${x}]`;
          const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
          return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createWhereOpProgramInfo = (inputs) => {
      const dimsA = inputs[1].dims;
      const dimsB = inputs[2].dims;
      const dimsC = inputs[0].dims;
      const outputDataType = inputs[1].dataType;
      const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
      let outputShape = dimsA;
      let outputSize = ShapeUtil.size(dimsA);
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
        if (!calculatedShape) {
          throw new Error("Can't perform where op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
      }
      const vecSize = Math.ceil(outputSize / 4);
      return {
        name: "Where",
        shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
        getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* vec size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: vecSize },
            ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
          ]
        })
      };
    };
    where = (context) => {
      context.compute(createWhereOpProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
var WEBGPU_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
    "use strict";
    init_argminmax();
    init_attention();
    init_batch_norm();
    init_bias_add();
    init_bias_split_gelu();
    init_binary_op();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_cumsum();
    init_depth_to_space();
    init_einsum();
    init_expand();
    init_fast_gelu();
    init_gather();
    init_gather_block_quantized();
    init_gather_elements();
    init_gemm();
    init_group_query_attention();
    init_instance_norm();
    init_layer_norm();
    init_matmul();
    init_matmulnbits();
    init_multihead_attention();
    init_pad();
    init_pool();
    init_quantize_linear();
    init_range();
    init_reduce();
    init_resize();
    init_rotary_embedding();
    init_skip_layer_norm();
    init_slice();
    init_softmax();
    init_split();
    init_tile();
    init_transpose();
    init_unary_op();
    init_where();
    WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
      ["Abs", [abs]],
      ["Acos", [acos]],
      ["Acosh", [acosh]],
      ["Add", [add]],
      ["ArgMax", [argMax, parseArgMinMaxAttributes]],
      ["ArgMin", [argMin, parseArgMinMaxAttributes]],
      ["Asin", [asin]],
      ["Asinh", [asinh]],
      ["Atan", [atan]],
      ["Atanh", [atanh]],
      ["Attention", [attention]],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", [averagePool, parseAveragePoolAttributes]],
      ["BatchNormalization", [batchNorm]],
      ["BiasAdd", [biasAdd]],
      ["BiasSplitGelu", [biasSplitGelu]],
      ["Cast", [cast, parseCastAttributes]],
      ["Ceil", [ceil]],
      ["Clip", [clip]],
      ["Concat", [concat, parseConcatAttributes]],
      ["Conv", [conv, parseConvAttributes]],
      ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
      ["Cos", [cos]],
      ["Cosh", [cosh]],
      ["CumSum", [cumsum, parseCumSumAttributes]],
      ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
      ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
      ["Div", [div]],
      ["Einsum", [einsum, parseEinsumAttributes]],
      ["Elu", [elu, parseAlphaAttributes]],
      ["Equal", [equal]],
      ["Erf", [erf]],
      ["Exp", [exp]],
      ["Expand", [expand]],
      ["FastGelu", [fastGelu2]],
      ["Floor", [floor]],
      ["FusedConv", [conv, parseConvAttributes]],
      ["Gather", [gather, parseGatherAttributes]],
      ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
      ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
      ["Gelu", [gelu]],
      ["Gemm", [gemm, parseGemmAttributes]],
      ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
      ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
      ["Greater", [greater]],
      ["GreaterOrEqual", [greaterOrEqual]],
      ["GroupQueryAttention", [groupQueryAttention]],
      ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
      ["InstanceNormalization", [instanceNorm]],
      ["LayerNormalization", [layerNorm]],
      ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
      ["Less", [less]],
      ["LessOrEqual", [lessOrEqual]],
      ["Log", [log]],
      ["MatMul", [matMul]],
      ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", [maxPool, parseMaxPoolAttributes]],
      ["Mul", [mul]],
      ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
      ["Neg", [neg]],
      ["Not", [not]],
      ["Pad", [pad]],
      ["Pow", [pow]],
      ["QuickGelu", [quickgelu, parseAlphaAttributes]],
      ["Range", [range]],
      ["Reciprocal", [reciprocal]],
      ["ReduceMin", [reduceMin]],
      ["ReduceMean", [reduceMean]],
      ["ReduceMax", [reduceMax]],
      ["ReduceSum", [reduceSum]],
      ["ReduceProd", [reduceProd]],
      ["ReduceL1", [reduceL1]],
      ["ReduceL2", [reduceL2]],
      ["ReduceLogSum", [reduceLogSum]],
      ["ReduceLogSumExp", [reduceLogSumExp]],
      ["ReduceSumSquare", [reduceSumSquare]],
      ["Relu", [relu]],
      ["Resize", [resize, parseResizeAttributes]],
      ["RotaryEmbedding", [rotaryEmbedding]],
      ["Sigmoid", [sigmoid]],
      ["Sin", [sin]],
      ["Sinh", [sinh]],
      ["Slice", [slice, parseSliceAttributes]],
      ["SkipLayerNormalization", [skipLayerNorm]],
      ["Split", [split, parseSplitAttributes]],
      ["Sqrt", [sqrt]],
      ["Softmax", [softmax, parseSoftmaxAttributes]],
      ["Sub", [sub]],
      ["Tan", [tan]],
      ["Tanh", [tanh]],
      ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
      ["Tile", [tile]],
      ["Transpose", [transpose, parseTransposeAttributes]],
      ["Where", [where]]
    ]);
  }
});

// web/lib/wasm/jsep/webgpu/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
    "use strict";
    init_esm();
    init_log();
    init_common();
    ProgramManager = class {
      constructor(backend) {
        this.backend = backend;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
        TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
        const device = this.backend.device;
        const computePassEncoder = this.backend.getComputePassEncoder();
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
        const entries = [];
        for (const input of inputs) {
          entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
        }
        for (const output of outputs) {
          entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
        }
        if (uniformBufferBinding) {
          entries.push({ binding: entries.length, resource: uniformBufferBinding });
        }
        const bindGroup = device.createBindGroup({
          layout: buildArtifact.computePipeline.getBindGroupLayout(0),
          entries,
          label: buildArtifact.programInfo.name
        });
        if (this.backend.sessionStatus === "capturing") {
          const commandInfo = {
            kernelId: this.backend.currentKernelId,
            computePipeline: buildArtifact.computePipeline,
            bindGroup,
            dispatchGroup
          };
          const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
          sessionCommandList.push(commandInfo);
        }
        computePassEncoder.setPipeline(buildArtifact.computePipeline);
        computePassEncoder.setBindGroup(0, bindGroup);
        computePassEncoder.dispatchWorkgroups(...dispatchGroup);
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
        this.backend.pendingDispatchNumber++;
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
          this.backend.endComputePass();
        }
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
          this.backend.flush();
        }
        TRACE_FUNC_END(buildArtifact.programInfo.name);
      }
      dispose() {
      }
      build(programInfo, normalizedDispatchGroupSize) {
        TRACE_FUNC_BEGIN(programInfo.name);
        const device = this.backend.device;
        const extensions = [];
        if (device.features.has("shader-f16")) {
          extensions.push("enable f16;");
        }
        const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
        const userCode = programInfo.getShaderSource(shaderHelper);
        const code = `${extensions.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
        const shaderModule = device.createShaderModule({ code, label: programInfo.name });
        LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
        const computePipeline = device.createComputePipeline({
          compute: { module: shaderModule, entryPoint: "main" },
          layout: "auto",
          label: programInfo.name
        });
        TRACE_FUNC_END(programInfo.name);
        return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
      }
      normalizeDispatchGroupSize(dispatchGroup) {
        const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
        const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
        const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
        const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
        if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
          return [x, y, z];
        }
        const size = x * y * z;
        let dispatchAverage = Math.ceil(Math.sqrt(size));
        if (dispatchAverage > limitPerDimension) {
          dispatchAverage = Math.ceil(Math.cbrt(size));
          if (dispatchAverage > limitPerDimension) {
            throw new Error("Total dispatch size exceeds WebGPU maximum.");
          }
          return [dispatchAverage, dispatchAverage, dispatchAverage];
        } else {
          return [dispatchAverage, dispatchAverage, 1];
        }
      }
    };
  }
});

// web/lib/wasm/jsep/backend-webgpu.ts
var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
var init_backend_webgpu = __esm({
  "web/lib/wasm/jsep/backend-webgpu.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_log();
    init_tensor_view();
    init_gpu_data_manager();
    init_op_resolve_rules();
    init_program_manager();
    getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
      if (inputDependencies.length !== inputTensors.length) {
        throw new Error(
          `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
        );
      }
      const inputInfos = [];
      for (let i = 0; i < inputTensors.length; ++i) {
        const type = inputTensors[i].dataType;
        switch (inputDependencies[i]) {
          case "none": {
            inputInfos.push("");
            break;
          }
          case "type": {
            inputInfos.push(`${type}`);
            break;
          }
          case "rank": {
            const rank = inputTensors[i].dims.length;
            inputInfos.push(`${type};${rank}`);
            break;
          }
          case "dims": {
            const dims = inputTensors[i].dims.join(",");
            inputInfos.push(`${type};${dims}`);
            break;
          }
          default:
            throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
        }
      }
      return inputInfos.join("|");
    };
    getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
      let key = programInfo.name;
      if (programInfo.shaderCache?.hint) {
        key += "[" + programInfo.shaderCache.hint + "]";
      }
      key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
        inputTensors,
        programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
      )}`;
      return key;
    };
    AdapterInfoImpl = class {
      constructor(adapterInfo) {
        if (adapterInfo) {
          this.architecture = adapterInfo.architecture;
          this.vendor = adapterInfo.vendor;
        }
      }
      isArchitecture(architecture) {
        return this.architecture === architecture;
      }
      isVendor(vendor) {
        return this.vendor === vendor;
      }
    };
    WebGpuBackend = class {
      constructor() {
        /**
         * representing the session ID of which is currently being run.
         * `null` means no session is being run.
         * only valid when session.run is executed.
         */
        this.currentSessionId = null;
        /**
         * representing the kernel ID of which is currently being computed (CPU code perspective).
         * `null` means no kernel is being computed.
         * only one kernel can be computed at a moment.
         */
        this.currentKernelId = null;
        this.commandEncoder = null;
        this.computePassEncoder = null;
        this.maxDispatchNumber = 16;
        this.pendingDispatchNumber = 0;
        // info of kernels pending submission for a single batch
        this.pendingKernels = [];
        // queryReadBuffer -> pendingKernels mapping for all the batches
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.sessionStatus = "default";
        /**
         * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
         */
        this.capturedCommandList = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> PendingKernelInfo[] mapping for profiling.
         */
        this.capturedPendingKernels = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
         */
        this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
      }
      /**
       * get the custom data of the current kernel
       */
      get currentKernelCustomData() {
        if (this.currentKernelId === null) {
          throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
        }
        let data = this.kernelCustomData.get(this.currentKernelId);
        if (!data) {
          data = {};
          this.kernelCustomData.set(this.currentKernelId, data);
        }
        return data;
      }
      async initialize(env3, adapter) {
        this.env = env3;
        const requiredFeatures = [];
        const deviceDescriptor = {
          requiredLimits: {
            maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
            maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
            maxBufferSize: adapter.limits.maxBufferSize,
            maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
          },
          requiredFeatures
        };
        if (adapter.features.has("chromium-experimental-timestamp-query-inside-passes")) {
          requiredFeatures.push("chromium-experimental-timestamp-query-inside-passes");
        } else if (adapter.features.has("timestamp-query")) {
          requiredFeatures.push("timestamp-query");
        }
        if (adapter.features.has("shader-f16")) {
          requiredFeatures.push("shader-f16");
        }
        this.device = await adapter.requestDevice(deviceDescriptor);
        this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
        this.gpuDataManager = createGpuDataManager(this);
        this.programManager = new ProgramManager(this);
        this.kernels = /* @__PURE__ */ new Map();
        this.kernelPersistentData = /* @__PURE__ */ new Map();
        this.kernelCustomData = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
        this.device.onuncapturederror = (ev) => {
          if (ev.error instanceof GPUValidationError) {
            console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
          }
        };
        Object.defineProperty(this.env.webgpu, "device", {
          value: this.device,
          writable: false,
          enumerable: true,
          configurable: false
        });
        Object.defineProperty(this.env.webgpu, "adapter", {
          value: adapter,
          writable: false,
          enumerable: true,
          configurable: false
        });
        this.setQueryType();
      }
      dispose() {
        if (typeof this.querySet !== "undefined") {
          this.querySet.destroy();
        }
        this.gpuDataManager.dispose();
      }
      getCommandEncoder() {
        if (!this.commandEncoder) {
          this.commandEncoder = this.device.createCommandEncoder();
        }
        return this.commandEncoder;
      }
      getComputePassEncoder() {
        if (!this.computePassEncoder) {
          const commandEncoder = this.getCommandEncoder();
          const computePassDescriptor = {};
          if (this.queryType === "at-passes") {
            computePassDescriptor.timestampWrites = {
              querySet: this.querySet,
              beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
              endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
            };
          }
          this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
        }
        return this.computePassEncoder;
      }
      endComputePass() {
        if (this.computePassEncoder) {
          this.computePassEncoder.end();
          this.computePassEncoder = null;
        }
      }
      flush() {
        if (!this.commandEncoder) {
          return;
        }
        TRACE_FUNC_BEGIN();
        this.endComputePass();
        let queryReadBuffer;
        if (this.queryType !== "none") {
          this.commandEncoder.resolveQuerySet(
            this.querySet,
            0,
            this.pendingDispatchNumber * 2,
            this.queryResolveBuffer,
            0
          );
          queryReadBuffer = this.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
          );
          this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
          this.pendingKernels = [];
          this.commandEncoder.copyBufferToBuffer(
            this.queryResolveBuffer,
            0,
            queryReadBuffer,
            0,
            this.pendingDispatchNumber * 2 * 8
          );
        }
        this.device.queue.submit([this.commandEncoder.finish()]);
        this.gpuDataManager.refreshPendingBuffers();
        this.commandEncoder = null;
        this.pendingDispatchNumber = 0;
        if (this.queryType !== "none") {
          void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
            const pendingKernels = this.pendingQueries.get(queryReadBuffer);
            for (let i = 0; i < mappedData.length / 2; i++) {
              const pendingKernelInfo = pendingKernels[i];
              const kernelId = pendingKernelInfo.kernelId;
              const kernelInfo = this.kernels.get(kernelId);
              const kernelType = kernelInfo.kernelType;
              const kernelName = kernelInfo.kernelName;
              const programName = pendingKernelInfo.programName;
              const inputTensorViews = pendingKernelInfo.inputTensorViews;
              const outputTensorViews = pendingKernelInfo.outputTensorViews;
              const startTimeU64 = mappedData[i * 2];
              const endTimeU64 = mappedData[i * 2 + 1];
              if (typeof this.queryTimeBase === "undefined") {
                this.queryTimeBase = startTimeU64;
              }
              const startTime = Number(startTimeU64 - this.queryTimeBase);
              const endTime = Number(endTimeU64 - this.queryTimeBase);
              if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                throw new RangeError("incorrect timestamp range");
              }
              if (this.env.webgpu.profiling?.ondata) {
                this.env.webgpu.profiling.ondata({
                  version: 1,
                  inputsMetadata: inputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  outputsMetadata: outputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  kernelId,
                  kernelType,
                  kernelName,
                  programName,
                  startTime,
                  endTime
                });
              } else {
                let inputShapes = "";
                inputTensorViews.forEach((value, i2) => {
                  inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                let outputShapes = "";
                outputTensorViews.forEach((value, i2) => {
                  outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                console.log(
                  `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}execution time: ${endTime - startTime} ns`
                );
              }
              TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
            }
            queryReadBuffer.unmap();
            this.pendingQueries.delete(queryReadBuffer);
          });
        }
        TRACE_FUNC_END();
      }
      /**
       * run a WebGPU program.
       * @param program a ProgramInfo instance
       * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
       * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
       * index to the kernel's output.
       * @param createKernelOutput a callback function that create a value to kernel's output with the given index
       * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
       * or persistent (owned by the current kernel)
       * @returns a TensorView array representing the result.
       */
      run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
        TRACE_FUNC_BEGIN(program.name);
        const inputDatas = [];
        for (let i = 0; i < inputTensorViews.length; ++i) {
          const data = inputTensorViews[i].data;
          if (data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(data);
          if (!gpuData) {
            throw new Error(`no GPU data for input: ${data}`);
          }
          inputDatas.push(gpuData);
        }
        const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
        const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
        if (validatedOutputIndices.length !== outputs.length) {
          throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
        }
        const outputTensorViews = [];
        const outputDatas = [];
        for (let i = 0; i < outputs.length; ++i) {
          if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
            throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
          }
          if (validatedOutputIndices[i] === -3) {
            continue;
          }
          const isTemporary = validatedOutputIndices[i] === -1;
          const isPersistent = validatedOutputIndices[i] === -2;
          const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
          outputTensorViews.push(tensorView);
          if (tensorView.data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(tensorView.data);
          if (!gpuData) {
            throw new Error(`no GPU data for output: ${tensorView.data}`);
          }
          if (isTemporary) {
            this.temporaryData.push(gpuData);
          }
          if (isPersistent) {
            let persistentData = this.kernelPersistentData.get(this.currentKernelId);
            if (!persistentData) {
              persistentData = [];
              this.kernelPersistentData.set(this.currentKernelId, persistentData);
            }
            persistentData.push(gpuData);
          }
          outputDatas.push(gpuData);
        }
        if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
          if (outputDatas.length === 0) {
            TRACE_FUNC_END(program.name);
            return outputTensorViews;
          }
          throw new Error(
            `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
          );
        }
        let uniformBufferBinding;
        if (programUniforms) {
          let currentOffset = 0;
          const offsets = [];
          programUniforms.forEach((v) => {
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (data.length === 0) {
              return;
            }
            const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
            let sizeOfVecOrMat;
            let baseAlignment;
            if (v.type === 10 /* float16 */) {
              baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
              sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
            } else {
              baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
              sizeOfVecOrMat = 16;
            }
            currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
            offsets.push(currentOffset);
            const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
            currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
          });
          const maxAlignmentOfField = 16;
          currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
          const arrayBuffer = new ArrayBuffer(currentOffset);
          programUniforms.forEach((v, i) => {
            const offset = offsets[i];
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (v.type === 6 /* int32 */) {
              new Int32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 12 /* uint32 */) {
              new Uint32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 10 /* float16 */) {
              new Uint16Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 1 /* float */) {
              new Float32Array(arrayBuffer, offset, data.length).set(data);
            } else {
              throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
            }
          });
          const uniformBufferData = (
            // eslint-disable-next-line no-bitwise
            this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
          );
          this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
          this.gpuDataManager.release(uniformBufferData.id);
          uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
        }
        const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
        const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
        const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
        let artifact = this.programManager.getArtifact(key);
        if (!artifact) {
          artifact = this.programManager.build(program, normalizedDispatchGroup);
          this.programManager.setArtifact(key, artifact);
          LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
        }
        if (programUniforms && artifact.uniformVariablesInfo) {
          if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
            throw new Error(
              `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
            );
          }
          for (let i = 0; i < programUniforms.length; i++) {
            const uniform = programUniforms[i];
            const actualType = uniform.type;
            const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
            const [type, length] = artifact.uniformVariablesInfo[i];
            if (actualType !== type || actualLength !== length) {
              throw new Error(
                `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
              );
            }
          }
        }
        LOG_DEBUG(
          "info",
          () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
        );
        if (this.queryType !== "none" || this.sessionStatus === "capturing") {
          const pendingKernelInfo = {
            kernelId: this.currentKernelId,
            programName: artifact.programInfo.name,
            inputTensorViews,
            outputTensorViews
          };
          this.pendingKernels.push(pendingKernelInfo);
          if (this.sessionStatus === "capturing") {
            const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
            sessionPendingKernels.push(pendingKernelInfo);
          }
        }
        this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
        TRACE_FUNC_END(program.name);
        return outputTensorViews;
      }
      upload(gpuDataId, data) {
        this.gpuDataManager.upload(gpuDataId, data);
      }
      memcpy(src, dst) {
        this.gpuDataManager.memcpy(src, dst);
      }
      async download(gpuDataId, getTargetBuffer) {
        await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
      }
      alloc(size) {
        return this.gpuDataManager.create(size).id;
      }
      free(ptr) {
        return this.gpuDataManager.release(ptr);
      }
      createKernel(kernelType, kernelId, attribute, kernelName) {
        const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
        if (!op) {
          throw new Error(`kernel not implemented: ${kernelType}`);
        }
        const kernelInfo = {
          kernelType,
          kernelName,
          kernelEntry: op[0],
          attributes: [op[1], attribute]
        };
        this.kernels.set(kernelId, kernelInfo);
      }
      releaseKernel(kernelId) {
        const persistentData = this.kernelPersistentData.get(kernelId);
        if (persistentData) {
          for (const data of persistentData) {
            this.gpuDataManager.release(data.id);
          }
          this.kernelPersistentData.delete(kernelId);
        }
        this.kernelCustomData.delete(kernelId);
        this.kernels.delete(kernelId);
      }
      computeKernel(kernelId, context, errors) {
        const kernel = this.kernels.get(kernelId);
        if (!kernel) {
          throw new Error(`kernel not created: ${kernelId}`);
        }
        const kernelType = kernel.kernelType;
        const kernelName = kernel.kernelName;
        const kernelEntry = kernel.kernelEntry;
        const attributes = kernel.attributes;
        if (this.currentKernelId !== null) {
          throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
        }
        this.currentKernelId = kernelId;
        if (attributes[0]) {
          attributes[1] = attributes[0](attributes[1]);
          attributes[0] = void 0;
        }
        LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
        const useErrorScope = this.env.debug;
        this.temporaryData = [];
        try {
          if (useErrorScope) {
            this.device.pushErrorScope("validation");
          }
          kernelEntry(context, attributes[1]);
          return 0;
        } catch (e) {
          errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
          return 1;
        } finally {
          if (useErrorScope) {
            errors.push(
              this.device.popErrorScope().then(
                (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
              )
            );
          }
          for (const data of this.temporaryData) {
            this.gpuDataManager.release(data.id);
          }
          this.temporaryData = [];
          this.currentKernelId = null;
        }
      }
      // #region external buffer
      registerBuffer(sessionId, index, buffer, size) {
        let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (!sessionInputOutputMapping) {
          sessionInputOutputMapping = /* @__PURE__ */ new Map();
          this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
        }
        const previousBuffer = sessionInputOutputMapping.get(index);
        const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer);
        sessionInputOutputMapping.set(index, [id, buffer]);
        return id;
      }
      unregisterBuffers(sessionId) {
        const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (sessionInputOutputMapping) {
          sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[0]));
          this.sessionExternalDataMapping.delete(sessionId);
        }
      }
      getBuffer(gpuDataId) {
        const gpuData = this.gpuDataManager.get(gpuDataId);
        if (!gpuData) {
          throw new Error(`no GPU data for buffer: ${gpuDataId}`);
        }
        return gpuData.buffer;
      }
      createDownloader(gpuBuffer, size, type) {
        return async () => {
          const data = await downloadGpuData(this, gpuBuffer, size);
          return createView(data.buffer, type);
        };
      }
      // #endregion
      writeTimestamp(index) {
        if (this.queryType !== "inside-passes") {
          return;
        }
        this.computePassEncoder.writeTimestamp(this.querySet, index);
      }
      setQueryType() {
        this.queryType = "none";
        if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
          if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            this.queryType = "inside-passes";
          } else if (this.device.features.has("timestamp-query")) {
            this.queryType = "at-passes";
          }
          if (this.queryType !== "none" && typeof this.querySet === "undefined") {
            this.querySet = this.device.createQuerySet({
              type: "timestamp",
              count: this.maxDispatchNumber * 2
            });
            this.queryResolveBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
            );
          }
        }
      }
      captureBegin() {
        LOG_DEBUG("info", "captureBegin");
        if (!this.capturedCommandList.get(this.currentSessionId)) {
          this.capturedCommandList.set(this.currentSessionId, []);
        }
        if (!this.capturedPendingKernels.get(this.currentSessionId)) {
          this.capturedPendingKernels.set(this.currentSessionId, []);
        }
        this.flush();
        this.sessionStatus = "capturing";
      }
      captureEnd() {
        LOG_DEBUG("info", "captureEnd");
        this.flush();
        this.sessionStatus = "default";
      }
      replay() {
        LOG_DEBUG("info", "replay");
        this.sessionStatus = "replaying";
        const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
        const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
        const length = sessionCommandList.length;
        this.pendingKernels = [];
        for (let i = 0; i < length; i++) {
          const computePassEncoder = this.getComputePassEncoder();
          const command = sessionCommandList[i];
          this.writeTimestamp(this.pendingDispatchNumber * 2);
          computePassEncoder.setPipeline(command.computePipeline);
          computePassEncoder.setBindGroup(0, command.bindGroup);
          computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
          this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
          this.pendingDispatchNumber++;
          if (this.queryType !== "none") {
            this.pendingKernels.push(sessionPendingKernels[i]);
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
            this.endComputePass();
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
            this.flush();
          }
        }
        this.flush();
        this.sessionStatus = "default";
      }
      onCreateSession() {
        this.gpuDataManager.onCreateSession();
      }
      onReleaseSession(sessionId) {
        this.unregisterBuffers(sessionId);
        if (this.capturedCommandList.has(sessionId)) {
          this.capturedCommandList.delete(sessionId);
        }
        if (this.capturedPendingKernels.has(sessionId)) {
          this.capturedPendingKernels.delete(sessionId);
        }
        this.gpuDataManager.onReleaseSession(sessionId);
      }
      onRunStart(sessionId) {
        this.currentSessionId = sessionId;
        this.setQueryType();
      }
    };
  }
});

// web/lib/wasm/jsep/webnn/tensor-manager.ts
var tensorGuid, createNewTensorId, TensorWrapper, TensorIdTracker, TensorManagerImpl, createTensorManager;
var init_tensor_manager = __esm({
  "web/lib/wasm/jsep/webnn/tensor-manager.ts"() {
    "use strict";
    init_log();
    tensorGuid = 1;
    createNewTensorId = () => tensorGuid++;
    TensorWrapper = class {
      constructor(descriptor) {
        this.sessionId = descriptor.sessionId;
        this.mlContext = descriptor.context;
        this.mlTensor = descriptor.tensor;
        this.dataType = descriptor.dataType;
        this.tensorShape = descriptor.shape;
      }
      get tensor() {
        return this.mlTensor;
      }
      get type() {
        return this.dataType;
      }
      get shape() {
        return this.tensorShape;
      }
      destroy() {
        LOG_DEBUG("verbose", () => "[WebNN] TensorWrapper.destroy");
        this.mlTensor.destroy();
      }
      write(data) {
        this.mlContext.writeTensor(this.mlTensor, data);
      }
      async read(dstBuffer) {
        if (dstBuffer) {
          return this.mlContext.readTensor(this.mlTensor, dstBuffer);
        }
        return this.mlContext.readTensor(this.mlTensor);
      }
      sameTypeAndShape(dataType, shape) {
        return this.dataType === dataType && this.tensorShape.every((v, i) => v === shape[i]);
      }
    };
    TensorIdTracker = class {
      constructor(tensorManager, wrapper) {
        this.tensorManager = tensorManager;
        this.wrapper = wrapper;
      }
      get tensorWrapper() {
        return this.wrapper;
      }
      releaseTensor() {
        if (this.tensorWrapper) {
          this.tensorManager.releaseTensor(this.tensorWrapper);
        }
      }
      async ensureTensor(dataType, shape, copyOld) {
        if (this.wrapper) {
          if (this.wrapper.sameTypeAndShape(dataType, shape)) {
            return this.wrapper.tensor;
          } else {
            if (copyOld) {
              this.activeUpload = new Uint8Array(await this.wrapper.read());
            }
            this.tensorManager.releaseTensor(this.wrapper);
          }
        }
        const usage = MLTensorUsage.READ | MLTensorUsage.WRITE;
        this.wrapper = await this.tensorManager.getCachedTensor(dataType, shape, usage, true, true);
        if (copyOld && this.activeUpload) {
          this.wrapper.write(this.activeUpload);
          this.activeUpload = void 0;
        }
        return this.wrapper.tensor;
      }
      upload(data) {
        if (this.wrapper) {
          this.wrapper.write(data);
          return;
        }
        if (this.activeUpload) {
          this.activeUpload.set(data);
        } else {
          this.activeUpload = new Uint8Array(data);
        }
      }
      async download(dstBuffer) {
        if (this.activeUpload) {
          if (dstBuffer) {
            if (dstBuffer instanceof ArrayBuffer) {
              new Uint8Array(dstBuffer).set(this.activeUpload);
            } else {
              new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength).set(this.activeUpload);
            }
            return;
          } else {
            return this.activeUpload.buffer;
          }
        }
        if (!this.wrapper) {
          throw new Error("Tensor has not been created.");
        }
        if (!dstBuffer) {
          return this.wrapper.read();
        }
        return this.wrapper.read(dstBuffer);
      }
    };
    TensorManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.tensorTrackersById = /* @__PURE__ */ new Map();
        this.freeTensors = [];
        this.externalTensors = /* @__PURE__ */ new Set();
      }
      reserveTensorId() {
        const tensorId = createNewTensorId();
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this));
        return tensorId;
      }
      releaseTensorId(tensorId) {
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          return;
        }
        this.tensorTrackersById.delete(tensorId);
        if (tensorTracker.tensorWrapper) {
          this.releaseTensor(tensorTracker.tensorWrapper);
        }
      }
      async ensureTensor(tensorId, dataType, shape, copyOld) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.ensureTensor {tensorId: ${tensorId}, dataType: ${dataType}, shape: ${shape}, copyOld: ${copyOld}}`
        );
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        return tensor.ensureTensor(dataType, shape, copyOld);
      }
      upload(tensorId, data) {
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        tensor.upload(data);
      }
      async download(tensorId, dstBuffer) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.download {tensorId: ${tensorId}, dstBuffer: ${dstBuffer?.byteLength}}`
        );
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          throw new Error("Tensor not found.");
        }
        return tensorTracker.download(dstBuffer);
      }
      releaseTensorsForSession(sessionId) {
        for (const tensor of this.freeTensors) {
          if (tensor.sessionId === sessionId) {
            tensor.destroy();
          }
        }
        this.freeTensors = this.freeTensors.filter((tensor) => tensor.sessionId !== sessionId);
      }
      registerTensor(mlContext, mlTensor, dataType, shape) {
        const tensorId = createNewTensorId();
        const wrapper = new TensorWrapper({
          sessionId: this.backend.currentSessionId,
          context: mlContext,
          tensor: mlTensor,
          dataType,
          shape
        });
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this, wrapper));
        this.externalTensors.add(wrapper);
        return tensorId;
      }
      /**
       * Get or create an MLTensor with the given data type and shape.
       */
      async getCachedTensor(dataType, shape, usage, writable, readable) {
        const sessionId = this.backend.currentSessionId;
        for (const [index, tensor2] of this.freeTensors.entries()) {
          if (tensor2.sameTypeAndShape(dataType, shape)) {
            const wrapper = this.freeTensors.splice(index, 1)[0];
            wrapper.sessionId = sessionId;
            return wrapper;
          }
        }
        const context = this.backend.currentContext;
        LOG_DEBUG("verbose", () => `[WebNN] MLContext.createTensor {dataType: ${dataType}, shape: ${shape}}`);
        const tensor = await context.createTensor({
          dataType,
          shape,
          dimensions: shape,
          usage,
          writable,
          readable
        });
        return new TensorWrapper({ sessionId, context, tensor, dataType, shape });
      }
      /**
       * Release tensor for reuse unless external.
       */
      releaseTensor(tensorWrapper) {
        if (this.externalTensors.has(tensorWrapper)) {
          this.externalTensors.delete(tensorWrapper);
        }
        this.freeTensors.push(tensorWrapper);
      }
    };
    createTensorManager = (...args) => new TensorManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/backend-webnn.ts
var onnxDataTypeToWebnnDataType, WebNNBackend;
var init_backend_webnn = __esm({
  "web/lib/wasm/jsep/backend-webnn.ts"() {
    "use strict";
    init_wasm_common();
    init_wasm_factory();
    init_tensor_view();
    init_tensor_manager();
    init_log();
    onnxDataTypeToWebnnDataType = /* @__PURE__ */ new Map([
      [1 /* float */, "float32"],
      [10 /* float16 */, "float16"],
      [6 /* int32 */, "int32"],
      [12 /* uint32 */, "uint32"],
      [7 /* int64 */, "int64"],
      [13 /* uint64 */, "uint64"],
      [3 /* int8 */, "int8"],
      [2 /* uint8 */, "uint8"],
      [9 /* bool */, "uint8"]
    ]);
    WebNNBackend = class {
      constructor(env3) {
        /**
         * Tensor managers for each session.
         */
        this.tensorManager = createTensorManager(this);
        /**
         * Maps from session id to MLContexts.
         */
        this.mlContextBySessionId = /* @__PURE__ */ new Map();
        /**
         * Maps from MLContext to session ids.
         */
        this.sessionIdsByMLContext = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
      }
      get currentSessionId() {
        if (this.activeSessionId === void 0) {
          throw new Error("No active session");
        }
        return this.activeSessionId;
      }
      onRunStart(sessionId) {
        this.activeSessionId = sessionId;
      }
      get currentContext() {
        const mlContext = this.getMLContext(this.currentSessionId);
        if (!mlContext) {
          throw new Error(`No MLContext found for session ${this.currentSessionId}`);
        }
        return mlContext;
      }
      registerMLContext(sessionId, mlContext) {
        this.mlContextBySessionId.set(sessionId, mlContext);
        let sessionIds = this.sessionIdsByMLContext.get(mlContext);
        if (!sessionIds) {
          sessionIds = /* @__PURE__ */ new Set();
          this.sessionIdsByMLContext.set(mlContext, sessionIds);
        }
        sessionIds.add(sessionId);
      }
      onReleaseSession(sessionId) {
        const mlContext = this.mlContextBySessionId.get(sessionId);
        if (!mlContext) {
          return;
        }
        this.tensorManager.releaseTensorsForSession(sessionId);
        this.mlContextBySessionId.delete(sessionId);
        const sessionIds = this.sessionIdsByMLContext.get(mlContext);
        sessionIds.delete(sessionId);
        if (sessionIds.size === 0) {
          this.sessionIdsByMLContext.delete(mlContext);
        }
      }
      getMLContext(sessionId) {
        return this.mlContextBySessionId.get(sessionId);
      }
      reserveTensorId() {
        return this.tensorManager.reserveTensorId();
      }
      releaseTensorId(tensorId) {
        LOG_DEBUG("verbose", () => `[WebNN] releaseTensorId {tensorId: ${tensorId}}`);
        this.tensorManager.releaseTensorId(tensorId);
      }
      async ensureTensor(tensorId, onnxDataType, dimensions, copyOld) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        return this.tensorManager.ensureTensor(tensorId, webnnDataType, dimensions, copyOld);
      }
      uploadTensor(tensorId, data) {
        const wasm2 = getInstance();
        if (!wasm2.shouldTransferToMLTensor) {
          throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
        }
        LOG_DEBUG("verbose", () => `[WebNN] uploadTensor {tensorId: ${tensorId}, data: ${data.byteLength}}`);
        this.tensorManager.upload(tensorId, data);
      }
      async downloadTensor(tensorId, dstBuffer) {
        return this.tensorManager.download(tensorId, dstBuffer);
      }
      createMLTensorDownloader(tensorId, type) {
        return async () => {
          const data = await this.tensorManager.download(tensorId);
          return createView(data, type);
        };
      }
      registerMLTensor(tensor, onnxDataType, dimensions) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        const id = this.tensorManager.registerTensor(this.currentContext, tensor, webnnDataType, dimensions);
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] registerMLTensor {tensor: ${tensor}, dataType: ${webnnDataType}, dimensions: ${dimensions}} -> {tensorId: ${id}}`
        );
        return id;
      }
      // Register WebNN Constant operands from external data.
      registerMLConstant(externalFilePath, dataOffset, dataLength, builder, desc, mountedFiles) {
        if (!mountedFiles) {
          throw new Error("External mounted files are not available.");
        }
        let filePath = externalFilePath;
        if (externalFilePath.startsWith("./")) {
          filePath = externalFilePath.substring(2);
        }
        const fileData = mountedFiles.get(filePath);
        if (!fileData) {
          throw new Error(`File with name ${filePath} not found in preloaded files.`);
        }
        if (dataOffset + dataLength > fileData.byteLength) {
          throw new Error("Out of bounds: data offset and length exceed the external file data size.");
        }
        const buffer = fileData.slice(dataOffset, dataOffset + dataLength).buffer;
        let bufferView;
        switch (desc.dataType) {
          case "float32":
            bufferView = new Float32Array(buffer);
            break;
          case "float16":
            bufferView = new Uint16Array(buffer);
            break;
          case "int32":
            bufferView = new Int32Array(buffer);
            break;
          case "uint32":
            bufferView = new Uint32Array(buffer);
            break;
          case "int64":
            bufferView = new BigInt64Array(buffer);
            break;
          case "uint64":
            bufferView = new BigUint64Array(buffer);
            break;
          case "int8":
            bufferView = new Int8Array(buffer);
            break;
          case "uint8":
            bufferView = new Uint8Array(buffer);
            break;
          default:
            throw new Error(`Unsupported data type: ${desc.dataType} in creating WebNN Constant from external data.`);
        }
        LOG_DEBUG("verbose", () => `[WebNN] registerMLConstant {dataType: ${desc.dataType}, shape: ${desc.shape}}}`);
        return builder.constant(desc, bufferView);
      }
      flush() {
      }
    };
  }
});

// web/lib/wasm/jsep/init.ts
var init_exports = {};
__export(init_exports, {
  init: () => init
});
var TensorViewImpl, ComputeContextImpl, init;
var init_init = __esm({
  "web/lib/wasm/jsep/init.ts"() {
    "use strict";
    init_wasm_common();
    init_backend_webgpu();
    init_log();
    init_util();
    init_backend_webnn();
    TensorViewImpl = class _TensorViewImpl {
      constructor(module, dataType, data, dims) {
        this.module = module;
        this.dataType = dataType;
        this.data = data;
        this.dims = dims;
      }
      getFloat32Array() {
        if (this.dataType !== 1 /* float */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getBigInt64Array() {
        if (this.dataType !== 7 /* int64 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getInt32Array() {
        if (this.dataType !== 6 /* int32 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getUint16Array() {
        if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      reshape(newDims) {
        if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
          throw new Error("Invalid new shape");
        }
        return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
      }
    };
    ComputeContextImpl = class {
      constructor(module, backend, contextDataOffset) {
        this.module = module;
        this.backend = backend;
        this.customDataOffset = 0;
        this.customDataSize = 0;
        this.adapterInfo = backend.adapterInfo;
        const heapU32 = module.HEAPU32;
        let dataIndex = contextDataOffset >>> 2;
        this.opKernelContext = heapU32[dataIndex++];
        const inputCount = heapU32[dataIndex++];
        this.outputCount = heapU32[dataIndex++];
        this.customDataOffset = heapU32[dataIndex++];
        this.customDataSize = heapU32[dataIndex++];
        const inputs = [];
        for (let i = 0; i < inputCount; i++) {
          const dataType = heapU32[dataIndex++];
          const data = heapU32[dataIndex++];
          const dim = heapU32[dataIndex++];
          const dims = [];
          for (let d = 0; d < dim; d++) {
            dims.push(heapU32[dataIndex++]);
          }
          inputs.push(new TensorViewImpl(module, dataType, data, dims));
        }
        this.inputs = inputs;
      }
      get kernelCustomData() {
        return this.backend.currentKernelCustomData;
      }
      get customDataBuffer() {
        return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
      }
      getMaxComputeWorkgroupSizes() {
        return [
          this.backend.device.limits.maxComputeWorkgroupSizeX,
          this.backend.device.limits.maxComputeWorkgroupSizeY,
          this.backend.device.limits.maxComputeWorkgroupSizeZ
        ];
      }
      getMaxComputeWorkgroupStoragesize() {
        return this.backend.device.limits.maxComputeWorkgroupStorageSize;
      }
      compute(program, inputsOutputsMapping) {
        const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
        const outputIndices = inputsOutputsMapping?.outputs ?? [];
        const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
        const createTemporaryOutput = (dataType, dims) => {
          const bufferSize = calculateTensorSizeInBytes(dataType, dims);
          if (!bufferSize) {
            throw new Error(`Unsupported data type: ${dataType}`);
          }
          const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
          return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
        };
        return this.backend.run(
          program,
          mappedInputs,
          outputIndices,
          createKernelOutput,
          createTemporaryOutput,
          this.outputCount
        );
      }
      output(index, dims) {
        const stack = this.module.stackSave();
        try {
          const data = this.module.stackAlloc(
            (1 + dims.length) * 4
            /* sizeof(size_t) */
          );
          let offset = data >> 2;
          this.module.HEAPU32[offset++] = dims.length;
          for (let i = 0; i < dims.length; i++) {
            this.module.HEAPU32[offset++] = dims[i];
          }
          return this.module._JsepOutput(this.opKernelContext, index, data);
        } catch (e) {
          throw new Error(
            `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
          );
        } finally {
          this.module.stackRestore(stack);
        }
      }
    };
    init = async (name, module, env3, gpuAdapter) => {
      const jsepInit = module.jsepInit;
      if (!jsepInit) {
        throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
      }
      if (name === "webgpu") {
        const backend = new WebGpuBackend();
        await backend.initialize(env3, gpuAdapter);
        jsepInit("webgpu", [
          // backend
          backend,
          // jsepAlloc()
          (size) => backend.alloc(size),
          // jsepFree()
          (ptr) => backend.free(ptr),
          // jsepCopy(src, dst, size, isSourceGpu)
          (src, dst, size, isSourceGpu = false) => {
            if (isSourceGpu) {
              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${src}, dst=${dst}, size=${size}`);
              backend.memcpy(src, dst);
            } else {
              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${src}, gpuDataId=${dst}, size=${size}`);
              const data = module.HEAPU8.subarray(src >>> 0, (src >>> 0) + size);
              backend.upload(dst, data);
            }
          },
          // jsepCopyAsync(src, dst, size)
          async (gpuDataId, dataOffset, size) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
            );
            await backend.download(gpuDataId, () => module.HEAPU8.subarray(dataOffset >>> 0, (dataOffset >>> 0) + size));
          },
          // jsepCreateKernel
          (kernelType, kernelId, attribute) => backend.createKernel(kernelType, kernelId, attribute, module.UTF8ToString(module._JsepGetNodeName(kernelId))),
          // jsepReleaseKernel
          (kernel) => backend.releaseKernel(kernel),
          // jsepRun
          (kernel, contextDataOffset, sessionHandle, errors) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
            );
            const context = new ComputeContextImpl(module, backend, contextDataOffset);
            return backend.computeKernel(kernel, context, errors);
          },
          // jsepCaptureBegin
          () => backend.captureBegin(),
          // jsepCaptureEnd
          () => backend.captureEnd(),
          // jsepReplay
          () => backend.replay()
        ]);
      } else {
        const backend = new WebNNBackend(env3);
        jsepInit("webnn", [
          backend,
          // jsepReserveTensorId
          () => backend.reserveTensorId(),
          // jsepReleaseTensorId,
          (tensorId) => backend.releaseTensorId(tensorId),
          // jsepEnsureTensor
          async (tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(tensorId, onnxDataType, shape, copyOld),
          // jsepUploadTensor
          (tensorId, data) => {
            backend.uploadTensor(tensorId, data);
          },
          // jsepDownloadTensor
          async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer)
        ]);
      }
    };
  }
});

// web/lib/wasm/wasm-core-impl.ts
var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
var init_wasm_core_impl = __esm({
  "web/lib/wasm/wasm-core-impl.ts"() {
    "use strict";
    init_run_options();
    init_session_options();
    init_wasm_common();
    init_wasm_factory();
    init_wasm_utils();
    init_wasm_utils_load_file();
    initOrt = (numThreads, loggingLevel) => {
      const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
      if (errorCode !== 0) {
        checkLastError("Can't initialize onnxruntime.");
      }
    };
    initRuntime = async (env3) => {
      initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
    };
    initEp = async (env3, epName) => {
      if (true) {
        const initJsep = (init_init(), __toCommonJS(init_exports)).init;
        if (epName === "webgpu") {
          if (typeof navigator === "undefined" || !navigator.gpu) {
            throw new Error("WebGPU is not supported in current environment");
          }
          let adapter = env3.webgpu.adapter;
          if (!adapter) {
            const powerPreference = env3.webgpu.powerPreference;
            if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
              throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
            }
            const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
            if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
              throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
            }
            adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
            if (!adapter) {
              throw new Error(
                'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
              );
            }
          } else {
            if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
              throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
            }
          }
          await initJsep("webgpu", getInstance(), env3, adapter);
        }
        if (epName === "webnn") {
          if (typeof navigator === "undefined" || !navigator.ml) {
            throw new Error("WebNN is not supported in current environment");
          }
          await initJsep("webnn", getInstance(), env3);
        }
      }
    };
    activeSessions = /* @__PURE__ */ new Map();
    getSessionInputOutputCount = (sessionHandle) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const dataOffset = wasm2.stackAlloc(8);
        const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output count.");
        }
        return [wasm2.HEAP32[dataOffset / 4], wasm2.HEAP32[dataOffset / 4 + 1]];
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    copyFromExternalBuffer = (model) => {
      const wasm2 = getInstance();
      const modelDataOffset = wasm2._malloc(model.byteLength);
      if (modelDataOffset === 0) {
        throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
      }
      wasm2.HEAPU8.set(model, modelDataOffset);
      return [modelDataOffset, model.byteLength];
    };
    createSession = async (modelData, options) => {
      let modelDataOffset, modelDataLength;
      const wasm2 = getInstance();
      if (Array.isArray(modelData)) {
        [modelDataOffset, modelDataLength] = modelData;
      } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
        [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
      } else {
        [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
      }
      let sessionHandle = 0;
      let sessionOptionsHandle = 0;
      let ioBindingHandle = 0;
      let allocs = [];
      const inputNamesUTF8Encoded = [];
      const outputNamesUTF8Encoded = [];
      try {
        [sessionOptionsHandle, allocs] = setSessionOptions(options);
        if (options?.externalData && wasm2.mountExternalData) {
          const loadingPromises = [];
          for (const file of options.externalData) {
            const path = typeof file === "string" ? file : file.path;
            loadingPromises.push(
              loadFile(typeof file === "string" ? file : file.data).then((data) => {
                wasm2.mountExternalData(path, data);
              })
            );
          }
          await Promise.all(loadingPromises);
        }
        for (const provider of options?.executionProviders ?? []) {
          const providerName = typeof provider === "string" ? provider : provider.name;
          if (providerName === "webnn") {
            wasm2.shouldTransferToMLTensor = false;
            if (wasm2.currentContext) {
              throw new Error("WebNN execution provider is already set.");
            }
            if (typeof provider !== "string") {
              const webnnOptions = provider;
              const context = webnnOptions?.context;
              const gpuDevice = webnnOptions?.gpuDevice;
              const deviceType = webnnOptions?.deviceType;
              const powerPreference = webnnOptions?.powerPreference;
              if (context) {
                wasm2.currentContext = context;
              } else if (gpuDevice) {
                wasm2.currentContext = await navigator.ml.createContext(gpuDevice);
              } else {
                wasm2.currentContext = await navigator.ml.createContext({ deviceType, powerPreference });
              }
            } else {
              wasm2.currentContext = await navigator.ml.createContext();
            }
            break;
          }
        }
        sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
        if (sessionHandle === 0) {
          checkLastError("Can't create a session.");
        }
        wasm2.jsepOnCreateSession?.();
        if (wasm2.currentContext) {
          wasm2.jsepRegisterMLContext(sessionHandle, wasm2.currentContext);
          wasm2.currentContext = void 0;
          wasm2.shouldTransferToMLTensor = true;
        }
        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
        const enableGraphCapture = !!options?.enableGraphCapture;
        const inputNames = [];
        const outputNames = [];
        const outputPreferredLocations = [];
        for (let i = 0; i < inputCount; i++) {
          const name = wasm2._OrtGetInputName(sessionHandle, i);
          if (name === 0) {
            checkLastError("Can't get an input name.");
          }
          inputNamesUTF8Encoded.push(name);
          inputNames.push(wasm2.UTF8ToString(name));
        }
        for (let i = 0; i < outputCount; i++) {
          const name = wasm2._OrtGetOutputName(sessionHandle, i);
          if (name === 0) {
            checkLastError("Can't get an output name.");
          }
          outputNamesUTF8Encoded.push(name);
          const nameString = wasm2.UTF8ToString(name);
          outputNames.push(nameString);
          if (true) {
            if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
              outputPreferredLocations.push("gpu-buffer");
              continue;
            }
            const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
            if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
              throw new Error(`Not supported preferred output location: ${location2}.`);
            }
            if (enableGraphCapture && location2 !== "gpu-buffer") {
              throw new Error(
                `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
              );
            }
            outputPreferredLocations.push(location2);
          }
        }
        let bindingState = null;
        if (outputPreferredLocations.some((l) => l === "gpu-buffer" || l === "ml-tensor")) {
          ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
          if (ioBindingHandle === 0) {
            checkLastError("Can't create IO binding.");
          }
          bindingState = {
            handle: ioBindingHandle,
            outputPreferredLocations,
            outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
          };
        }
        activeSessions.set(sessionHandle, [
          sessionHandle,
          inputNamesUTF8Encoded,
          outputNamesUTF8Encoded,
          bindingState,
          enableGraphCapture,
          false
        ]);
        return [sessionHandle, inputNames, outputNames];
      } catch (e) {
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (ioBindingHandle !== 0) {
          wasm2._OrtReleaseBinding(ioBindingHandle);
        }
        if (sessionHandle !== 0) {
          wasm2._OrtReleaseSession(sessionHandle);
        }
        throw e;
      } finally {
        wasm2._free(modelDataOffset);
        if (sessionOptionsHandle !== 0) {
          wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        wasm2.unmountExternalData?.();
      }
    };
    releaseSession = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot release session. invalid session id: ${sessionId}`);
      }
      const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
      if (ioBindingState) {
        if (enableGraphCapture) {
          wasm2._OrtClearBoundOutputs(ioBindingState.handle);
        }
        wasm2._OrtReleaseBinding(ioBindingState.handle);
      }
      wasm2.jsepOnReleaseSession?.(sessionId);
      inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      wasm2._OrtReleaseSession(sessionHandle);
      activeSessions.delete(sessionId);
    };
    prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
      if (!tensor) {
        tensorHandles.push(0);
        return;
      }
      const wasm2 = getInstance();
      const dataType = tensor[0];
      const dims = tensor[1];
      const location2 = tensor[3];
      let rawData;
      let dataByteLength;
      if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
        throw new Error("String tensor is not supported on GPU.");
      }
      if (enableGraphCapture && location2 !== "gpu-buffer") {
        throw new Error(
          `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
        );
      }
      if (location2 === "gpu-buffer") {
        const gpuBuffer = tensor[2].gpuBuffer;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        const registerBuffer = wasm2.jsepRegisterBuffer;
        if (!registerBuffer) {
          throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
        }
        rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
      } else if (location2 === "ml-tensor") {
        const mlTensor = tensor[2].mlTensor;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        const registerMLTensor = wasm2.jsepRegisterMLTensor;
        if (!registerMLTensor) {
          throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
        }
        rawData = registerMLTensor(mlTensor, tensorDataTypeStringToEnum(dataType), dims);
      } else {
        const data = tensor[2];
        if (Array.isArray(data)) {
          dataByteLength = 4 * data.length;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          let dataIndex = rawData / 4;
          for (let i = 0; i < data.length; i++) {
            if (typeof data[i] !== "string") {
              throw new TypeError(`tensor data at index ${i} is not a string`);
            }
            wasm2.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
          }
        } else {
          dataByteLength = data.byteLength;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
        }
      }
      const stack = wasm2.stackSave();
      const dimsOffset = wasm2.stackAlloc(4 * dims.length);
      try {
        let dimIndex = dimsOffset / 4;
        dims.forEach((d) => wasm2.HEAP32[dimIndex++] = d);
        const tensor2 = wasm2._OrtCreateTensor(
          tensorDataTypeStringToEnum(dataType),
          rawData,
          dataByteLength,
          dimsOffset,
          dims.length,
          dataLocationStringToEnum(location2)
        );
        if (tensor2 === 0) {
          checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
        }
        tensorHandles.push(tensor2);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
      }
      const sessionHandle = session[0];
      const inputNamesUTF8Encoded = session[1];
      const outputNamesUTF8Encoded = session[2];
      const ioBindingState = session[3];
      const enableGraphCapture = session[4];
      const inputOutputBound = session[5];
      const inputCount = inputIndices.length;
      const outputCount = outputIndices.length;
      let runOptionsHandle = 0;
      let runOptionsAllocs = [];
      const inputTensorHandles = [];
      const outputTensorHandles = [];
      const inputOutputAllocs = [];
      const beforeRunStack = wasm2.stackSave();
      const inputValuesOffset = wasm2.stackAlloc(inputCount * 4);
      const inputNamesOffset = wasm2.stackAlloc(inputCount * 4);
      const outputValuesOffset = wasm2.stackAlloc(outputCount * 4);
      const outputNamesOffset = wasm2.stackAlloc(outputCount * 4);
      try {
        wasm2.jsepOnRunStart?.(sessionHandle);
        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
        for (let i = 0; i < inputCount; i++) {
          prepareInputOutputTensor(
            inputTensors[i],
            inputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputIndices[i],
            enableGraphCapture
          );
        }
        for (let i = 0; i < outputCount; i++) {
          prepareInputOutputTensor(
            outputTensors[i],
            outputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputCount + outputIndices[i],
            enableGraphCapture
          );
        }
        let inputValuesIndex = inputValuesOffset / 4;
        let inputNamesIndex = inputNamesOffset / 4;
        let outputValuesIndex = outputValuesOffset / 4;
        let outputNamesIndex = outputNamesOffset / 4;
        for (let i = 0; i < inputCount; i++) {
          wasm2.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
          wasm2.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
        }
        for (let i = 0; i < outputCount; i++) {
          wasm2.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
          wasm2.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
        }
        if (ioBindingState && !inputOutputBound) {
          const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
          if (inputNamesUTF8Encoded.length !== inputCount) {
            throw new Error(
              `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
            );
          }
          for (let i = 0; i < inputCount; i++) {
            const index = inputIndices[i];
            const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
            if (errorCode2 !== 0) {
              checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
            }
          }
          for (let i = 0; i < outputCount; i++) {
            const index = outputIndices[i];
            const location2 = outputTensors[i]?.[3];
            if (location2) {
              const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
              }
            } else {
              const errorCode2 = wasm2._OrtBindOutput(
                handle,
                outputNamesUTF8Encoded[index],
                0,
                outputPreferredLocationsEncoded[index]
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
              }
            }
          }
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            true
          ]);
        }
        let errorCode;
        if (ioBindingState) {
          errorCode = await wasm2._OrtRunWithBinding(
            sessionHandle,
            ioBindingState.handle,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        } else {
          errorCode = await wasm2._OrtRun(
            sessionHandle,
            inputNamesOffset,
            inputValuesOffset,
            inputCount,
            outputNamesOffset,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        }
        if (errorCode !== 0) {
          checkLastError("failed to call OrtRun().");
        }
        const output = [];
        for (let i = 0; i < outputCount; i++) {
          const tensor = wasm2.HEAPU32[outputValuesOffset / 4 + i];
          if (tensor === outputTensorHandles[i]) {
            output.push(outputTensors[i]);
            continue;
          }
          const beforeGetTensorDataStack = wasm2.stackSave();
          const tensorDataOffset = wasm2.stackAlloc(4 * 4);
          let keepOutputTensor = false;
          let type, dataOffset = 0;
          try {
            const errorCode2 = wasm2._OrtGetTensorData(
              tensor,
              tensorDataOffset,
              tensorDataOffset + 4,
              tensorDataOffset + 8,
              tensorDataOffset + 12
            );
            if (errorCode2 !== 0) {
              checkLastError(`Can't access output tensor data on index ${i}.`);
            }
            let tensorDataIndex = tensorDataOffset / 4;
            const dataType = wasm2.HEAPU32[tensorDataIndex++];
            dataOffset = wasm2.HEAPU32[tensorDataIndex++];
            const dimsOffset = wasm2.HEAPU32[tensorDataIndex++];
            const dimsLength = wasm2.HEAPU32[tensorDataIndex++];
            const dims = [];
            for (let i2 = 0; i2 < dimsLength; i2++) {
              dims.push(wasm2.HEAPU32[dimsOffset / 4 + i2]);
            }
            wasm2._OrtFree(dimsOffset);
            const size = dims.reduce((a, b) => a * b, 1);
            type = tensorDataTypeEnumToString(dataType);
            const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
            if (type === "string") {
              if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                throw new Error("String tensor is not supported on GPU.");
              }
              const stringData = [];
              let dataIndex = dataOffset / 4;
              for (let i2 = 0; i2 < size; i2++) {
                const offset = wasm2.HEAPU32[dataIndex++];
                const maxBytesToRead = i2 === size - 1 ? void 0 : wasm2.HEAPU32[dataIndex] - offset;
                stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
              }
              output.push([type, dims, stringData, "cpu"]);
            } else {
              if (preferredLocation === "gpu-buffer" && size > 0) {
                const getBuffer = wasm2.jsepGetBuffer;
                if (!getBuffer) {
                  throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                }
                const gpuBuffer = getBuffer(dataOffset);
                const bufferSize = calculateTensorSizeInBytes(dataType, size);
                if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    gpuBuffer,
                    download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                    dispose: () => {
                      wasm2._OrtReleaseTensor(tensor);
                    }
                  },
                  "gpu-buffer"
                ]);
              } else if (preferredLocation === "ml-tensor" && size > 0) {
                const ensureTensor = wasm2.jsepEnsureTensor;
                if (!ensureTensor) {
                  throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                }
                const tensorSize = calculateTensorSizeInBytes(dataType, size);
                if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                const mlTensor = await ensureTensor(dataOffset, dataType, dims, false);
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    mlTensor,
                    download: wasm2.jsepCreateMLTensorDownloader(dataOffset, type),
                    dispose: () => {
                      wasm2.jsepReleaseTensorId(dataOffset);
                      wasm2._OrtReleaseTensor(tensor);
                    }
                  },
                  "ml-tensor"
                ]);
              } else {
                const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                const data = new typedArrayConstructor(size);
                new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                  wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                );
                output.push([type, dims, data, "cpu"]);
              }
            }
          } finally {
            wasm2.stackRestore(beforeGetTensorDataStack);
            if (type === "string" && dataOffset) {
              wasm2._free(dataOffset);
            }
            if (!keepOutputTensor) {
              wasm2._OrtReleaseTensor(tensor);
            }
          }
        }
        if (ioBindingState && !enableGraphCapture) {
          wasm2._OrtClearBoundOutputs(ioBindingState.handle);
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            false
          ]);
        }
        return output;
      } finally {
        wasm2.stackRestore(beforeRunStack);
        inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        inputOutputAllocs.forEach((p) => wasm2._free(p));
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        runOptionsAllocs.forEach((p) => wasm2._free(p));
      }
    };
    endProfiling = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error("invalid session id");
      }
      const sessionHandle = session[0];
      const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
      if (profileFileName === 0) {
        checkLastError("Can't get an profile file name.");
      }
      wasm2._OrtFree(profileFileName);
    };
    extractTransferableBuffers = (tensors) => {
      const buffers = [];
      for (const tensor of tensors) {
        const data = tensor[2];
        if (!Array.isArray(data) && "buffer" in data) {
          buffers.push(data.buffer);
        }
      }
      return buffers;
    };
  }
});

// web/lib/wasm/proxy-wrapper.ts
var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
var init_proxy_wrapper = __esm({
  "web/lib/wasm/proxy-wrapper.ts"() {
    "use strict";
    init_esm();
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
    initializing2 = false;
    initialized2 = false;
    aborted2 = false;
    queuedCallbacks = /* @__PURE__ */ new Map();
    enqueueCallbacks = (type, callbacks) => {
      const queue = queuedCallbacks.get(type);
      if (queue) {
        queue.push(callbacks);
      } else {
        queuedCallbacks.set(type, [callbacks]);
      }
    };
    ensureWorker = () => {
      if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
        throw new Error("worker not ready");
      }
    };
    onProxyWorkerMessage = (ev) => {
      switch (ev.data.type) {
        case "init-wasm":
          initializing2 = false;
          if (ev.data.err) {
            aborted2 = true;
            initWasmCallbacks[1](ev.data.err);
          } else {
            initialized2 = true;
            initWasmCallbacks[0]();
          }
          if (temporaryObjectUrl) {
            URL.revokeObjectURL(temporaryObjectUrl);
            temporaryObjectUrl = void 0;
          }
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          const callbacks = queuedCallbacks.get(ev.data.type);
          if (ev.data.err) {
            callbacks.shift()[1](ev.data.err);
          } else {
            callbacks.shift()[0](ev.data.out);
          }
          break;
        }
        default:
      }
    };
    initializeWebAssemblyAndOrtRuntime = async () => {
      if (initialized2) {
        return;
      }
      if (initializing2) {
        throw new Error("multiple calls to 'initWasm()' detected.");
      }
      if (aborted2) {
        throw new Error("previous call to 'initWasm()' failed.");
      }
      initializing2 = true;
      if (isProxy()) {
        return new Promise((resolve, reject) => {
          proxyWorker?.terminate();
          void importProxyWorker().then(([objectUrl, worker]) => {
            try {
              proxyWorker = worker;
              proxyWorker.onerror = (ev) => reject(ev);
              proxyWorker.onmessage = onProxyWorkerMessage;
              initWasmCallbacks = [resolve, reject];
              const message = { type: "init-wasm", in: env2 };
              proxyWorker.postMessage(message);
              temporaryObjectUrl = objectUrl;
            } catch (e) {
              reject(e);
            }
          }, reject);
        });
      } else {
        try {
          await initializeWebAssembly(env2.wasm);
          await initRuntime(env2);
          initialized2 = true;
        } catch (e) {
          aborted2 = true;
          throw e;
        } finally {
          initializing2 = false;
        }
      }
    };
    initializeOrtEp = async (epName) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("init-ep", [resolve, reject]);
          const message = { type: "init-ep", in: { epName, env: env2 } };
          proxyWorker.postMessage(message);
        });
      } else {
        await initEp(env2, epName);
      }
    };
    copyFromExternalBuffer2 = async (buffer) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("copy-from", [resolve, reject]);
          const message = { type: "copy-from", in: { buffer } };
          proxyWorker.postMessage(message, [buffer.buffer]);
        });
      } else {
        return copyFromExternalBuffer(buffer);
      }
    };
    createSession2 = async (model, options) => {
      if (isProxy()) {
        if (options?.preferredOutputLocation) {
          throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("create", [resolve, reject]);
          const message = { type: "create", in: { model, options: { ...options } } };
          const transferable = [];
          if (model instanceof Uint8Array) {
            transferable.push(model.buffer);
          }
          proxyWorker.postMessage(message, transferable);
        });
      } else {
        return createSession(model, options);
      }
    };
    releaseSession2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("release", [resolve, reject]);
          const message = { type: "release", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        releaseSession(sessionId);
      }
    };
    run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
      if (isProxy()) {
        if (inputs.some((t) => t[3] !== "cpu")) {
          throw new Error("input tensor on GPU is not supported for proxy.");
        }
        if (outputs.some((t) => t)) {
          throw new Error("pre-allocated output tensor is not supported for proxy.");
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("run", [resolve, reject]);
          const serializableInputs = inputs;
          const message = {
            type: "run",
            in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
          };
          proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
        });
      } else {
        return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
      }
    };
    endProfiling2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("end-profiling", [resolve, reject]);
          const message = { type: "end-profiling", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        endProfiling(sessionId);
      }
    };
  }
});

// web/lib/wasm/session-handler-inference.ts
var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/wasm/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_wasm_common();
    init_wasm_utils_env();
    init_wasm_utils_load_file();
    encodeTensorMetadata = (tensor, getName) => {
      switch (tensor.location) {
        case "cpu":
          return [tensor.type, tensor.dims, tensor.data, "cpu"];
        case "gpu-buffer":
          return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
        case "ml-tensor":
          return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
        default:
          throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
      }
    };
    decodeTensorMetadata = (tensor) => {
      switch (tensor[3]) {
        case "cpu":
          return new Tensor2(tensor[0], tensor[2], tensor[1]);
        case "gpu-buffer": {
          const dataType = tensor[0];
          if (!isGpuBufferSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
          }
          const { gpuBuffer, download, dispose } = tensor[2];
          return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
        }
        case "ml-tensor": {
          const dataType = tensor[0];
          if (!isMLTensorSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
          }
          const { mlTensor, download, dispose } = tensor[2];
          return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
        }
        default:
          throw new Error(`invalid data location: ${tensor[3]}`);
      }
    };
    OnnxruntimeWebAssemblySessionHandler = class {
      async fetchModelAndCopyToWasmMemory(path) {
        return copyFromExternalBuffer2(await loadFile(path));
      }
      async loadModel(pathOrBuffer, options) {
        TRACE_FUNC_BEGIN();
        let model;
        if (typeof pathOrBuffer === "string") {
          if (isNode) {
            model = await loadFile(pathOrBuffer);
          } else {
            model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
          }
        } else {
          model = pathOrBuffer;
        }
        [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
        TRACE_FUNC_END();
      }
      async dispose() {
        return releaseSession2(this.sessionId);
      }
      async run(feeds, fetches, options) {
        TRACE_FUNC_BEGIN();
        const inputArray = [];
        const inputIndices = [];
        Object.entries(feeds).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.inputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid input '${name}'`);
          }
          inputArray.push(tensor);
          inputIndices.push(index);
        });
        const outputArray = [];
        const outputIndices = [];
        Object.entries(fetches).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.outputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid output '${name}'`);
          }
          outputArray.push(tensor);
          outputIndices.push(index);
        });
        const inputs = inputArray.map(
          (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
        );
        const outputs = outputArray.map(
          (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
        );
        const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
        const resultMap = {};
        for (let i = 0; i < results.length; i++) {
          resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
        }
        TRACE_FUNC_END();
        return resultMap;
      }
      startProfiling() {
      }
      endProfiling() {
        void endProfiling2(this.sessionId);
      }
    };
  }
});

// web/lib/backend-wasm.ts
var backend_wasm_exports = {};
__export(backend_wasm_exports, {
  OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
  initializeFlags: () => initializeFlags,
  wasmBackend: () => wasmBackend
});
var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
var init_backend_wasm = __esm({
  "web/lib/backend-wasm.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_session_handler_inference();
    init_wasm_utils_import();
    initializeFlags = () => {
      if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
        env2.wasm.initTimeout = 0;
      }
      if (env2.wasm.simd === false) {
        console.warn(
          'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
        );
      }
      if (typeof env2.wasm.proxy !== "boolean") {
        env2.wasm.proxy = false;
      }
      if (typeof env2.wasm.trace !== "boolean") {
        env2.wasm.trace = false;
      }
      if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          env2.wasm.numThreads = 1;
        } else {
          const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
          env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
        }
      }
      if (true) {
        if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
          env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
        }
      }
    };
    OnnxruntimeWebAssemblyBackend = class {
      /**
       * This function initializes the WebAssembly backend.
       *
       * This function will be called only once for each backend name. It will be called the first time when
       * `ort.InferenceSession.create()` is called with a registered backend name.
       *
       * @param backendName - the registered backend name.
       */
      async init(backendName) {
        initializeFlags();
        await initializeWebAssemblyAndOrtRuntime();
        await initializeOrtEp(backendName);
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const handler = new OnnxruntimeWebAssemblySessionHandler();
        await handler.loadModel(pathOrBuffer, options);
        return Promise.resolve(handler);
      }
    };
    wasmBackend = new OnnxruntimeWebAssemblyBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.21.0-dev.20241024-d9ca84ef96";

// web/lib/index.ts
var lib_default = esm_exports;
if (false) {
  const onnxjsBackend = null.onnxjsBackend;
  registerBackend("webgl", onnxjsBackend, -10);
}
if (true) {
  const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
  if (true) {
    registerBackend("webgpu", wasmBackend2, 5);
    registerBackend("webnn", wasmBackend2, 5);
  }
  registerBackend("cpu", wasmBackend2, 10);
  registerBackend("wasm", wasmBackend2, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  TrainingSession2 as TrainingSession,
  lib_default as default,
  env2 as env,
  registerBackend
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1lbnYudHMiLCAiLi4vbGliL3dhc20vcHJveHktd29ya2VyL21haW4udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1mYWN0b3J5LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMudHMiLCAiLi4vbGliL3dhc20vcnVuLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1vcHRpb25zLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29tbW9uLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMtbG9hZC1maWxlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvbG9nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb21tb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLXNoYXJlZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9hcmdtaW5tYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2F0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmF0Y2gtbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmlhcy1hZGQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLXNwbGl0LWdlbHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9mdXNlLXV0aWxzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvYWN0aXZhdGlvbl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX21tX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LXRyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY3Vtc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9kZXB0aC10by1zcGFjZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZWluc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9leHBhbmQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Zhc3QtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXItYmxvY2stcXVhbnRpemVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXItZWxlbWVudHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dlbW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL211bHRpaGVhZC1hdHRlbnRpb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NwbGl0LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9ncm91cC1xdWVyeS1hdHRlbnRpb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2luc3RhbmNlLW5vcm0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2xheWVyLW5vcm0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bG5iaXRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wYWQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3Bvb2wudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3F1YW50aXplLWxpbmVhci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmFuZ2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3Jlc2l6ZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcm90YXJ5LWVtYmVkZGluZy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2tpcC1sYXllci1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zbGljZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc29mdG1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdGlsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvd2hlcmUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3AtcmVzb2x2ZS1ydWxlcy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC9iYWNrZW5kLXdlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYm5uL3RlbnNvci1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJubi50cyIsICIuLi9saWIvd2FzbS9qc2VwL2luaXQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5cbmludGVyZmFjZSBCYWNrZW5kSW5mbyB7XG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XG4gIHByaW9yaXR5OiBudW1iZXI7XG5cbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuICBpbml0aWFsaXplZD86IGJvb2xlYW47XG4gIGFib3J0ZWQ/OiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7IGJhY2tlbmQsIHByaW9yaXR5IH0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jIChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kIHwgc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXG4gIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gIC8vIHRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGFsbCByZXF1ZXN0ZWQgYmFja2VuZHNcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0ID0gYXdhaXQgdHJ5UmVzb2x2ZUFuZEluaXRpYWxpemVCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIGJhY2tlbmQgaXMgYXZhaWxhYmxlLCB0aHJvdyBlcnJvci5cbiAgaWYgKCFiYWNrZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2Vycm9ycy5tYXAoKGUpID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICAvLyBmb3IgZWFjaCBleHBsaWNpdGx5IHJlcXVlc3RlZCBiYWNrZW5kLCBpZiBpdCdzIG5vdCBhdmFpbGFibGUsIG91dHB1dCB3YXJuaW5nIG1lc3NhZ2UuXG4gIGZvciAoY29uc3QgeyBuYW1lLCBlcnIgfSBvZiBlcnJvcnMpIHtcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcigoaSkgPT4gYXZhaWxhYmxlQmFja2VuZE5hbWVzLmhhcyh0eXBlb2YgaSA9PT0gJ3N0cmluZycgPyBpIDogaS5uYW1lKSk7XG5cbiAgcmV0dXJuIFtcbiAgICBiYWNrZW5kLFxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XG4gICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgfSxcbiAgICB9KSxcbiAgXTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhbiBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcblxuICBjcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyPyhcbiAgICBjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIHRyYWluTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIGV2YWxNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMC1kZXYuMjAyNDEwMTYtMmI4ZmM1NTI5Yic7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7IGNvbW1vbjogdmVyc2lvbiB9LFxuXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBsb2dMZXZlbFZhbHVlID0gdmFsdWU7XG4gIH0sXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcbiAgICByZXR1cm4gbG9nTGV2ZWxWYWx1ZTtcbiAgfSxcbn07XG5cbi8vIHNldCBwcm9wZXJ0eSAnbG9nTGV2ZWwnIHNvIHRoYXQgdGhleSBjYW4gYmUgY29ycmVjdGx5IHRyYW5zZmVycmVkIHRvIHdvcmtlciBieSBgcG9zdE1lc3NhZ2UoKWAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiBhcyBlbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanNgIGZvciB0cmFpbmluZyBidWlsZFxuICAgICAqL1xuICAgIG1qcz86IFVSTCB8IHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeCB8IFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXG4gICAgICogYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgZm9yIG1hdG11bC4gMCBtZWFucyB0byBkaXNhYmxlIGJhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBtYXRtdWxNYXhCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgdGV4dHVyZSBjYWNoZSBtb2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxuICAgICAqL1xuICAgIHRleHR1cmVDYWNoZU1vZGU/OiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwYWNrZWQgdGV4dHVyZSBtb2RlXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwYWNrPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgZW5hYmxlIGFzeW5jIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgYXN5bmM/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YSB7XG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XG4gICAgdmVyc2lvbjogMTtcbiAgICBpbnB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAga2VybmVsSWQ6IG51bWJlcjtcbiAgICBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xuICAgIHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZTogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKi9cbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlcjtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfVxuICAgICAqL1xuICAgIGFkYXB0ZXI6IHVua25vd247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVEZXZpY2VgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBkZXZpY2UgPSBlbnYud2ViZ3B1LmRldmljZSBhcyBHUFVEZXZpY2U7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX0gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgbm90IHVzZSB0eXBlcyBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRldmljZTogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdmFsaWRhdGUgaW5wdXQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlSW5wdXRDb250ZW50PzogYm9vbGVhbjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XG4gIC8qKlxuICAgKiBzZXQgdGhlIHNldmVyaXR5IGxldmVsIGZvciBsb2dnaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGAnd2FybmluZydgXG4gICAqL1xuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgIHwgbnVsbDtcblxuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgLy8gRyB2YWx1ZVxuICAgICAgICBjb25zdCBCID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk7XG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgY2hhbm5lbHM6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgIChjaGFubmVscyA9PT0gMyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsXG4gICAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgICAgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKytcbiAgICApIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgLy8gQSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBPcHRpb25zRGltZW5zaW9ucyxcbiAgT3B0aW9uc0Zvcm1hdCxcbiAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zLFxuICBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckludGVyZmFjZSB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8geyBtZWFuOiAyNTUsIGJpYXM6IDAgfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICB9IGVsc2Uge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiFbMF0sIG5vcm0ubWVhbiFbMV0sIG5vcm0ubWVhbiFbMl0sIG5vcm0ubWVhbiFbM10gPz8gMjU1XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCxcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcbiAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICBiSW1hZ2VQb2ludGVyID0gMixcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDA7XG4gICAgaSA8IHN0cmlkZTtcbiAgICBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcFxuICApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxuICAgIG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnXG4gICAgICA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKVxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tSW1hZ2UoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jIChcbiAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgb3B0aW9ucz86XG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tR3B1QnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tR3B1QnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tTUxUZW5zb3IoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgbWxUZW5zb3I6IFRlbnNvckludGVyZmFjZS5NTFRlbnNvclR5cGUsXG4gIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ21sLXRlbnNvcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgbWxUZW5zb3IsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVBpbm5lZEJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gIHR5cGU6IFQsXG4gIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBUZW5zb3IgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcbiAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gIFsnYm9vbCcsIFVpbnQ4QXJyYXldLFxuICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbiAgWydpbnQ0JywgVWludDhBcnJheV0sXG4gIFsndWludDQnLCBVaW50OEFycmF5XSxcbl0pO1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXG4gIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXG4gICAgICAgIG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7XG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXG4gIHRlbnNvckZyb21JbWFnZSxcbiAgdGVuc29yRnJvbU1MVGVuc29yLFxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxuICB0ZW5zb3JGcm9tVGV4dHVyZSxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9ucyxcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1xuICBjaGVja1R5cGVkQXJyYXksXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXksXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG59IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IFRlbnNvclR5cGUsXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ21sLXRlbnNvcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Zsb2F0MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ2NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnYm9vbCdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWxUZW5zb3JEYXRhID0gYXJnMC5tbFRlbnNvcjtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xuICAgICAgLy9cbiAgICAgIGxldCBkYXRhOiBUZW5zb3JEYXRhVHlwZTtcbiAgICAgIGxldCBtYXliZURpbXM6IHR5cGVvZiBhcmcxIHwgdHlwZW9mIGFyZzI7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICBtYXliZURpbXMgPSBhcmcyO1xuICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgLy8gZXJyb3Igd2lsbCBiZSBwb3B1bGF0ZWQgYXQgaW5mZXJlbmNlXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgaWYgKChhcmcwID09PSAnZmxvYXQxNicgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSkgfHwgYXJnMCA9PT0gJ3VpbnQ0JyB8fCBhcmcwID09PSAnaW50NCcpIHtcbiAgICAgICAgICAgICAgLy8gLSAnZmxvYXQxNic6XG4gICAgICAgICAgICAgIC8vICAgV2hlbiBubyBGbG9hdDE2QXJyYXkgcG9seWZpbGwgaXMgdXNlZCwgd2UgY2Fubm90IGNyZWF0ZSAnZmxvYXQxNicgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5LlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAgIFRocm93IGVycm9yIGhlcmUgYmVjYXVzZSB3aGVuIHVzZXIgdHJ5IHRvIHVzZSBudW1iZXIgYXJyYXkgYXMgZGF0YSxcbiAgICAgICAgICAgICAgLy8gICBlLmcuIG5ldyBUZW5zb3IoJ2Zsb2F0MTYnLCBbMSwgMiwgMywgNF0sIGRpbXMpKSwgaXQgd2lsbCBhY3R1YWxseSBjYWxsXG4gICAgICAgICAgICAgIC8vICAgVWludDE2QXJyYXkuZnJvbShhcmcxKSB3aGljaCBnZW5lcmF0ZXMgd3JvbmcgZGF0YS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gLSAndWludDQnIGFuZCAnaW50NCc6XG4gICAgICAgICAgICAgIC8vICAgVWludDhBcnJheS5mcm9tKGFyZzEpIHdpbGwgZ2VuZXJhdGUgd3JvbmcgZGF0YSBmb3IgJ3VpbnQ0JyBhbmQgJ2ludDQnIHRlbnNvci5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgQ3JlYXRpbmcgYSAke2FyZzB9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9IGFzIGRhdGEuYCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAvLyAyLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdW5pb24gdHlwZSBvZiAnKEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yKS5mcm9tKCknXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgIC8vIHR5cGUuXG5cbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgaWYgKGFyZzAgPT09ICd1aW50OCcpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzAgYXMgYW55W10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICB0eXBlID0gJ3VpbnQ4JztcbiAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcbiAgICAgICAgICBjb25zdCBtYXBwZWRUeXBlID0gTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5nZXQoXG4gICAgICAgICAgICBhcmcwLmNvbnN0cnVjdG9yIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHthcmcwLmNvbnN0cnVjdG9yfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSA9IG1hcHBlZFR5cGU7XG4gICAgICAgICAgZGF0YSA9IGFyZzAgYXMgU3VwcG9ydGVkVHlwZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgaWYgKG1heWJlRGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGFzc3VtZSAxLUQgdGVuc29yIGlmIGRpbXMgb21pdHRlZFxuICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYXliZURpbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGRpbXMgPSBtYXliZURpbXMgYXMgcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gY2hlY2sgb24gZGltc1xuICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGRpbXMpO1xuICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcbiAgICBpZiAodGhpcy5jcHVEYXRhICYmIHNpemUgIT09IHRoaXMuY3B1RGF0YS5sZW5ndGgpIHtcbiAgICAgIGlmICgodHlwZSA9PT0gJ3VpbnQ0JyB8fCB0eXBlID09PSAnaW50NCcpICYmIE1hdGguY2VpbChzaXplIC8gMikgPT09IHRoaXMuY3B1RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gZm9yICh1KWludDQsIHRoZSBkYXRhIGxlbmd0aCBpcyBoYWxmIG9mIHRoZSB0ZW5zb3Igc2l6ZS4gU28gd2UgY2hlY2sgdGhpcyBzcGVjaWFsIGNhc2Ugd2hlbiBzaXplIGlzIG9kZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3NpemV9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBmYWN0b3J5XG4gIHN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoXG4gICAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzpcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUZW5zb3JJbnRlcmZhY2U+IHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxuICAgIHRleHR1cmU6IFRlbnNvclRleHR1cmVUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVRleHR1cmUodGV4dHVyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgZ3B1QnVmZmVyOiBUZW5zb3JHcHVCdWZmZXJUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+LFxuICApOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tR3B1QnVmZmVyKGdwdUJ1ZmZlciwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU1MVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuTUxUZW5zb3JEYXRhVHlwZXM+KFxuICAgIG1sVGVuc29yOiBUZW5zb3JNTFRlbnNvclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbU1MVGVuc29yKG1sVGVuc29yLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVBpbm5lZEJ1ZmZlcih0eXBlLCBidWZmZXIsIGRpbXMpO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29udmVyc2lvbnNcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XG4gICAgcmV0dXJuIHRlbnNvclRvSW1hZ2VEYXRhKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHB1YmxpYyBmaWVsZHNcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHR5cGU6IFRlbnNvclR5cGU7XG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJpdmF0ZSBmaWVsZHNcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGF0YUxvY2F0aW9uOiBUZW5zb3JEYXRhTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgZGF0YSBvbiBDUFUsIGlmIGxvY2F0aW9uIGlzICdjcHUnIG9yICdjcHUtcGlubmVkJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdVRleHR1cmVEYXRhPzogVGVuc29yVGV4dHVyZVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBHUFUgYnVmZmVyIHdoZW4gbG9jYXRpb24gaXMgJ2dwdS1idWZmZXInLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdUJ1ZmZlckRhdGE/OiBUZW5zb3JHcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgV2ViTk4gTUxUZW5zb3Igd2hlbiBsb2NhdGlvbiBpcyAnbWwtdGVuc29yJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBtbFRlbnNvckRhdGE/OiBUZW5zb3JNTFRlbnNvclR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkb3dubG9hZGVyIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBkb3dubG9hZGVyPygpOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPjtcblxuICAvKipcbiAgICogYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGF0YSBpcyBiZWluZyBkb3dubG9hZGVkIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgaXNEb3dubG9hZGluZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkaXNwb3NlciBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2VyPygpOiB2b2lkO1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcm9wZXJ0aWVzXG4gIGdldCBkYXRhKCk6IFRlbnNvckRhdGFUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmNwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsICcgK1xuICAgICAgICAgICdvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNwdURhdGE7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKTogVGVuc29yRGF0YUxvY2F0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhTG9jYXRpb247XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpOiBUZW5zb3JUZXh0dXJlVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5ncHVUZXh0dXJlRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XG4gIH1cblxuICBnZXQgZ3B1QnVmZmVyKCk6IFRlbnNvckdwdUJ1ZmZlclR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1QnVmZmVyRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YTtcbiAgfVxuXG4gIGdldCBtbFRlbnNvcigpOiBUZW5zb3JNTFRlbnNvclR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMubWxUZW5zb3JEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJOTiBNTFRlbnNvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWxUZW5zb3JEYXRhO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIG1ldGhvZHNcblxuICBhc3luYyBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+IHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgc3dpdGNoICh0aGlzLmRhdGFMb2NhdGlvbikge1xuICAgICAgY2FzZSAnY3B1JzpcbiAgICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgICAgaWYgKCF0aGlzLmRvd25sb2FkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAocmVsZWFzZURhdGEgJiYgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlcigpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY3B1RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1sVGVuc29yRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKHRoaXMuZG93bmxvYWRlciB8fCB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JSZXNoYXBlKHRoaXMsIGRpbXMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yRmFjdG9yeSB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckltcGwgfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbmltcG9ydCB7IFR5cGVkVGVuc29yVXRpbHMgfSBmcm9tICcuL3RlbnNvci11dGlscy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuLyoqXG4gKiByZXByZXNlbnQgYSBiYXNpYyB0ZW5zb3Igd2l0aCBzcGVjaWZpZWQgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlLlxuICovXG5pbnRlcmZhY2UgVHlwZWRUZW5zb3JCYXNlPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gQ1BVIChlZy4gaXQncyBpbiB0aGUgZm9ybSBvZiBXZWJHTCB0ZXh0dXJlIG9yIFdlYkdQVSBidWZmZXIpLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHTCB0ZXh0dXJlLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHUFUgYnVmZmVyLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViTk4gTUxUZW5zb3IgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBpbiBhIFdlYk5OIE1MVGVuc29yLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IG1sVGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmV0dXJucyB0aGUgZGF0YSBpbW1lZGlhdGVseS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCBkb3dubG9hZHMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZWxlYXNlRGF0YSAtIHdoZXRoZXIgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuIElnbm9yZSBpZiBkYXRhIGlzIGFscmVhZHkgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJlbW92ZSBpdHMgaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXG4gICAqXG4gICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgdGhlIHRlbnNvciBpcyBjb25zaWRlcmVkIG5vIGxvbmdlciB2YWxpZC4gSXRzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdub25lJy5cbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRlbnNvciB7XG4gIGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDg6IEludDhBcnJheTtcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIGludDMyOiBJbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IFVpbnQ4QXJyYXk7XG4gICAgaW50NDogSW50OEFycmF5O1xuICB9XG5cbiAgaW50ZXJmYWNlIEVsZW1lbnRUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBudW1iZXI7XG4gICAgdWludDg6IG51bWJlcjtcbiAgICBpbnQ4OiBudW1iZXI7XG4gICAgdWludDE2OiBudW1iZXI7XG4gICAgaW50MTY6IG51bWJlcjtcbiAgICBpbnQzMjogbnVtYmVyO1xuICAgIGludDY0OiBiaWdpbnQ7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICBmbG9hdDE2OiBudW1iZXI7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IG51bWJlcjtcbiAgICBpbnQ0OiBudW1iZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHsgc2l6ZTogbnVtYmVyOyBtYXBTdGF0ZTogJ3VubWFwcGVkJyB8ICdwZW5kaW5nJyB8ICdtYXBwZWQnIH07XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYk5OIE1MVGVuc29yXG4gICAqXG4gICAqIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBXZWJOTidzIE1MVGVuc29yIGlzIGN1cnJlbnRseSBpbiBmbHV4LlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgTUxUZW5zb3JUeXBlID0gdW5rbm93bjtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyRGF0YVR5cGVzID0gJ2Zsb2F0MzInIHwgJ2Zsb2F0MTYnIHwgJ2ludDMyJyB8ICdpbnQ2NCcgfCAndWludDMyJyB8ICd1aW50OCcgfCAnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvckRhdGFUeXBlcyA9XG4gICAgfCAnZmxvYXQzMidcbiAgICB8ICdmbG9hdDE2J1xuICAgIHwgJ2ludDgnXG4gICAgfCAndWludDgnXG4gICAgfCAnaW50MzInXG4gICAgfCAndWludDMyJ1xuICAgIHwgJ2ludDY0J1xuICAgIHwgJ3VpbnQ2NCdcbiAgICB8ICdib29sJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHdoZXJlIHRoZSB0ZW5zb3IgZGF0YSBpcyBzdG9yZWRcbiAgICovXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJyB8ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ3RleHR1cmUnIHwgJ2dwdS1idWZmZXInIHwgJ21sLXRlbnNvcic7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5UeXBlPiBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUPiwgVHlwZWRUZW5zb3JVdGlsczxUPiB7fVxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxuXG4vKipcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JDb25zdHJ1Y3RvciBleHRlbmRzIFRlbnNvckZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ10gfCByZWFkb25seSBzdHJpbmdbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChcbiAgICB0eXBlOiAnYm9vbCcsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIGEgVWludDhDbGFtcGVkQXJyYXksIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKHR5cGU6ICd1aW50OCcsIGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IDY0LWJpdCBpbnRlZ2VyIHR5cGVkIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzICd1aW50NjQnIHwgJ2ludDY0Jz4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBudW1lcmljIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnIHwgJ2Jvb2wnIHwgJ3VpbnQ2NCcgfCAnaW50NjQnPj4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogRmxvYXQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogSW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBCaWdJbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEZsb2F0NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogQmlnVWludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50NjQnPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6IFRlbnNvci5UeXBlLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZSB8IHJlYWRvbmx5IG51bWJlcltdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbCBhcyBUZW5zb3JDb25zdHJ1Y3RvcjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0UgPSAoZGV2aWNlVHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IFRSQUNFX0ZVTkMgPSAobXNnOiBzdHJpbmcsIGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKSB8fCBbXTtcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgbGFiZWwgKz0gYDo6JHtleHRyYU1zZ31gO1xuICAgICAgfVxuICAgICAgVFJBQ0UoJ0NQVScsIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGhhc1RyYWNlRnVuYyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICBhcmcwOiBzdHJpbmcgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5LFxuICAgIGFyZzE/OiBTZXNzaW9uT3B0aW9ucyB8IG51bWJlcixcbiAgICBhcmcyPzogbnVtYmVyLFxuICAgIGFyZzM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBsZXQgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhcmcwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB9XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgT25ueE1vZGVsT3B0aW9ucyB9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIGlucHV0L291dHB1dCB0eXBlc1xuXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xuICB0eXBlIE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcblxuICAvKipcbiAgICogQSBmZWVkcyAobW9kZWwgaW5wdXRzKSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogLSBPbWl0dGVkLiBVc2UgbW9kZWwncyBvdXRwdXQgbmFtZXMgZGVmaW5pdGlvbi5cbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxuICAgKiAtIEFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIG9yIG51bGwgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtcbiAgICogZGlmZmVyZW50IGZyb20gaW5wdXQgYXJndW1lbnQsIGluIG91dHB1dCwgT25ueFZhbHVlIGlzIG9wdGlvbmFsLiBJZiBhbiBPbm54VmFsdWUgaXMgcHJlc2VudCBpdCB3aWxsIGJlXG4gICAqIHVzZWQgYXMgYSBwcmUtYWxsb2NhdGVkIHZhbHVlIGJ5IHRoZSBpbmZlcmVuY2UgZW5naW5lOyBpZiBvbWl0dGVkLCBpbmZlcmVuY2UgZW5naW5lIHdpbGwgYWxsb2NhdGUgYnVmZmVyXG4gICAqIGludGVybmFsbHkuXG4gICAqL1xuICB0eXBlIEZldGNoZXNUeXBlID0gcmVhZG9ubHkgc3RyaW5nW10gfCBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgaW5mZXJlbmNpbmcgcmV0dXJuIHR5cGUgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBSZXR1cm5UeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBzZXNzaW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIHNlc3Npb24gYmVoYXZpb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb25PcHRpb25zIGV4dGVuZHMgT25ueE1vZGVsT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9uIGNhbiBiZSBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBleGVjdXRpb24gcHJvdmlkZXIsXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlcnM/OiByZWFkb25seSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludHJhIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRlck9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmcmVlRGltZW5zaW9uT3ZlcnJpZGVzPzogeyByZWFkb25seSBbZGltZW5zaW9uTmFtZTogc3RyaW5nXTogbnVtYmVyIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW1pemF0aW9uIGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnIHwgJ2Jhc2ljJyB8ICdleHRlbmRlZCcgfCAnYWxsJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIENQVSBtZW1vcnkgYXJlbmEuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlQ3B1TWVtQXJlbmE/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgbWVtb3J5IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBleGVjdXRpb25Nb2RlPzogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBtb2RlbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXG4gICAgICogd2l0aCBhIHBvcC11cCB3aW5kb3cuXG4gICAgICovXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgZW5hYmxlUHJvZmlsaW5nPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEZpbGUgcHJlZml4IGZvciBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHByb2ZpbGVGaWxlUHJlZml4Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIElELlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ0lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXG4gICAgICogcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxuICAgICAqL1xuICAgIHByZWZlcnJlZE91dHB1dExvY2F0aW9uPzogT25ueFZhbHVlRGF0YUxvY2F0aW9uIHwgeyByZWFkb25seSBbb3V0cHV0TmFtZTogc3RyaW5nXTogT25ueFZhbHVlRGF0YUxvY2F0aW9uIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBncmFwaCBjYXB0dXJlLlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBlbmFibGVHcmFwaENhcHR1cmU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cbiAgLy8gQmFja2VuZCBXZWJBc3NlbWJseTogc3VwcG9ydHMgJ2NwdScsICd3YXNtJywgJ3dlYmdwdScgYW5kICd3ZWJubicuXG4gIC8vIEJhY2tlbmQgT05OWC5qczogc3VwcG9ydHMgJ3dlYmdsJy5cbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cbiAgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwIHtcbiAgICBjb3JlbWw6IENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3VkYTogQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGRtbDogRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgdGVuc29ycnQ6IFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2FzbTogV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJncHU6IFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYm5uOiBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdXG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvblxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJOYW1lXG4gICAgfCBzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnIHwgJ05IV0MnO1xuICB9XG5cbiAgLy8gI3JlZ2lvbiBXZWJOTiBvcHRpb25zXG5cbiAgaW50ZXJmYWNlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBjcmVhdGluZyBhIFdlYk5OIE1MQ29udGV4dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RpY3RkZWYtbWxjb250ZXh0b3B0aW9uc1xuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBkZXZpY2VUeXBlPzogJ2NwdScgfCAnZ3B1JyB8ICducHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnIHwgJ2xvdy1wb3dlcicgfCAnaGlnaC1wZXJmb3JtYW5jZSc7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhvdXRNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSwgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgY29udGV4dD86IG5ldmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0LlxuICAgKlxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcbiAgICogY2hhbm5lbCBsYXlvdXQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcbiAgICAgIE9taXQ8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPixcbiAgICAgIFJlcXVpcmVkPFBpY2s8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPj4ge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0IHdoaWNoIGlzIGNyZWF0ZWQgZnJvbSBHUFVEZXZpY2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dC1ncHVkZXZpY2VcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2ViR3B1IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICAgIGdwdURldmljZTogdW5rbm93biAvKiBHUFVEZXZpY2UgKi87XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbiA9XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXZWJHcHU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3Fubic7XG4gICAgLy8gVE9ETyBhZGQgZmxhZ3NcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xuICAgIC8qKlxuICAgICAqIFRoZSBiaXQgZmxhZ3MgZm9yIENvcmVNTCBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBDT1JFTUxfRkxBR19VU0VfQ1BVX09OTFkgPSAweDAwMVxuICAgICAqIENPUkVNTF9GTEFHX0VOQUJMRV9PTl9TVUJHUkFQSCA9IDB4MDAyXG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9FTkFCTEVfREVWSUNFX1dJVEhfQU5FID0gMHgwMDRcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0FMTE9XX1NUQVRJQ19JTlBVVF9TSEFQRVMgPSAweDAwOFxuICAgICAqIENPUkVNTF9GTEFHX0NSRUFURV9NTFBST0dSQU0gPSAweDAxMFxuICAgICAqIENPUkVNTF9GTEFHX1VTRV9DUFVfQU5EX0dQVSA9IDB4MDIwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZWUgaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Byb3ZpZGVycy9jb3JlbWwvY29yZW1sX3Byb3ZpZGVyX2ZhY3RvcnkuaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxuICAgICAqL1xuICAgIGNvcmVNbEZsYWdzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byB1c2UgQ1BVIG9ubHkgaW4gQ29yZU1MIEVQLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIHVzZUNQVU9ubHk/OiBib29sZWFuO1xuICAgIHVzZUNQVUFuZEdQVT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBDb3JlTUwgRVAgb24gc3ViZ3JhcGguXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIG9ubHkgZW5hYmxlIENvcmVNTCBFUCBmb3IgQXBwbGUgZGV2aWNlcyB3aXRoIEFORSAoQXBwbGUgTmV1cmFsIEVuZ2luZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xuICAgIHVzZUZQMTY/OiBib29sZWFuO1xuICAgIHVzZU5DSFc/OiBib29sZWFuO1xuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcbiAgICBjcHVPbmx5PzogYm9vbGVhbjtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcnVuIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIGluZmVyZW5jZSBydW4gYmVoYXZpb3JcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgYWxsIGluY29tcGxldGUgT3J0UnVuIGNhbGxzIGFzIHNvb24gYXMgcG9zc2libGUgaWYgdHJ1ZVxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIHRlcm1pbmF0ZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIHRhZyBmb3IgdGhlIFJ1bigpIGNhbGxzIHVzaW5nIHRoaXNcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICB0YWc/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzaW5nbGUgcnVuIGNvbmZpZ3VyYXRpb24gZW50cnkuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3J1bl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4dHJhOiB7XG4gICAgICogICBtZW1vcnk6IHtcbiAgICAgKiAgICAgZW5hYmxlX21lbW9yeV9hcmVuYV9zaHJpbmthZ2U6IFwiMVwiLFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleHRyYT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdmFsdWUgbWV0YWRhdGFcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuICBpbnRlcmZhY2UgVmFsdWVNZXRhZGF0YSB7XG4gICAgLy8gVEJEXG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uT3V0cHV0VHlwZWAgZm9yXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYW4gT05OWCBtb2RlbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uOiBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSA9IEluZmVyZW5jZVNlc3Npb25JbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JMYXlvdXQgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvblV0aWxzIHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGEgRGF0YVVSTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yLCBUeXBlZFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgSW1hZ2VGb3JtYXQgPSAnUkdCJyB8ICdSR0JBJyB8ICdCR1InIHwgJ1JCRyc7XG5leHBvcnQgdHlwZSBJbWFnZVRlbnNvckxheW91dCA9ICdOSFdDJyB8ICdOQ0hXJztcblxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG5cbi8vICNyZWdpb24gdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb25cblxuLyoqXG4gKiByZXByZXNlbnQgY29tbW9uIHByb3BlcnRpZXMgb2YgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqL1xuaW50ZXJmYWNlIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiBleHRlbmRzIFBpY2s8VGVuc29yLCAnZGltcyc+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBHUFUgcmVzb3VyY2UuXG4gKi9cbmludGVyZmFjZSBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZG93bmxvYWQ/KCk6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkaXNwb3NlPygpOiB2b2lkO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzID0gVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2NwdS1waW5uZWQnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIENQVSBwaW5uZWQgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9IFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAndGV4dHVyZScuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ3RleHR1cmUnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0gVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdncHUtYnVmZmVyJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPSBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdtbC10ZW5zb3InLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdtbC10ZW5zb3InO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IG1sVGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgb2YgZWFjaCBpbmRpdmlkdWFsIG9wdGlvbnMuXG4vLyB0aGUgdGVuc29yIGZhY3RvcnkgZnVuY3Rpb25zIHVzZSBhIGNvbXBvc2l0aW9uIG9mIHRob3NlIG9wdGlvbnMgYXMgdGhlIHBhcmFtZXRlciB0eXBlLlxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgZmllbGRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCByZXByZXNlbnRlZCBpbiBSR0JBIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckZvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIG9wdGlvbiAnZm9ybWF0Jy4gV2hpbGUgb3B0aW9uICdmb3JtYXQnIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsIGltYWdlLCAndGVuc29yRm9ybWF0J1xuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICovXG4gIHRlbnNvckZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiAnZmxvYXQzMicgfCAndWludDgnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JMYXlvdXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSB0ZW5zb3IgbGF5b3V0IHdoZW4gcmVwcmVzZW50aW5nIGRhdGEgb2Ygb25lIG9yIG1vcmUgaW1hZ2UocykuXG4gICAqL1xuICB0ZW5zb3JMYXlvdXQ/OiBJbWFnZVRlbnNvckxheW91dDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbFxuICAgKi9cbiAgaGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSB3aWR0aCBpbiBwaXhlbFxuICAgKi9cbiAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSByZXNpemVkIGhlaWdodC4gSWYgb21pdHRlZCwgb3JpZ2luYWwgaGVpZ2h0IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHJlc2l6ZWRIZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgcmVzaXplZCB3aWR0aCAtIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGVuc29yIGRpbWVuc2lvbnMgYXMgd2VsbFxuICAgKi9cbiAgcmVzaXplZFdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgbm9ybWFsaXphdGlvbiBwYXJhbWV0ZXJzIHdoZW4gcHJlcHJvY2Vzc2luZyB0aGUgaW1hZ2UgYXMgbW9kZWwgaW5wdXQuXG4gICAqXG4gICAqIERhdGEgZWxlbWVudCBhcmUgcmFuZ2VkIGZyb20gMCB0byAyNTUuXG4gICAqL1xuICBub3JtPzoge1xuICAgIC8qKlxuICAgICAqIFRoZSAnYmlhcycgdmFsdWUgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAwLlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIGJpYXM/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMjU1LlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21VcmxPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsXG4gICAgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIFJlcXVpcmVkPE9wdGlvbnNEaW1lbnNpb25zPixcbiAgICBPcHRpb25zRm9ybWF0LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IC8qIFRPRE86IGFkZCBtb3JlICovIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vKipcbiAqIHR5cGUgVGVuc29yRmFjdG9yeSBkZWZpbmVzIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucyBvZiAnVGVuc29yJyB0byBjcmVhdGUgdGVuc29yIGluc3RhbmNlcyBmcm9tIGV4aXN0aW5nIGRhdGEgb3JcbiAqIHJlc291cmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGYWN0b3J5IHtcbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlRGF0YSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRGF0YSAtIHRoZSBJbWFnZURhdGEgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSW1hZ2VEYXRhLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgSFRNTEltYWdlRWxlbWVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxuICAgKlxuICAgKiBAcGFyYW0gdXJsU291cmNlIC0gYSBzdHJpbmcgYXMgYSBVUkwgdG8gdGhlIGltYWdlIG9yIGEgZGF0YSBVUkwgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKHVybFNvdXJjZTogc3RyaW5nLCBvcHRpb25zPzogVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlQml0bWFwIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gYml0bWFwIC0gdGhlIEltYWdlQml0bWFwIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGJpdG1hcDogSW1hZ2VCaXRtYXAsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICpcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdMIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYHdpZHRoYDogdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgaGVpZ2h0YDogdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcbiAgICB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuICApOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBHUFVCdWZmZXIgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3IgLSB0aGUgTUxUZW5zb3Igb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIHRoZSBNTFRlbnNvciB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvclxuICAgKiBkYXRhIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgdGhlIFdlYk5OIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy5cbiAgICogVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiB0aGUgV2ViTk4gTUxUZW5zb3IuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvciB3aWxsXG4gICAqIG5vdCBiZSBkaXNwb3NlZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvXG4gICAqIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz4oXG4gICAgdGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhcyBhIHBpbm5lZCBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBidWZmZXIgLSBhIFR5cGVkQXJyYXkgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZS5cbiAgICogQHBhcmFtIGRpbXMgLSBzcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+PihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29yLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxuICpcbiAqIFBhdGggaXMgdmFpbGFibGUgb25seSBpbiBvbm54cnVudGltZS1ub2RlIG9yIG9ubnhydW50aW1lLXdlYiBydW5uaW5nIGluIE5vZGUuanMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVVcmxPclBhdGggPSBzdHJpbmc7XG5cbi8qKlxuICogQSBCbG9iIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XG5cbi8qKlxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxuICpcbiAqIFdoZW4gaXQgaXMgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIsIHRoZSB3aG9sZSBidWZmZXIgaXMgYXNzdW1lZCB0byBiZSB0aGUgZmlsZSBjb250ZW50LlxuICovXG5leHBvcnQgdHlwZSBGaWxlRGF0YSA9IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlckxpa2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZpbGUgdGhhdCBjYW4gYmUgbG9hZGVkIGJ5IHRoZSBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVUeXBlID0gRmlsZVVybE9yUGF0aCB8IEZpbGVCbG9iIHwgRmlsZURhdGE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAgICovXG4gIGRhdGE6IEZpbGVUeXBlO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZmlsZSBwYXRoLlxuICAgKi9cbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICpcbiAqIFdoZW4gdXNpbmcgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBhIGZpbGUgVVJMIG9yIHBhdGggdGhhdCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1vZGVsIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHwgRmlsZVVybE9yUGF0aDtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBtb2RlbCBsb2FkaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9ubnhNb2RlbE9wdGlvbnMge1xuICAvKipcbiAgICogU3BlY2lmeWluZyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCByZXByZXNlbnRzIHRoZSBleHRlcm5hbCBkYXRhLlxuICAgKi9cbiAgZXh0ZXJuYWxEYXRhPzogcmVhZG9ubHkgRXh0ZXJuYWxEYXRhRmlsZVR5cGVbXTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBOb25UZW5zb3JUeXBlID0gbmV2ZXI7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWUgUmVwcmVzZW50cyBib3RoIHRlbnNvcnMgYW5kIG5vbi10ZW5zb3JzIHZhbHVlIGZvciBtb2RlbCdzIGlucHV0cy9vdXRwdXRzLlxuICpcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZSA9IFRlbnNvciB8IE5vblRlbnNvclR5cGU7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgb2YgYW4gT25ueFZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gPSBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IFNlc3Npb25IYW5kbGVyLCBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2UsIFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMgfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZTtcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucztcblxuY29uc3Qgbm9CYWNrZW5kRXJyTXNnOiBzdHJpbmcgPVxuICAnVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuICcgKyBcIk1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLlwiO1xuXG5leHBvcnQgY2xhc3MgVHJhaW5pbmdTZXNzaW9uIGltcGxlbWVudHMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyLCBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbiwgaGFzRXZhbE1vZGVsOiBib29sZWFuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmhhc09wdGltaXplck1vZGVsID0gaGFzT3B0aW1pemVyTW9kZWw7XG4gICAgdGhpcy5oYXNFdmFsTW9kZWwgPSBoYXNFdmFsTW9kZWw7XG4gIH1cbiAgcHJpdmF0ZSBoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyO1xuICBwcml2YXRlIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuO1xuICBwcml2YXRlIGhhc0V2YWxNb2RlbDogYm9vbGVhbjtcblxuICBnZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IHRyYWluaW5nT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXQgZXZhbElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG4gIGdldCBldmFsT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsT3V0cHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgdHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLFxuICAgIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPiB7XG4gICAgY29uc3QgZXZhbE1vZGVsOiBzdHJpbmcgfCBVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpbWl6ZXJNb2RlbDogc3RyaW5nIHwgVWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5vcHRpbWl6ZXJNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHNlc3Npb25PcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgaWYgKGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcikge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcihcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLmNoZWNrcG9pbnRTdGF0ZSxcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLnRyYWluTW9kZWwsXG4gICAgICAgIGV2YWxNb2RlbCxcbiAgICAgICAgb3B0aW1pemVyTW9kZWwsXG4gICAgICAgIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdTZXNzaW9uKGhhbmRsZXIsICEhdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsLCAhIXRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9CYWNrZW5kRXJyTXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBydW5UcmFpblN0ZXAgYW5kIGZ1dHVyZSBydW5TdGVwIG1ldGhvZHMgdGhhdCBoYW5kbGVzIHRoZSB0eXBlLW5hcnJvd2luZyBjb252ZXJzaW9uIGZyb21cbiAgICogdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgYW5kIFJ1bk9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dE5hbWVzIHRoZSBmZWVkcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZXkgY29udGFpbiBhbGwgaW5wdXQgbmFtZXMgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgaW5wdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXROYW1lcyB0aGUgZmV0Y2hlcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZWlyIGtleXMgbWF0Y2ggdXAgd2l0aCB2YWxpZCBuYW1lcyBpbiB0aGUgbGlzdCBvZiBvdXRwdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBmZWVkcyB0aGUgcmVxdWlyZWQgaW5wdXRcbiAgICogQHBhcmFtIGFyZzEgbmFycm93ZWQgJiBjb252ZXJ0ZWQgaW50byB0aGUgU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgb3IgUnVuT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIGFyZzIgb3B0aW9uYWwgUnVuT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB0eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgZmVlZHM6IEZlZWRzVHlwZSxcbiAgICBhcmcxPzogRmV0Y2hlc1R5cGUgfCBSdW5PcHRpb25zLFxuICAgIGFyZzI/OiBSdW5PcHRpb25zLFxuICApOiBbU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIFJ1bk9wdGlvbnNdIHtcbiAgICBjb25zdCBmZXRjaGVzOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsIH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmZXRjaGVzLCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBydW5UcmFpblN0ZXAgYW5kIGFueSBvdGhlciBydW5TdGVwIG1ldGhvZHMuIFRha2VzIHRoZSBSZXR1cm5UeXBlIHJlc3VsdCBmcm9tIHRoZSBTZXNzaW9uSGFuZGxlclxuICAgKiBhbmQgY2hhbmdlcyBpdCBpbnRvIGEgbWFwIG9mIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlKTogUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaGFuZGxlci5sYXp5UmVzZXRHcmFkKCk7XG4gIH1cblxuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID0gdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgIHRoaXMudHJhaW5pbmdJbnB1dE5hbWVzLFxuICAgICAgdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLFxuICAgICAgZmVlZHMsXG4gICAgICBhcmcxLFxuICAgICAgYXJnMixcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuVHJhaW5TdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgfVxuXG4gIGFzeW5jIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmhhc09wdGltaXplck1vZGVsKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcChvcHRpb25zIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlIHwgUnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9IHRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAoXG4gICAgICAgIHRoaXMuZXZhbElucHV0TmFtZXMsXG4gICAgICAgIHRoaXMuZXZhbE91dHB1dE5hbWVzLFxuICAgICAgICBmZWVkcyxcbiAgICAgICAgYXJnMSxcbiAgICAgICAgYXJnMixcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bkV2YWxTdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBFdmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXk6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyYW1zU2l6ZSA9IGF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gICAgLy8gY2hlY2tpbmcgdGhhdCB0aGUgc2l6ZSBvZiB0aGUgVWludDhBcnJheSBpcyBlcXVpdmFsZW50IHRvIHRoZSBieXRlIGxlbmd0aCBvZiBhIEZsb2F0MzJBcnJheSBvZiB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGFyYW1ldGVyc1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQgKiBwYXJhbXNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdTaXplIG9mIHRoZSBidWZmZXIgcGFzc2VkIGludG8gbG9hZFBhcmFtZXRlcnNCdWZmZXIgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaW4gJyArXG4gICAgICAgICAgJ3RoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXksIHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPE9ubnhWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW1wbCB9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi1pbXBsLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEVpdGhlciBVUkkgZmlsZSBwYXRoIChzdHJpbmcpIG9yIFVpbnQ4QXJyYXkgY29udGFpbmluZyBtb2RlbCBvciBjaGVja3BvaW50IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgdHlwZSBVcmlPckJ1ZmZlciA9IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIHRyYWluaW5nIHNlc3Npb24sXG4gKiB3aGljaCBjb250YWlucyBhIG1vZGVsIHRoYXQgY2FuIGJlIHRyYWluZWQsIGFuZCwgb3B0aW9uYWxseSxcbiAqIGFuIGV2YWwgYW5kIG9wdGltaXplciBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIExhemlseSByZXNldHMgdGhlIGdyYWRpZW50cyBvZiBhbGwgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdG8gemVyby4gU2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgaW52b2NhdGlvbiBvZlxuICAgKiBydW5PcHRpbWl6ZXJTdGVwLlxuICAgKi9cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gVHJhaW5TdGVwIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yXG4gICBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRyYWluIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBzaW5nbGUgb3B0aW1pemVyIHN0ZXAsIHdoaWNoIHBlcmZvcm1zIHdlaWdodCB1cGRhdGVzIGZvciB0aGUgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIG9wdGltaXplciBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBvcHRpbWl6aW5nLlxuICAgKi9cbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKFxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb3B5IHBhcmFtZXRlcnNcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGFsbCBwYXJhbWV0ZXJzIGZvciB0aGUgdHJhaW5pbmcgc3RhdGUuIENhbGN1bGF0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBwcmltaXRpdmUgKGRhdGF0eXBlIG9mXG4gICAqIHRoZSBwYXJhbWV0ZXJzKSBlbGVtZW50cyBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIHRyYWluaW5nIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgZm9yIHRyYWluYWJsZSBwYXJhbXMgb25seS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogQ29waWVzIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIHRvIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGhcbiAgICogcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgRmxvYXQzMiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFRydWUgaWYgdHJhaW5hYmxlIHBhcmFtZXRlcnMgb25seSB0byBiZSBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIG1vZGVsIHBhcmFtZXRlcnMgdG8gYSBjb250aWd1b3VzIGJ1ZmZlci4gVXN1YWxseSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIEZlZGVyYXRlZCBMZWFybmluZy5cbiAgICogQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGggcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgb25seSB0cmFpbmFibGUgcGFyYW1ldGVycyBhcmUgY29waWVkLiBUcmFpbmFibGUgcGFyYW1ldGVycyBhcmUgcGFyYW1ldGVyc1xuICAgKiBmb3Igd2hpY2ggcmVxdWlyZXNfZ3JhZCBpcyBzZXQgdG8gdHJ1ZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZsb2F0MzIgT25ueFZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPE9ubnhWYWx1ZT47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIGEgLmNrcHQgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBjaGVja3BvaW50IGZvciB0aGUgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICBjaGVja3BvaW50U3RhdGU6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCB0cmFpbmluZyBmaWxlLlxuICAgKi9cbiAgdHJhaW5Nb2RlbDogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBvcHRpbWl6ZXIgbW9kZWwgZmlsZS5cbiAgICovXG4gIG9wdGltaXplck1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBldmFsIG1vZGVsIGZpbGUuXG4gICAqL1xuICBldmFsTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG59XG5cbi8qKlxuICogRGVmaW5lcyBtZXRob2Qgb3ZlcmxvYWQgcG9zc2liaWxpdGllcyBmb3IgY3JlYXRpbmcgYSBUcmFpbmluZ1Nlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ1Nlc3Npb24gYW5kIGFzeW5jaHJvbm91c2x5IGxvYWRzIGFueSBtb2RlbHMgcGFzc2VkIGluIHRocm91Z2ggdHJhaW5pbmdPcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmluZ09wdGlvbnMgc3BlY2lmeSBtb2RlbHMgYW5kIGNoZWNrcG9pbnRzIHRvIGxvYWQgaW50byB0aGUgVHJhaW5pbmcgU2Vzc2lvblxuICAgKiBAcGFyYW0gc2Vzc2lvbk9wdGlvbnMgc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciB0cmFpbmluZyBzZXNzaW9uIGJlaGF2aW9yXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFRyYWluaW5nU2Vzc2lvbiBvYmplY3RcbiAgICovXG4gIGNyZWF0ZShcbiAgICB0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsXG4gICAgc2Vzc2lvbk9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVHJhaW5pbmdTZXNzaW9uOiBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5ID0gVHJhaW5pbmdTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICEhKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcIkhUTUxJbWFnZUVsZW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgd2hpY2ggaXMgY29uZmxpY3Qgd2l0aCBsaWIud2Vid29ya2VyLmQudHMuXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IEhUTUxJbWFnZUVsZW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4vLyBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyBub2RlX21vZHVsZXMvQHdlYmdwdS90eXBlcy9kaXN0L2luZGV4LmQudHM6ODM6NyAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDgzICAgICB8IEhUTUxJbWFnZUVsZW1lbnRcbi8vICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXG4vLyBieXBhc3MgdGhlIHR5cGUgY2hlY2suXG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJkb2N1bWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJkb2N1bWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCBzbyBpdCdzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgZG9jdW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjMzIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6NjEgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6ODggLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxTY3JpcHRFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5+XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBkb2N1bWVudGAgaXMgdXNlZCB0byBnZXQgdGhlIGN1cnJlbnQgc2NyaXB0IFVSTCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYVxuLy8gXCJkdWFsXCIgZmlsZSBmb3IgZW50cmllcyBvZiBib3RoIHdlYndvcmtlciBhbmQgdGhlIGVzbSBtb2R1bGUuXG4vL1xuZGVjbGFyZSBnbG9iYWwge1xuICB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgPSB1bmtub3duO1xuICB0eXBlIEhUTUxTY3JpcHRFbGVtZW50ID0geyBzcmM/OiBzdHJpbmcgfTtcbiAgY29uc3QgZG9jdW1lbnQ6IHVuZGVmaW5lZCB8IHsgY3VycmVudFNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50IH07XG59XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqXG4gKiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGEgXCJkdWFsXCIgZmlsZSBmb3IgYm90aCBlbnRyaWVzIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFRoZSBwcm94eSB3b3JrZXIgaXRzZWxmLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciwgaXQgbGlzdGVucyB0byB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgbWFpbiB0aHJlYWQgYW5kIHBlcmZvcm1zIHRoZSBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIGRpcmVjdGx5IHVzaW5nIGBuZXcgV29ya2VyKClgIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAtIFRoZSBFU00gbW9kdWxlIHRoYXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIChhcyBhIHdvcmtlciBsYXVuY2hlcikuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyIGxhdW5jaGVyLCBpdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgYW5kIHJldHVybnMgaXQuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIHVzaW5nIGBpbXBvcnQoKWAgaW4gdGhlIG1haW4gdGhyZWFkLCB3aXRoIHRoZSBxdWVyeSBwYXJhbWV0ZXIgYGltcG9ydD0xYC5cbiAqXG4gKiBUaGlzIGZpbGUgd2lsbCBiZSBhbHdheXMgY29tcGlsaW5nIGludG8gRVNNIGZvcm1hdC5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21NZXNzYWdlLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSB9IGZyb20gJy4uL3Byb3h5LW1lc3NhZ2VzLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNlc3Npb24sXG4gIGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsXG4gIGVuZFByb2ZpbGluZyxcbiAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMsXG4gIGluaXRFcCxcbiAgaW5pdFJ1bnRpbWUsXG4gIHJlbGVhc2VTZXNzaW9uLFxuICBydW4sXG59IGZyb20gJy4uL3dhc20tY29yZS1pbXBsLmpzJztcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4uL3dhc20tZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuLi93YXNtLXV0aWxzLWltcG9ydC5qcyc7XG5cbmNvbnN0IFdPUktFUl9OQU1FID0gJ29ydC13YXNtLXByb3h5LXdvcmtlcic7XG5jb25zdCBpc1Byb3h5V29ya2VyID0gZ2xvYmFsVGhpcy5zZWxmPy5uYW1lID09PSBXT1JLRVJfTkFNRTtcblxuaWYgKGlzUHJveHlXb3JrZXIpIHtcbiAgLy8gV29ya2VyIHRocmVhZFxuICBzZWxmLm9ubWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgaW46IG1lc3NhZ2UgfSA9IGV2LmRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpbml0LXdhc20nOlxuICAgICAgICAgIGluaXRpYWxpemVXZWJBc3NlbWJseShtZXNzYWdlIS53YXNtKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXQtZXAnOiB7XG4gICAgICAgICAgY29uc3QgeyBlcE5hbWUsIGVudiB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgaW5pdEVwKGVudiwgZXBOYW1lKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb3B5LWZyb20nOiB7XG4gICAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBvdXQ6IGJ1ZmZlckRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgIGNvbnN0IHsgbW9kZWwsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpLnRoZW4oXG4gICAgICAgICAgICAoc2Vzc2lvbk1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWxlYXNlJzpcbiAgICAgICAgICByZWxlYXNlU2Vzc2lvbihtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydW4nOiB7XG4gICAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgbmV3IEFycmF5KG91dHB1dEluZGljZXMubGVuZ3RoKS5maWxsKG51bGwpLCBvcHRpb25zKS50aGVuKFxuICAgICAgICAgICAgKG91dHB1dHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc29tZSgobykgPT4gb1szXSAhPT0gJ2NwdScpKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnI6ICdQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLicgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICB7IHR5cGUsIG91dDogb3V0cHV0cyB9IGFzIE9ydFdhc21NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoWy4uLmlucHV0cywgLi4ub3V0cHV0c10gYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6XG4gICAgICAgICAgZW5kUHJvZmlsaW5nKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJveHlXb3JrZXJcbiAgPyBudWxsXG4gIDogKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PlxuICAgICAgbmV3IFdvcmtlcih1cmxPdmVycmlkZSA/PyBzY3JpcHRTcmMhLCB7IHR5cGU6IEJVSUxEX0RFRlMuSVNfRVNNID8gJ21vZHVsZScgOiAnY2xhc3NpYycsIG5hbWU6IFdPUktFUl9OQU1FIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdHlwZXMnO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5cbi8qKlxuICogVGhlIGNsYXNzaWMgc2NyaXB0IHNvdXJjZSBVUkwuIFRoaXMgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gbm9uIEVTTW9kdWxlIGVudmlyb25tZW50cy5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9XG4gIC8vIGlmIE5vZGVqcywgcmV0dXJuIHVuZGVmaW5lZFxuICBpc05vZGVcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogLy8gaWYgSXQncyBFU00sIHVzZSBpbXBvcnQubWV0YS51cmxcbiAgICAgIChCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwgPz9cbiAgICAgIC8vIHVzZSBgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNgIGlmIGF2YWlsYWJsZVxuICAgICAgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyY1xuICAgICAgICA6IC8vIHVzZSBgc2VsZi5sb2NhdGlvbi5ocmVmYCBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICA/IHNlbGYubG9jYXRpb24/LmhyZWZcbiAgICAgICAgICA6IHVuZGVmaW5lZCkpO1xuXG4vKipcbiAqIFRoZSBvcmlnaW4gb2YgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXG4gKi9cbmNvbnN0IG9yaWdpbiA9IGlzTm9kZSB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogbG9jYXRpb24ub3JpZ2luO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSB3aXRoIHByZWZpeCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAqL1xuY29uc3QgaXNTYW1lT3JpZ2luID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLm9yaWdpbiA9PT0gb3JpZ2luO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dHMgdG8gYW4gYWJzb2x1dGUgVVJMIHdpdGggdGhlIGdpdmVuIHByZWZpeCBvdmVycmlkZS4gSWYgZmFpbGVkLCByZXR1cm4gdW5kZWZpbmVkLlxuICovXG5jb25zdCBub3JtYWxpemVVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFsbGJhY2sgVVJMIGlmIGFuIGFic29sdXRlIFVSTCBjYW5ub3QgYmUgY3JlYXRlZCBieSB0aGUgbm9ybWFsaXplVXJsIGZ1bmN0aW9uLlxuICovXG5jb25zdCBmYWxsYmFja1VybCA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4gYCR7cHJlZml4T3ZlcnJpZGUgPz8gJy4vJ30ke2ZpbGVuYW1lfWA7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVsb2FkIGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogSWYgdGhlIG9yaWdpbiBvZiB0aGUgd29ya2VyIFVSTCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4sIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBkaXJlY3RseS5cbiAqIFNlZSBkaXNjdXNzaW9ucyBpbiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3dvcmtlci1sb2FkZXIvaXNzdWVzLzE1NFxuICpcbiAqIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBmZXRjaCB0aGUgd29ya2VyIFVSTCBhbmQgY3JlYXRlIGEgbmV3IEJsb2IgVVJMIHdpdGggdGhlIHNhbWUgb3JpZ2luIGFzIGEgd29ya2Fyb3VuZC5cbiAqXG4gKiBAcGFyYW0gYWJzb2x1dGVVcmwgLSBUaGUgYWJzb2x1dGUgVVJMIHRvIHByZWxvYWQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5ldyBCbG9iIFVSTFxuICovXG5jb25zdCBwcmVsb2FkID0gYXN5bmMgKGFic29sdXRlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlVXJsLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn07XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBkeW5hbWljYWxseSBpbXBvcnQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cbiAqXG4gKiBUaGUgYnVpbGQgc2NyaXB0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBVUkwgaXMgbm90IGJ1bmRsZWQgaW50byB0aGUgZmluYWwgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGltcG9ydC5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLlxuICovXG5jb25zdCBkeW5hbWljSW1wb3J0RGVmYXVsdCA9IGFzeW5jIDxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4gPT5cbiAgKGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIHVybCkpLmRlZmF1bHQ7XG5cbi8qKlxuICogVGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IGltcG9ydGVkIGZyb20gdGhlIHByb3h5IHdvcmtlciBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBXZWJBc3NlbWJseSBwcm94eSBpcyBub3QgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IGNyZWF0ZVByb3h5V29ya2VyOiAoKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PiBXb3JrZXIpIHwgdW5kZWZpbmVkID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgPyB1bmRlZmluZWQgOiByZXF1aXJlKCcuL3Byb3h5LXdvcmtlci9tYWluJykuZGVmYXVsdDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDIuIFVzZSB0aGUgcHJveHkgd29ya2VyIGZhY3RvcnkgdG8gY3JlYXRlIHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgcHJveHkgd29ya2VyLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0UHJveHlXb3JrZXIgPSBhc3luYyAoKTogUHJvbWlzZTxbdW5kZWZpbmVkIHwgc3RyaW5nLCBXb3JrZXJdPiA9PiB7XG4gIGlmICghc2NyaXB0U3JjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLicpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNjcmlwdCBzb3VyY2UgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiB1c2UgdGhlIGVtYmVkZGVkIHByb3h5IG1vZHVsZSBkaXJlY3RseS5cbiAgaWYgKGlzU2FtZU9yaWdpbihzY3JpcHRTcmMpKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGNyZWF0ZVByb3h5V29ya2VyISgpXTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBwcmVsb2FkXG4gIGNvbnN0IHVybCA9IGF3YWl0IHByZWxvYWQoc2NyaXB0U3JjKTtcbiAgcmV0dXJuIFt1cmwsIGNyZWF0ZVByb3h5V29ya2VyISh1cmwpXTtcbn07XG5cbi8qKlxuICogVGhlIGVtYmVkZGVkIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGluIEVTTSBhbmQgd2hlbiBlbWJlZGRpbmcgaXMgbm90IGRpc2FibGVkLlxuICovXG5jb25zdCBlbWJlZGRlZFdhc21Nb2R1bGU6IEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+IHwgdW5kZWZpbmVkID1cbiAgQlVJTERfREVGUy5JU19FU00gJiYgQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgcmVxdWlyZShcbiAgICAgICAgIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXG4gICAgICAgICAgPyAnLi4vLi4vZGlzdC9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzJ1xuICAgICAgICAgIDogJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnLFxuICAgICAgKS5kZWZhdWx0XG4gICAgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIEJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVCBpcyB0cnVlLCB1c2UgdGhlIGVtYmVkZGVkIG1vZHVsZS5cbiAqIDIuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAzLiBPdGhlcndpc2UsIGl0IHdpbGwgcGVyZm9ybSBhIGR5bmFtaWMgaW1wb3J0IG9mIHRoZSBtb2R1bGUuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZSwgd2hpY2ggaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0V2FzbU1vZHVsZSA9IGFzeW5jIChcbiAgdXJsT3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcHJlZml4T3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgaXNNdWx0aVRocmVhZGVkOiBib29sZWFuLFxuKTogUHJvbWlzZTxbdW5kZWZpbmVkIHwgc3RyaW5nLCBFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPl0+ID0+IHtcbiAgaWYgKEJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVCkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCBlbWJlZGRlZFdhc21Nb2R1bGUhXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXNtTW9kdWxlRmlsZW5hbWUgPSAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcbiAgICAgID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXG4gICAgICA6ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qcyc7XG4gICAgY29uc3Qgd2FzbU1vZHVsZVVybCA9IHVybE92ZXJyaWRlID8/IG5vcm1hbGl6ZVVybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKTtcbiAgICAvLyBuZWVkIHRvIHByZWxvYWQgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgIC8vIDEuIG5vdCBpbiBOb2RlLmpzLlxuICAgIC8vICAgIC0gTm9kZS5qcyBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIG9yaWdpbiBwb2xpY3kgZm9yIGNyZWF0aW5nIHdvcmtlcnMuXG4gICAgLy8gMi4gbXVsdGktdGhyZWFkZWQgaXMgZW5hYmxlZC5cbiAgICAvLyAgICAtIElmIG11bHRpLXRocmVhZGVkIGlzIGRpc2FibGVkLCBubyB3b3JrZXIgd2lsbCBiZSBjcmVhdGVkLiBTbyB3ZSBkb24ndCBuZWVkIHRvIHByZWxvYWQgdGhlIG1vZHVsZS5cbiAgICAvLyAzLiB0aGUgYWJzb2x1dGUgVVJMIGlzIGF2YWlsYWJsZS5cbiAgICAvLyAgICAtIElmIHRoZSBhYnNvbHV0ZSBVUkwgaXMgZmFpbGVkIHRvIGJlIGNyZWF0ZWQsIHRoZSBvcmlnaW4gY2Fubm90IGJlIGRldGVybWluZWQuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBub3RcbiAgICAvLyAgICBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gNC4gdGhlIHdvcmtlciBVUkwgaXMgbm90IGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICAgIC8vICAgIC0gSWYgdGhlIHdvcmtlciBVUkwgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBjcmVhdGUgdGhlIHdvcmtlciBkaXJlY3RseS5cbiAgICBjb25zdCBuZWVkUHJlbG9hZCA9ICFpc05vZGUgJiYgaXNNdWx0aVRocmVhZGVkICYmIHdhc21Nb2R1bGVVcmwgJiYgIWlzU2FtZU9yaWdpbih3YXNtTW9kdWxlVXJsLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgY29uc3QgdXJsID0gbmVlZFByZWxvYWRcbiAgICAgID8gYXdhaXQgcHJlbG9hZCh3YXNtTW9kdWxlVXJsKVxuICAgICAgOiAod2FzbU1vZHVsZVVybCA/PyBmYWxsYmFja1VybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKSk7XG4gICAgcmV0dXJuIFtuZWVkUHJlbG9hZCA/IHVybCA6IHVuZGVmaW5lZCwgYXdhaXQgZHluYW1pY0ltcG9ydERlZmF1bHQ8RW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4+KHVybCldO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdHlwZXMnO1xuaW1wb3J0IHsgaW1wb3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS11dGlscy1pbXBvcnQnO1xuXG5sZXQgd2FzbTogT3J0V2FzbU1vZHVsZSB8IHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuY29uc3QgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gSWYgJ1NoYXJlZEFycmF5QnVmZmVyJyBpcyBub3QgYXZhaWxhYmxlLCBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90IHdvcmsuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXG4gICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9tb3ppbGxhLmRldi5wbGF0Zm9ybS9JSGtCWmxIRVRwQS9kd3NNTmNoV0VRQUpcbiAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgdGhyZWFkZWQgaW5zdHJ1Y3Rpb25zLlxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgNSwgNCwgMSwgMywgMSwgMSwgMTAsIDExLCAxLCA5LCAwLCA2NSwgMCwgMjU0LCAxNixcbiAgICAgICAgMiwgMCwgMjYsIDExLFxuICAgICAgXSksXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgaXNTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyBTSU1EIGluc3RydWN0aW9ucy5cblxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XG4gICAgLy9cbiAgICAvLyAobW9kdWxlXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxuICAgIC8vICAgKGZ1bmMgJGYwICh0eXBlICR0MClcbiAgICAvLyAgICAgKGRyb3BcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcbiAgICAvLyAgICAgICAgIChpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgICAgICAoaTMyLmNvbnN0IDApKVxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXG5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDIsIDEsIDAsIDEwLCAzMCwgMSwgMjgsIDAsIDY1LCAwLCAyNTMsIDE1LCAyNTMsIDEyLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNTMsIDE4NiwgMSwgMjYsIDExLFxuICAgICAgXSksXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseSA9IGFzeW5jIChmbGFnczogRW52LldlYkFzc2VtYmx5RmxhZ3MpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAvLyB3YXNtIGZsYWdzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XG4gIGxldCBudW1UaHJlYWRzID0gZmxhZ3MubnVtVGhyZWFkcyE7XG5cbiAgLy8gZW5zdXJlIFNJTUQgaXMgc3VwcG9ydGVkXG4gIGlmICghaXNTaW1kU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG11bHRpLXRocmVhZGluZyBpcyBzdXBwb3J0ZWRcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XG4gIGlmIChudW1UaHJlYWRzID4gMSAmJiAhbXVsdGlUaHJlYWRTdXBwb3J0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byAnICtcbiAgICAgICAgICBudW1UaHJlYWRzICtcbiAgICAgICAgICAnLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gJyArXG4gICAgICAgICAgJ1NlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gJyArICdGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy4nLFxuICAgICk7XG5cbiAgICAvLyBzZXQgZmxhZ3MubnVtVGhyZWFkcyB0byAxIHNvIHRoYXQgT3J0SW5pdCgpIHdpbGwgbm90IGNyZWF0ZSBhIGdsb2JhbCB0aHJlYWQgcG9vbC5cbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XG4gIH1cblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lm1qcztcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy53YXNtO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlID0gKHdhc21QYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gd2FzbVBhdGhPdmVycmlkZUZsYWc7XG4gIGNvbnN0IHdhc21CaW5hcnlPdmVycmlkZSA9IGZsYWdzLndhc21CaW5hcnk7XG5cbiAgY29uc3QgW29iamVjdFVybCwgb3J0V2FzbUZhY3RvcnldID0gYXdhaXQgaW1wb3J0V2FzbU1vZHVsZShtanNQYXRoT3ZlcnJpZGUsIHdhc21QcmVmaXhPdmVycmlkZSwgbnVtVGhyZWFkcyA+IDEpO1xuXG4gIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcblxuICBjb25zdCB0YXNrczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBbXTtcblxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHRhc2tzLnB1c2goXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgLy8gcHJvbWlzZSBmb3IgbW9kdWxlIGluaXRpYWxpemF0aW9uXG4gIHRhc2tzLnB1c2goXG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiB0aHJlYWRzLiBXZWJBc3NlbWJseSB3aWxsIGNyZWF0ZSAoTW9kdWxlLm51bVRocmVhZHMgLSAxKSB3b3JrZXJzLiBJZiBpdCBpcyAxLCBubyB3b3JrZXIgd2lsbCBiZVxuICAgICAgICAgKiBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgbnVtVGhyZWFkcyxcbiAgICAgIH07XG5cbiAgICAgIGlmICh3YXNtQmluYXJ5T3ZlcnJpZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gVGhpcyB3aWxsIHNraXAgdGhlIHdhc20gZmlsZSBmZXRjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZy53YXNtQmluYXJ5ID0gd2FzbUJpbmFyeU92ZXJyaWRlO1xuICAgICAgfSBlbHNlIGlmICh3YXNtUGF0aE92ZXJyaWRlIHx8IHdhc21QcmVmaXhPdmVycmlkZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0byBsb2NhdGUgdGhlIFdlYkFzc2VtYmx5IGZpbGUuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpbmNlIEVtc2NyaXB0ZW4gMy4xLjU4LCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGZvciB0aGUgLndhc20gZmlsZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lLCBzY3JpcHREaXJlY3RvcnkpID0+XG4gICAgICAgICAgd2FzbVBhdGhPdmVycmlkZSA/PyAod2FzbVByZWZpeE92ZXJyaWRlID8/IHNjcmlwdERpcmVjdG9yeSkgKyBmaWxlTmFtZTtcbiAgICAgIH1cblxuICAgICAgb3J0V2FzbUZhY3RvcnkoY29uZmlnKS50aGVuKFxuICAgICAgICAvLyB3YXNtIG1vZHVsZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXNtID0gbW9kdWxlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyB3YXNtIG1vZHVsZSBmYWlsZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAod2hhdCkgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCh3aGF0KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSksXG4gICk7XG5cbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcblxuICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2UgPSAoKTogT3J0V2FzbU1vZHVsZSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiB3YXNtKSB7XG4gICAgcmV0dXJuIHdhc207XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmICFpbml0aWFsaXppbmcgJiYgIWFib3J0ZWQpIHtcbiAgICAvLyBUT0RPOiBjdXJyZW50bHkgXCJQVGhyZWFkLnRlcm1pbmF0ZUFsbFRocmVhZHMoKVwiIGlzIG5vdCBleHBvc2VkIGluIHRoZSB3YXNtIG1vZHVsZS5cbiAgICAvLyAgICAgICBBbmQgdGhpcyBmdW5jdGlvbiBpcyBub3QgeWV0IGNhbGxlZCBieSBhbnkgY29kZS5cbiAgICAvLyAgICAgICBJZiBpdCBpcyBuZWVkZWQgaW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIGV4cG9zZSBpdCBpbiB0aGUgd2FzbSBtb2R1bGUgYW5kIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUuXG5cbiAgICAvLyB3YXNtPy5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XG4gICAgd2FzbSA9IHVuZGVmaW5lZDtcblxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuXG5leHBvcnQgY29uc3QgYWxsb2NXYXNtU3RyaW5nID0gKGRhdGE6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IGRhdGFMZW5ndGggPSB3YXNtLmxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDE7XG4gIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MoZGF0YUxlbmd0aCk7XG4gIHdhc20uc3RyaW5nVG9VVEY4KGRhdGEsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuICBhbGxvY3MucHVzaChkYXRhT2Zmc2V0KTtcblxuICByZXR1cm4gZGF0YU9mZnNldDtcbn07XG5cbmludGVyZmFjZSBFeHRyYU9wdGlvbnNIYW5kbGVyIHtcbiAgKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBpdGVyYXRlRXh0cmFPcHRpb25zID0gKFxuICBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgcHJlZml4OiBzdHJpbmcsXG4gIHNlZW46IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+LFxuICBoYW5kbGVyOiBFeHRyYU9wdGlvbnNIYW5kbGVyLFxuKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgaWYgKHNlZW4uaGFzKG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZW4uYWRkKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyBrZXkgOiBrZXk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnModmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG5hbWUgKyAnLicsIHNlZW4sIGhhbmRsZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGhhbmRsZXIobmFtZSwgdmFsdWUgPyAnMScgOiAnMCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogY2hlY2sgd2ViIGFzc2VtYmx5IEFQSSdzIGxhc3QgZXJyb3IgYW5kIHRocm93IGVycm9yIGlmIGFueSBlcnJvciBvY2N1cnJlZC5cbiAqIEBwYXJhbSBtZXNzYWdlIGEgbWVzc2FnZSB1c2VkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0xhc3RFcnJvciA9IChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGNvbnN0IHBhcmFtc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg4KTtcbiAgICB3YXNtLl9PcnRHZXRMYXN0RXJyb3IocGFyYW1zT2Zmc2V0LCBwYXJhbXNPZmZzZXQgKyA0KTtcbiAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLkhFQVAzMltwYXJhbXNPZmZzZXQgLyA0XTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2VQb2ludGVyID0gd2FzbS5IRUFQVTMyW3BhcmFtc09mZnNldCAvIDQgKyAxXTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VQb2ludGVyID8gd2FzbS5VVEY4VG9TdHJpbmcoZXJyb3JNZXNzYWdlUG9pbnRlcikgOiAnJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX0gRVJST1JfQ09ERTogJHtlcnJvckNvZGV9LCBFUlJPUl9NRVNTQUdFOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuXG5leHBvcnQgY29uc3Qgc2V0UnVuT3B0aW9ucyA9IChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHJ1bk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgcnVuT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0cnkge1xuICAgIGlmIChvcHRpb25zPy5sb2dTZXZlcml0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA9IDI7IC8vIERlZmF1bHQgdG8gd2FybmluZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsICE9PSAnbnVtYmVyJyB8fFxuICAgICAgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dTZXZlcml0eUxldmVsKSB8fFxuICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fFxuICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID4gNFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1ZlcmJvc2l0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPSAwOyAvLyBEZWZhdWx0IHRvIDBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy50ZXJtaW5hdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy50ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGFnRGF0YU9mZnNldCA9IDA7XG4gICAgaWYgKG9wdGlvbnM/LnRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG9wdGlvbnMudGFnLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIHJ1bk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVSdW5PcHRpb25zKFxuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsISxcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhLFxuICAgICAgISFydW5PcHRpb25zLnRlcm1pbmF0ZSEsXG4gICAgICB0YWdEYXRhT2Zmc2V0LFxuICAgICk7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhvcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsdWUsIGFsbG9jcyk7XG5cbiAgICAgICAgaWYgKHdhc20uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHJ1bk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbcnVuT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmNvbnN0IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbCA9IChncmFwaE9wdGltaXphdGlvbkxldmVsOiBzdHJpbmcgfCB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHJldHVybiA5OTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7Z3JhcGhPcHRpbWl6YXRpb25MZXZlbH1gKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0RXhlY3V0aW9uTW9kZSA9IChleGVjdXRpb25Nb2RlOiAnc2VxdWVudGlhbCcgfCAncGFyYWxsZWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChleGVjdXRpb25Nb2RlKSB7XG4gICAgY2FzZSAnc2VxdWVudGlhbCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdwYXJhbGxlbCc6XG4gICAgICByZXR1cm4gMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtleGVjdXRpb25Nb2RlfWApO1xuICB9XG59O1xuXG5jb25zdCBhcHBlbmREZWZhdWx0T3B0aW9ucyA9IChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogdm9pZCA9PiB7XG4gIGlmICghb3B0aW9ucy5leHRyYSkge1xuICAgIG9wdGlvbnMuZXh0cmEgPSB7fTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZXh0cmEuc2Vzc2lvbikge1xuICAgIG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiA9IHt9O1xuICB9XG4gIGNvbnN0IHNlc3Npb24gPSBvcHRpb25zLmV4dHJhLnNlc3Npb24gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgaWYgKCFzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5ID0gJzEnO1xuICB9XG5cbiAgLy8gaWYgdXNpbmcgSlNFUCB3aXRoIFdlYkdQVSwgYWx3YXlzIGRpc2FibGUgbWVtb3J5IHBhdHRlcm5cbiAgaWYgKFxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzICYmXG4gICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMuc29tZSgoZXApID0+ICh0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lKSA9PT0gJ3dlYmdwdScpXG4gICkge1xuICAgIG9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybiA9IGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBzZXRFeGVjdXRpb25Qcm92aWRlcnMgPSAoXG4gIHNlc3Npb25PcHRpb25zSGFuZGxlOiBudW1iZXIsXG4gIGV4ZWN1dGlvblByb3ZpZGVyczogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5FeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdLFxuICBhbGxvY3M6IG51bWJlcltdLFxuKTogdm9pZCA9PiB7XG4gIGZvciAoY29uc3QgZXAgb2YgZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgbGV0IGVwTmFtZSA9IHR5cGVvZiBlcCA9PT0gJ3N0cmluZycgPyBlcCA6IGVwLm5hbWU7XG5cbiAgICAvLyBjaGVjayBFUCBuYW1lXG4gICAgc3dpdGNoIChlcE5hbWUpIHtcbiAgICAgIGNhc2UgJ3dlYm5uJzpcbiAgICAgICAgZXBOYW1lID0gJ1dFQk5OJztcbiAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCB3ZWJubk9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgLy8gY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgIGlmIChkZXZpY2VUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdkZXZpY2VUeXBlJywgYWxsb2NzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhkZXZpY2VUeXBlLCBhbGxvY3MpO1xuICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZGV2aWNlVHlwZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2ViZ3B1JzpcbiAgICAgICAgZXBOYW1lID0gJ0pTJztcbiAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCB3ZWJncHVPcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucz8ucHJlZmVycmVkTGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdwcmVmZXJyZWRMYXlvdXQnLCBhbGxvY3MpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0LCBhbGxvY3MpO1xuICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2FzbSc6XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xuICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihzZXNzaW9uT3B0aW9uc0hhbmRsZSwgZXBOYW1lRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX0uYCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0U2Vzc2lvbk9wdGlvbnMgPSAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgYXBwZW5kRGVmYXVsdE9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbChzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsID8/ICdhbGwnKTtcbiAgICBjb25zdCBleGVjdXRpb25Nb2RlID0gZ2V0RXhlY3V0aW9uTW9kZShzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlID8/ICdzZXF1ZW50aWFsJyk7XG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5sb2dJZCA9PT0gJ3N0cmluZycgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMubG9nSWQsIGFsbG9jcykgOiAwO1xuXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dTZXZlcml0eUxldmVsKSB8fCBsb2dTZXZlcml0eUxldmVsIDwgMCB8fCBsb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ1ZlcmJvc2l0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPz8gMDsgLy8gRGVmYXVsdCB0byAwIC0gdmVyYm9zZVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dWZXJib3NpdHlMZXZlbCkgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPCAwIHx8IGxvZ1ZlcmJvc2l0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoT2Zmc2V0ID1cbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLCBhbGxvY3MpXG4gICAgICAgIDogMDtcblxuICAgIHNlc3Npb25PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoXG4gICAgICBncmFwaE9wdGltaXphdGlvbkxldmVsLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybixcbiAgICAgIGV4ZWN1dGlvbk1vZGUsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZyxcbiAgICAgIDAsXG4gICAgICBsb2dJZERhdGFPZmZzZXQsXG4gICAgICBsb2dTZXZlcml0eUxldmVsLFxuICAgICAgbG9nVmVyYm9zaXR5TGV2ZWwsXG4gICAgICBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoT2Zmc2V0LFxuICAgICk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICAgIHNldEV4ZWN1dGlvblByb3ZpZGVycyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwgc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdlbmFibGVHcmFwaENhcHR1cmUnLCBhbGxvY3MpO1xuICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgaWYgKHdhc20uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcbiAgICAgICAgICBgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmV9LmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhuYW1lLCBhbGxvY3MpO1xuICAgICAgICBpZiAod2FzbS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHNlc3Npb25PcHRpb25zSGFuZGxlLCBuYW1lT2Zmc2V0LCB2YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7bmFtZX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHNlc3Npb25PcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsdWUsIGFsbG9jcyk7XG5cbiAgICAgICAgaWYgKHdhc20uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbi8vIGEgZHVtbXkgdHlwZSBkZWNsYXJhdGlvbiBmb3IgRmxvYXQxNkFycmF5IGluIGNhc2UgYW55IHBvbHlmaWxsIGlzIGF2YWlsYWJsZS5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBGbG9hdDE2QXJyYXk6IGFueTtcbn1cblxuLy8gVGhpcyBmaWxlIGluY2x1ZGVzIGNvbW1vbiBkZWZpbml0aW9ucy4gVGhleSBkbyBOT1QgaGF2ZSBkZXBlbmRlbmN5IG9uIHRoZSBXZWJBc3NlbWJseSBpbnN0YW5jZS5cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBPTk5YIGRlZmluaXRpb24uIFVzZSB0aGlzIHRvIGRyb3AgZGVwZW5kZW5jeSAnb25ueF9wcm90bycgdG8gZGVjcmVhc2UgY29tcGlsZWQgLmpzIGZpbGUgc2l6ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRGF0YVR5cGUge1xuICB1bmRlZmluZWQgPSAwLFxuICBmbG9hdCA9IDEsXG4gIHVpbnQ4ID0gMixcbiAgaW50OCA9IDMsXG4gIHVpbnQxNiA9IDQsXG4gIGludDE2ID0gNSxcbiAgaW50MzIgPSA2LFxuICBpbnQ2NCA9IDcsXG4gIHN0cmluZyA9IDgsXG4gIGJvb2wgPSA5LFxuICBmbG9hdDE2ID0gMTAsXG4gIGRvdWJsZSA9IDExLFxuICB1aW50MzIgPSAxMixcbiAgdWludDY0ID0gMTMsXG4gIGNvbXBsZXg2NCA9IDE0LFxuICBjb21wbGV4MTI4ID0gMTUsXG4gIGJmbG9hdDE2ID0gMTYsXG5cbiAgLy8gNC1iaXQgZGF0YS10eXBlc1xuICB1aW50NCA9IDIxLFxuICBpbnQ0ID0gMjIsXG59XG5cbi8qKlxuICogTWFwIHN0cmluZyB0ZW5zb3IgZGF0YSB0byBlbnVtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSA9ICh0eXBlOiBzdHJpbmcpOiBEYXRhVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDg7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ4O1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmJvb2w7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDE2O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDE2O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQzMjtcbiAgICBjYXNlICd1aW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQzMjtcbiAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDE2O1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmRvdWJsZTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnN0cmluZztcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50NjQ7XG4gICAgY2FzZSAndWludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NjQ7XG4gICAgY2FzZSAnaW50NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50NDtcbiAgICBjYXNlICd1aW50NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgZW51bSB2YWx1ZSB0byBzdHJpbmcgdGVuc29yIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nID0gKHR5cGVQcm90bzogRGF0YVR5cGUpOiBUZW5zb3IuVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZVByb3RvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ4OlxuICAgICAgcmV0dXJuICdpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ4OlxuICAgICAgcmV0dXJuICd1aW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS5ib29sOlxuICAgICAgcmV0dXJuICdib29sJztcbiAgICBjYXNlIERhdGFUeXBlLmludDE2OlxuICAgICAgcmV0dXJuICdpbnQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MTY6XG4gICAgICByZXR1cm4gJ3VpbnQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgcmV0dXJuICd1aW50MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIHJldHVybiAnZmxvYXQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5kb3VibGU6XG4gICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUuc3RyaW5nOlxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NjQ6XG4gICAgICByZXR1cm4gJ2ludDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcbiAgICAgIHJldHVybiAndWludDY0JztcbiAgICBjYXNlIERhdGFUeXBlLmludDQ6XG4gICAgICByZXR1cm4gJ2ludDQnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDQ6XG4gICAgICByZXR1cm4gJ3VpbnQ0JztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlUHJvdG99YCk7XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IHRlbnNvciBzaXplIGluIGJ5dGVzIGJ5IHRoZSBnaXZlbiBkYXRhIHR5cGUgYW5kIGRpbWVuc2lvbnNcbiAqIEByZXR1cm5zIHNpemUgaW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyA9IChcbiAgZGF0ZVR5cGU6IG51bWJlcixcbiAgZGltc09yU2l6ZTogcmVhZG9ubHkgbnVtYmVyW10gfCBudW1iZXIsXG4pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBlbGVtZW50U2l6ZSA9IFtcbiAgICAtMSwgLy8gdW5kZWZpbmVkID0gMFxuICAgIDQsIC8vIGZsb2F0ID0gMVxuICAgIDEsIC8vIHVpbnQ4ID0gMlxuICAgIDEsIC8vIGludDggPSAzXG4gICAgMiwgLy8gdWludDE2ID0gNFxuICAgIDIsIC8vIGludDE2ID0gNVxuICAgIDQsIC8vIGludDMyID0gNlxuICAgIDgsIC8vIGludDY0ID0gN1xuICAgIC0xLCAvLyBzdHJpbmcgPSA4XG4gICAgMSwgLy8gYm9vbCA9IDlcbiAgICAyLCAvLyBmbG9hdDE2ID0gMTBcbiAgICA4LCAvLyBkb3VibGUgPSAxMVxuICAgIDQsIC8vIHVpbnQzMiA9IDEyXG4gICAgOCwgLy8gdWludDY0ID0gMTNcbiAgICAtMSwgLy8gY29tcGxleDY0ID0gMTRcbiAgICAtMSwgLy8gY29tcGxleDEyOCA9IDE1XG4gICAgLTEsIC8vIGJmbG9hdDE2ID0gMTZcbiAgICAtMSwgLy8gRkxPQVQ4RTRNM0ZOID0gMTdcbiAgICAtMSwgLy8gRkxPQVQ4RTRNM0ZOVVogPSAxOFxuICAgIC0xLCAvLyBGTE9BVDhFNU0yID0gMTlcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMkZOVVogPSAyMFxuICAgIDAuNSwgLy8gdWludDQgPSAyMVxuICAgIDAuNSwgLy8gaW50NCA9IDIyXG4gIF1bZGF0ZVR5cGVdO1xuXG4gIGNvbnN0IHNpemUgPSB0eXBlb2YgZGltc09yU2l6ZSA9PT0gJ251bWJlcicgPyBkaW1zT3JTaXplIDogZGltc09yU2l6ZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcbiAgcmV0dXJuIGVsZW1lbnRTaXplID4gMCA/IE1hdGguY2VpbChzaXplICogZWxlbWVudFNpemUpIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBnZXQgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IgYnkgdGhlIGdpdmVuIHRlbnNvciB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgPSAoXG4gIHR5cGU6IFRlbnNvci5UeXBlLFxuKTpcbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgIC8vIGFsbG93IEZsb2F0MTZBcnJheSBwb2x5ZmlsbC5cbiAgICAgIHJldHVybiB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBGbG9hdDE2QXJyYXkuZnJvbSA/IEZsb2F0MTZBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBjYXNlICd1aW50MzInOlxuICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgIHJldHVybiBCaWdJbnQ2NEFycmF5O1xuICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgbG9nIGxldmVsIHRvIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0gKGxvZ0xldmVsPzogJ3ZlcmJvc2UnIHwgJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJyB8ICdmYXRhbCcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdpbmZvJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZmF0YWwnOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtsb2dMZXZlbH1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0+XG4gIHR5cGUgPT09ICdmbG9hdDMyJyB8fFxuICB0eXBlID09PSAnZmxvYXQxNicgfHxcbiAgdHlwZSA9PT0gJ2ludDMyJyB8fFxuICB0eXBlID09PSAnaW50NjQnIHx8XG4gIHR5cGUgPT09ICd1aW50MzInIHx8XG4gIHR5cGUgPT09ICd1aW50OCcgfHxcbiAgdHlwZSA9PT0gJ2Jvb2wnIHx8XG4gIHR5cGUgPT09ICd1aW50NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDQnO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRlbnNvciB0eXBlIGlzIHN1cHBvcnRlZCBieSBXZWJOTiBNTFRlbnNvclxuICovXG5leHBvcnQgY29uc3QgaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUgPSAodHlwZTogVGVuc29yLlR5cGUpOiB0eXBlIGlzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcyA9PlxuICB0eXBlID09PSAnZmxvYXQzMicgfHxcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XG4gIHR5cGUgPT09ICdpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ2ludDY0JyB8fFxuICB0eXBlID09PSAndWludDMyJyB8fFxuICB0eXBlID09PSAndWludDY0JyB8fFxuICB0eXBlID09PSAnaW50OCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICB0eXBlID09PSAnYm9vbCc7XG5cbi8qKlxuICogTWFwIHN0cmluZyBkYXRhIGxvY2F0aW9uIHRvIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSA9IChsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICBjYXNlICdub25lJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIDU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtsb2NhdGlvbn1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgaW50ZWdlciBkYXRhIGxvY2F0aW9uIHRvIHN0cmluZyB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uRW51bVRvU3RyaW5nID0gKGxvY2F0aW9uOiBudW1iZXIpOiBUZW5zb3IuRGF0YUxvY2F0aW9uIHwgdW5kZWZpbmVkID0+XG4gIChbJ25vbmUnLCAnY3B1JywgJ2NwdS1waW5uZWQnLCAndGV4dHVyZScsICdncHUtYnVmZmVyJywgJ21sLXRlbnNvciddIGFzIGNvbnN0KVtsb2NhdGlvbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuXG4vKipcbiAqIExvYWQgYSBmaWxlIGludG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBmaWxlIC0gdGhlIGZpbGUgdG8gbG9hZC4gQ2FuIGJlIGEgVVJML3BhdGgsIGEgQmxvYiwgYW4gQXJyYXlCdWZmZXIsIG9yIGEgVWludDhBcnJheS5cbiAqIEByZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBmaWxlIGRhdGEuXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZSA9IGFzeW5jIChmaWxlOiBzdHJpbmcgfCBCbG9iIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSk6IFByb21pc2U8VWludDhBcnJheT4gPT4ge1xuICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gTm9kZS5qc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByZWFkRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVhZEZpbGUoZmlsZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlID09PSAnRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFJykge1xuICAgICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2UgZnMuY3JlYXRlUmVhZFN0cmVhbSBpbnN0ZWFkXG4gICAgICAgICAgY29uc3QgeyBjcmVhdGVSZWFkU3RyZWFtIH0gPSByZXF1aXJlKCdub2RlOmZzJyk7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShmaWxlKTtcbiAgICAgICAgICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KGNodW5rcykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIGJyb3dzZXJzXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGUpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICAgICAgY29uc3QgZmlsZVNpemUgPSBjb250ZW50TGVuZ3RoSGVhZGVyID8gcGFyc2VJbnQoY29udGVudExlbmd0aEhlYWRlciwgMTApIDogMDtcbiAgICAgIGlmIChmaWxlU2l6ZSA8IDEwNzM3NDE4MjQgLyogMUdCICovKSB7XG4gICAgICAgIC8vIHdoZW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGlzIG5vdCBzZXQsIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGZpbGUgc2l6ZS4gV2UgYXNzdW1lIGl0IGlzIHNtYWxsIGVub3VnaCB0b1xuICAgICAgICAvLyBsb2FkIGludG8gbWVtb3J5LlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIHN0cmVhbSBpbnN0ZWFkXG4gICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9LCBubyByZXNwb25zZSBib2R5LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB0cnkgdG8gY3JlYXRlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGZpbGVTaXplKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgLy8gdXNlIFdlYkFzc2VtYmx5IE1lbW9yeSB0byBhbGxvY2F0ZSBsYXJnZXIgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gTWF0aC5jZWlsKGZpbGVTaXplIC8gNjU1MzYpO1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IHBhZ2VzLCBtYXhpbXVtOiBwYWdlcyB9KS5idWZmZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgICAgIGNodW5rLnNldCh2YWx1ZSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCBmaWxlU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZmlsZSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGxvZ0xldmVsU3RyaW5nVG9FbnVtIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG50eXBlIExvZ0xldmVsID0gTm9uTnVsbGFibGU8RW52Wydsb2dMZXZlbCddPjtcbnR5cGUgTWVzc2FnZVN0cmluZyA9IHN0cmluZztcbnR5cGUgTWVzc2FnZUZ1bmN0aW9uID0gKCkgPT4gc3RyaW5nO1xudHlwZSBNZXNzYWdlID0gTWVzc2FnZVN0cmluZyB8IE1lc3NhZ2VGdW5jdGlvbjtcblxuY29uc3QgbG9nTGV2ZWxQcmVmaXggPSBbJ1YnLCAnSScsICdXJywgJ0UnLCAnRiddO1xuXG5jb25zdCBkb0xvZyA9IChsZXZlbDogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coYFske2xvZ0xldmVsUHJlZml4W2xldmVsXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7bWVzc2FnZX1gKTtcbn07XG5cbmxldCBjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwgfCB1bmRlZmluZWQ7XG5sZXQgZGVidWc6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBjb25zdCBjb25maWd1cmVMb2dnZXIgPSAoJGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCwgJGRlYnVnOiBib29sZWFuKTogdm9pZCA9PiB7XG4gIGNvbmZpZ0xvZ0xldmVsID0gJGNvbmZpZ0xvZ0xldmVsO1xuICBkZWJ1ZyA9ICRkZWJ1Zztcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNvbnN0IExPRyA9IChsb2dMZXZlbDogTG9nTGV2ZWwsIG1zZzogTWVzc2FnZSk6IHZvaWQgPT4ge1xuICBjb25zdCBtZXNzYWdlTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShsb2dMZXZlbCk7XG4gIGNvbnN0IGNvbmZpZ0xldmVsID0gbG9nTGV2ZWxTdHJpbmdUb0VudW0oY29uZmlnTG9nTGV2ZWwpO1xuICBpZiAobWVzc2FnZUxldmVsID49IGNvbmZpZ0xldmVsKSB7XG4gICAgZG9Mb2cobWVzc2FnZUxldmVsLCB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2cpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGxvZ2dpbmcgdXRpbGl0eSB0byBsb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuIE9ubHkgbG9ncyB3aGVuIGRlYnVnIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0dfREVCVUc6IHR5cGVvZiBMT0cgPSAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgTE9HPikgPT4ge1xuICBpZiAoZGVidWcpIHtcbiAgICBMT0coLi4uYXJncyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoXG4gIGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLFxuICB0eXBlOiBUZW5zb3IuVHlwZSxcbik6XG4gIHwgSW50MzJBcnJheVxuICB8IFVpbnQzMkFycmF5XG4gIHwgQmlnSW50NjRBcnJheVxuICB8IEJpZ1VpbnQ2NEFycmF5XG4gIHwgVWludDhBcnJheVxuICB8IEZsb2F0MzJBcnJheVxuICB8IEZsb2F0NjRBcnJheVxuICB8IEludDhBcnJheVxuICB8IEludDE2QXJyYXlcbiAgfCBVaW50MTZBcnJheSA9PiBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG5cbi8qKlxuICogYSBUZW5zb3JWaWV3IGRvZXMgbm90IG93biB0aGUgZGF0YS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcbiAgcmVhZG9ubHkgZGF0YTogbnVtYmVyO1xuICByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyO1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcblxuICAvKipcbiAgICogZ2V0IGEgRmxvYXQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEZsb2F0MzJBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEJpZ0ludDY0QXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEludDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRJbnQzMkFycmF5KCk6IEludDMyQXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIFVpbnQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXk7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIG5ldyB0ZW5zb3IgdmlldyB3aXRoIHRoZSBzYW1lIGRhdGEgYnV0IGRpZmZlcmVudCBkaW1lbnNpb25zLlxuICAgKi9cbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXc7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uL3RlbnNvci12aWV3JztcblxuaW1wb3J0IHsgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcblxuZXhwb3J0IHR5cGUgU2Vzc2lvblN0YXRlID0gJ2RlZmF1bHQnIHwgJ2NhcHR1cmluZycgfCAncmVwbGF5aW5nJztcblxuZXhwb3J0IGVudW0gR3B1RGF0YVR5cGUge1xuICBkZWZhdWx0ID0gMCxcbiAgdXBsb2FkID0gMSxcbiAgcHJvZmlsZSA9IDIsXG59XG5leHBvcnQgdHlwZSBHcHVEYXRhSWQgPSBudW1iZXI7XG5cbmV4cG9ydCB0eXBlIEdwdUFyY2hpdGVjdHVyZSA9ICdhbXBlcmUnIHwgJ2dlbi0xMmxwJztcbmV4cG9ydCB0eXBlIEdwdVZlbmRvciA9ICdhbWQnIHwgJ2ludGVsJyB8ICdudmlkaWEnO1xuZXhwb3J0IGludGVyZmFjZSBBZGFwdGVySW5mbyB7XG4gIGlzQXJjaGl0ZWN0dXJlOiAoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpID0+IGJvb2xlYW47XG4gIGlzVmVuZG9yOiAodmVuZG9yOiBHcHVWZW5kb3IpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YSB7XG4gIHR5cGU6IEdwdURhdGFUeXBlO1xuICBpZDogR3B1RGF0YUlkO1xuICBidWZmZXI6IEdQVUJ1ZmZlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JJbmZvIHtcbiAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIGRhdGFUeXBlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVVuaWZvcm0ge1xuICB0eXBlOiBEYXRhVHlwZTtcbiAgZGF0YTogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCB0eXBlIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvID0gW3R5cGU6IERhdGFUeXBlLCBsZW5ndGg6IG51bWJlcl07XG5cbi8qKlxuICogUmVwcmVzZW50IHRoZSBkZXBlbmRlbmN5IG9mIGEgcHJvZ3JhbSBvbiBhIHNwZWNpZmljIGlucHV0IHRlbnNvci5cbiAqXG4gKiAtICdub25lJzogdGhlIHNoYWRlci91bmlmb3JtIGRvZXMgbm90IGRlcGVuZCBvbiB0aGlzIGlucHV0J3MgaW5mb1xuICogLSAndHlwZSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBvZiB0aGlzIGlucHV0XG4gKiAtICdyYW5rJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgcmFuayBvZiB0aGlzIGlucHV0XG4gKiAtICdkaW1zJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgZGltcyBvZiB0aGlzIGlucHV0XG4gKiAtICdkYXRhJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlLCB0aGUgZGltcyBhbmQgdGhlIGRhdGEgb2YgdGhpcyBpbnB1dFxuICovXG5leHBvcnQgdHlwZSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSA9ICdub25lJyB8ICd0eXBlJyB8ICdyYW5rJyB8ICdkaW1zJyB8ICdkYXRhJztcblxuLyoqXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHNoYWRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgaW5pdGlhbGl6aW5nLXRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGF0dHJpYnV0ZXMgb3IgYW55IGluZm9ybWF0aW9uIG9mXG4gICAqIGluaXRpYWxpemVycy4gSXQgc2hvdWxkIE5PVCBjb250YWluIGFueSBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdkaW1zJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3IgdW5pZm9ybS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybUNhY2hlSW5mbyB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSB1bmlmb3JtIGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxuICAgKi9cbiAgaGludD86IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xuICAgKiBvbiAnbm9uZScgb2YgYWxsIGlucHV0cy5cbiAgICovXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBkYXRhIHRoYXQgcmVwcmVzZW50IGEgc2hhZGVyIHByb2dyYW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mbyB7XG4gIC8qKlxuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvZ3JhbS4gdXNlZCBmb3IgZGVidWdnaW5nIGFuZCBwcm9maWxpbmdcbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNhY2hlIGluZm9ybWF0aW9uIG9mIHRoZSBwcm9ncmFtIHNoYWRlci5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgaGludCBpcyBlbXB0eSBhbmQgaW5wdXREZXBlbmRlbmNpZXMgYXJlIFsnZGltcyddIGZvciBhbGwgaW5wdXRzLlxuICAgKi9cbiAgc2hhZGVyQ2FjaGU/OiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvO1xuXG4gIC8qKlxuICAgKiB0aGUgc2hhZGVyJ3MgcHJvY2Vzc2luZyBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHNoYWRlciBjYWNoZSBtaXNzZWQuXG4gICAqL1xuICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGdldCBydW4gZGF0YSByZXF1aXJlZCB0byBydW4gdGhlIHByb2dyYW0uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvZ3JhbSBpcyBleGVjdXRlZC4gU2hvdWxkIGtlZXAgdGhpcyBmdW5jdGlvbiBhcyBzaW1wbGUgYXMgcG9zc2libGUuXG4gICAqL1xuICBnZXRSdW5EYXRhOiAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pID0+IHtcbiAgICBvdXRwdXRzOiByZWFkb25seSBUZW5zb3JJbmZvW107XG4gICAgZGlzcGF0Y2hHcm91cDogeyB4OiBudW1iZXI7IHk/OiBudW1iZXI7IHo/OiBudW1iZXIgfTtcbiAgICBwcm9ncmFtVW5pZm9ybXM/OiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVtdO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0IHtcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xuICBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgdW5pZm9ybVZhcmlhYmxlc0luZm86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyB7XG4gIC8qKlxuICAgKiBzcGVjaWZ5IHRoZSBtYXBwaW5nIHRvIHRoZSBwcm9ncmFtJ3MgaW5wdXRzLiB0aGUgdmFsdWUgY2FuIGJlIGEgbnVtYmVyIG9yIGEgdGVuc29yIHZpZXcuXG4gICAqIC0gaWYgaXQncyBhIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIGlucHV0XG4gICAqIC0gaWYgaXQncyBhIHRlbnNvciB2aWV3LCBpdCdzIGFuIGV4aXN0aW5nIHRlbnNvciB2aWV3IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbnB1dFxuICAgKlxuICAgKiBpZiBpbnB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3MgaW5wdXRzIGluIG9yZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRzPzogUmVhZG9ubHlBcnJheTxUZW5zb3JWaWV3IHwgbnVtYmVyPjtcbiAgLyoqXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBvdXRwdXRzLiB0aGUgdmFsdWUgbXVzdCBiZSBhIG51bWJlci5cbiAgICogLSBpZiBpdCdzIGEgbm9uLW5lZ2F0aXZlIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIG91dHB1dFxuICAgKiAtIGlmIGl0J3MgLTEsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgdGVtcG9yYXJ5IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgYWZ0ZXJcbiAgICogdGhlIGtlcm5lbCBpcyBleGVjdXRlZC5cbiAgICogLSBpZiBpdCdzIC0yLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHBlcnNpc3RlbnQgdmFsdWUuIHRoaXMgdmFsdWUgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZVxuICAgKiBrZXJuZWwgaXMgcmVsZWFzZWQuXG4gICAqXG4gICAqIGlmIG91dHB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3Mgb3V0cHV0cyBpbiBvcmRlci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dHM/OiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBBIENvbXB1dGVDb250ZXh0IGluc3RhbmNlIGNhcnJpZXMgdGhlIHN0YXRlcyB0aGF0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBydW5uaW5nIG9mIGEga2VybmVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0IHtcbiAgLyoqXG4gICAqIGdwdSBhZGFwdGVyIGluZm9cbiAgICovXG4gIHJlYWRvbmx5IGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mbztcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBwb2ludGVyIHRvIE9wS2VybmVsQ29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGEgbGlzdCBvZiBpbnB1dHMsIGVhY2ggaW5wdXQgaXMgYW4gaW5zdGFuY2Ugb2YgVGVuc29yVmlld1xuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG5cbiAgLyoqXG4gICAqIGEgY3VzdG9tIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYW55IGRhdGEgdGhhdCBpcyBuZWVkZWQgYnkgdGhlIGtlcm5lbFxuICAgKi9cbiAgcmVhZG9ubHkga2VybmVsQ3VzdG9tRGF0YTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH07XG5cbiAgLyoqXG4gICAqIGEgYnVmZmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGN1c3RvbSBkYXRhIGNyZWF0ZWQgZWFjaCB0aW1lIHRoZSBrZXJuZWwgaXMgZXhlY3V0ZWRcbiAgICovXG4gIHJlYWRvbmx5IGN1c3RvbURhdGFCdWZmZXI6IFVpbnQ4QXJyYXk7XG5cbiAgLyoqXG4gICAqIGEgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoZSBub2RlXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuXG4gIGNvbXB1dGUocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0c091dHB1dHNNYXBwaW5nPzogQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyk6IFRlbnNvclZpZXdbXTtcbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZXNpemUoKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBUaW1lc3RhbXBRdWVyeSA9ICdub25lJyB8ICdpbnNpZGUtcGFzc2VzJyB8ICdhdC1wYXNzZXMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHsgR3B1RGF0YSwgR3B1RGF0YUlkLCBHcHVEYXRhVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIG1hbmFnZXMgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGFNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIGNvcHkgZGF0YSBmcm9tIENQVSB0byBHUFUuXG4gICAqL1xuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gR1BVLlxuICAgKi9cbiAgbWVtY3B5KHNvdXJjZUlkOiBHcHVEYXRhSWQsIGRlc3RpbmF0aW9uSWQ6IEdwdURhdGFJZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBjcmVhdGUgbmV3IGRhdGEgb24gR1BVLlxuICAgKi9cbiAgY3JlYXRlKHNpemU6IG51bWJlciwgdXNhZ2U/OiBudW1iZXIpOiBHcHVEYXRhO1xuICAvKipcbiAgICogZ2V0IEdQVSBkYXRhIGJ5IElELlxuICAgKi9cbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUgYnkgSUQuXG4gICAqXG4gICAqIEByZXR1cm4gc2l6ZSBvZiB0aGUgZGF0YSByZWxlYXNlZFxuICAgKi9cbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIGRvd25sb2FkKGlkOiBHcHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIHJlZnJlc2ggdGhlIGJ1ZmZlcnMgdGhhdCBtYXJrZWQgZm9yIHJlbGVhc2UuXG4gICAqXG4gICAqIHdoZW4gcmVsZWFzZSgpIGlzIGNhbGxlZCwgdGhlIGJ1ZmZlciBpcyBub3QgcmVsZWFzZWQgaW1tZWRpYXRlbHkuIHRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21tYW5kc1xuICAgKiB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIEdQVS4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbW1hbmRzIGFyZSBzdWJtaXR0ZWQgc28gdGhhdCB0aGUgYnVmZmVycyBjYW4gYmVcbiAgICogYWN0dWFsbHkgcmVsZWFzZWQuXG4gICAqL1xuICByZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTogdm9pZDtcblxuICAvKipcbiAgICogcmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLiBJZiB0aGUgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCwgcmV0dXJuIHRoZSBleGlzdGluZyBHUFUgZGF0YSBJRC5cbiAgICpcbiAgICogR1BVIGRhdGEgbWFuYWdlciBvbmx5IG1hbmFnZXMgYSBtYXBwaW5nIGJldHdlZW4gdGhlIGJ1ZmZlciBhbmQgdGhlIEdQVSBkYXRhIElELiBJdCB3aWxsIG5vdCBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZlxuICAgKiB0aGUgZXh0ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzPzogW0dwdURhdGFJZCwgR1BVQnVmZmVyXSk6IG51bWJlcjtcblxuICAvKipcbiAgICogdW5yZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuXG4gICAqL1xuICB1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoaWQ6IEdwdURhdGFJZCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGRlc3Ryb3kgYWxsIGdwdSBidWZmZXJzLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgc2Vzc2lvbiByZWxhdGVkIGRhdGEuXG4gICAqL1xuICBvbkNyZWF0ZVNlc3Npb24oKTogdm9pZDtcblxuICAvKipcbiAgICogcmVsZWFzZSBzZXNzaW9uIHJlbGF0ZWQgZGF0YS5cbiAgICogQHBhcmFtIHNlc3Npb25JZCAtIHNwZWNpZnkgdGhlIHNlc3Npb24gSUQuXG4gICAqL1xuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIFN0b3JhZ2VDYWNoZVZhbHVlIHtcbiAgZ3B1RGF0YTogR3B1RGF0YTtcbiAgb3JpZ2luYWxTaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IGJ1Y2tldEZyZWVsaXN0OiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbmV3IE1hcChbXG4gIFs2NCwgMjUwXSxcbiAgWzEyOCwgMjAwXSxcbiAgWzI1NiwgMjAwXSxcbiAgWzUxMiwgMjAwXSxcbiAgWzIwNDgsIDIzMF0sXG4gIFs0MDk2LCAyMDBdLFxuICBbODE5MiwgNTBdLFxuICBbMTYzODQsIDUwXSxcbiAgWzMyNzY4LCA1MF0sXG4gIFs2NTUzNiwgNTBdLFxuICBbMTMxMDcyLCA1MF0sXG4gIFsyNjIxNDQsIDUwXSxcbiAgWzUyNDI4OCwgNTBdLFxuICBbMTA0ODU3NiwgNTBdLFxuICBbMjA5NzE1MiwgMzBdLFxuICBbNDE5NDMwNCwgMjBdLFxuICBbODM4ODYwOCwgMTBdLFxuICBbMTI1ODI5MTIsIDEwXSxcbiAgWzE2Nzc3MjE2LCAxMF0sXG4gIFsyNjIxNDQwMCwgMTVdLFxuICBbMzM1NTQ0MzIsIDIyXSxcbiAgWzQ0MjM2ODAwLCAyXSxcbiAgWzU4OTgyNDAwLCA2XSxcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSB0aGUgYnVja2V0IHNpemVzIGJlbG93IGJ1dCBub3QgY2FjaGluZyB0aGVtXG4gIC8vIHJlc3VsdHMgaW4gc29tZSBtYWpvciBwZXJmb3JtYW5jZSBoaXRzIGZvciBtb2RlbHMgbGlrZSBzZC10dXJiby5cbiAgWzY3MTA4ODY0LCA2XSxcbiAgWzEzNDIxNzcyOCwgNl0sXG4gIFsxNjc3NzIxNjAsIDZdLFxuXSk7XG5cbmNvbnN0IGJ1Y2tldEFycjogbnVtYmVyW10gPSBbXTtcblxuLyoqXG4gKiBub3JtYWxpemUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyB0aGUgMTI4LWJpdHMgKDE2IGJ5dGVzKSBhbGlnbm1lbnQuXG4gKi9cbmNvbnN0IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IE1hdGguY2VpbChzaXplIC8gMTYpICogMTY7XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBidWZmZXIgc2l6ZSBzbyB0aGF0IGl0IGZpdHMgaW50byBidWNrZXRzLlxuICovXG5jb25zdCBjYWxjQnVja2V0QnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYnVja2V0QXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBzaXplRm9yQnVja2V0ID0gYnVja2V0QXJyW2lkeF07XG4gICAgaWYgKHNpemUgPD0gc2l6ZUZvckJ1Y2tldCkge1xuICAgICAgcmV0dXJuIHNpemVGb3JCdWNrZXQ7XG4gICAgfVxuICB9XG4gIC8vIG5vdCBpbiBidWNrZXQgbGlzdCAtPiBjYWxsZXIgd2lsbCBub3QgY2FjaGUsIHJvdW5kIHVwIHRvIDE2LlxuICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyAxNikgKiAxNjtcbn07XG5cbmxldCBndWlkID0gMTtcbmNvbnN0IGNyZWF0ZU5ld0dwdURhdGFJZCA9ICgpID0+IGd1aWQrKztcblxuLyoqXG4gKiBleHBvcnRlZCBzdGFuZGFyZCBkb3dubG9hZCBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBzZXNzaW9uIHRvIGRvd25sb2FkIHRoZSBkYXRhIGZyb20gR1BVLCBhbmQgYWxzbyBieVxuICogZmFjdG9yeSB0byBjcmVhdGUgR1BVIHRlbnNvcnMgd2l0aCB0aGUgY2FwYWNpdHkgb2YgZG93bmxvYWRpbmcgZGF0YSBmcm9tIEdQVS5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBXZWJHUFUgYmFja2VuZFxuICogQHBhcmFtIGdwdUJ1ZmZlciAtIHRoZSBHUFUgYnVmZmVyIHRvIGRvd25sb2FkXG4gKiBAcGFyYW0gb3JpZ2luYWxTaXplIC0gdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGRhdGFcbiAqIEBwYXJhbSBnZXRUYXJnZXRCdWZmZXIgLSBvcHRpb25hbC4gSWYgcHJvdmlkZWQsIHRoZSBkYXRhIHdpbGwgYmUgY29waWVkIHRvIHRoZSB0YXJnZXQgYnVmZmVyLiBPdGhlcndpc2UsIGEgbmV3IGJ1ZmZlclxuICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvd25sb2FkR3B1RGF0YSA9IGFzeW5jIChcbiAgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcbiAgZ3B1QnVmZmVyOiBHUFVCdWZmZXIsXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyLFxuICBnZXRUYXJnZXRCdWZmZXI/OiAoKSA9PiBVaW50OEFycmF5LFxuKTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUob3JpZ2luYWxTaXplKTtcbiAgY29uc3QgZ3B1UmVhZEJ1ZmZlciA9IGJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfSxcbiAgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IGJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICBiYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgZ3B1QnVmZmVyIC8qIHNvdXJjZSBidWZmZXIgKi8sXG4gICAgICAwIC8qIHNvdXJjZSBvZmZzZXQgKi8sXG4gICAgICBncHVSZWFkQnVmZmVyIC8qIGRlc3RpbmF0aW9uIGJ1ZmZlciAqLyxcbiAgICAgIDAgLyogZGVzdGluYXRpb24gb2Zmc2V0ICovLFxuICAgICAgYnVmZmVyU2l6ZSAvKiBzaXplICovLFxuICAgICk7XG4gICAgYmFja2VuZC5mbHVzaCgpO1xuXG4gICAgYXdhaXQgZ3B1UmVhZEJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO1xuXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgaWYgKGdldFRhcmdldEJ1ZmZlcikge1xuICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgQ1BVIGJ1ZmZlciB0byBhY2NlcHQgdGhlIGRhdGEsIG5vIG5lZWQgdG8gY2xvbmUgdGhlIEFycmF5QnVmZmVyLlxuICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyID0gZ2V0VGFyZ2V0QnVmZmVyKCk7XG4gICAgICB0YXJnZXRCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCAwLCBvcmlnaW5hbFNpemUpKTtcbiAgICAgIHJldHVybiB0YXJnZXRCdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBtYXBwZWQgQXJyYXlCdWZmZXIgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZSBHUFUgYnVmZmVyIGlzIGRlc3Ryb3llZC4gTmVlZCB0byBjbG9uZSB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyLlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLnNsaWNlKDAsIG9yaWdpbmFsU2l6ZSkpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBncHVSZWFkQnVmZmVyLmRlc3Ryb3koKTtcbiAgfVxufTtcblxuY2xhc3MgR3B1RGF0YU1hbmFnZXJJbXBsIGltcGxlbWVudHMgR3B1RGF0YU1hbmFnZXIge1xuICAvLyBHUFUgRGF0YSBJRCA9PiBHUFUgRGF0YSAoIHN0b3JhZ2UgYnVmZmVyIClcbiAgcHJpdmF0ZSBzdG9yYWdlQ2FjaGU6IE1hcDxHcHVEYXRhSWQsIFN0b3JhZ2VDYWNoZVZhbHVlPjtcblxuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIHVwbG9hZGluZyAoIGRhdGEgaXMgdW5tYXBwZWQgKVxuICBwcml2YXRlIGJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nOiBHUFVCdWZmZXJbXTtcbiAgLy8gcGVuZGluZyBidWZmZXJzIGZvciBjb21wdXRpbmdcbiAgcHJpdmF0ZSBidWZmZXJzUGVuZGluZzogR1BVQnVmZmVyW107XG5cbiAgLy8gVGhlIHJldXNhYmxlIHN0b3JhZ2UgYnVmZmVycyBmb3IgY29tcHV0aW5nLlxuICBwcml2YXRlIGZyZWVCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG4gIC8vIFRoZSByZXVzYWJsZSB1bmlmb3JtIGJ1ZmZlcnNcbiAgcHJpdmF0ZSBmcmVlVW5pZm9ybUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcblxuICAvLyBUaGUgcGVuZGluZ0J1ZmZlcnMgZm9yIGNhcHR1cmUgZ3JhcGguXG4gIC8vIGEgU2Vzc2lvbklEIC0+IEdQVUJ1ZmZlcltdIG1hcHBpbmcuXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIC8vIFRoZSBzZXNzaW9uIGNvdW50LlxuICBwcml2YXRlIHNlc3Npb25Db3VudDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyA9IFtdO1xuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXldIG9mIGJ1Y2tldEZyZWVsaXN0KSB7XG4gICAgICBidWNrZXRBcnIucHVzaChrZXkpO1xuICAgICAgdGhpcy5mcmVlQnVmZmVycy5zZXQoa2V5LCBbXSk7XG4gICAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5zZXQoa2V5LCBbXSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgPSAwO1xuICB9XG5cbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBjb25zdCBzcmNBcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIGNvbnN0IHNyY09mZnNldCA9IGRhdGEuYnl0ZU9mZnNldDtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgY29uc3Qgc2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShzcmNMZW5ndGgpO1xuXG4gICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGdwdSBidWZmZXJcbiAgICBjb25zdCBncHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZ3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgaWYgKGdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUgIT09IHNyY0xlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7Z3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3NyY0xlbmd0aH1gKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdUJ1ZmZlckZvclVwbG9hZGluZyA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHsgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSwgc2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIH0sXG4gICAgKTtcblxuICAgIC8vIGNvcHkgKHVwbG9hZCkgZGF0YVxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnNldChuZXcgVWludDhBcnJheShzcmNBcnJheUJ1ZmZlciwgc3JjT2Zmc2V0LCBzcmNMZW5ndGgpKTtcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcudW5tYXAoKTtcblxuICAgIC8vIEdQVSBjb3B5XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLCAwLCBncHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsIDAsIHNpemUpO1xuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke2lkfSlgKTtcblxuICAgIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChncHVCdWZmZXJGb3JVcGxvYWRpbmcpO1xuICB9XG5cbiAgbWVtY3B5KHNvdXJjZUlkOiBHcHVEYXRhSWQsIGRlc3RpbmF0aW9uSWQ6IEdwdURhdGFJZCk6IHZvaWQge1xuICAgIC8vIGdldCBzb3VyY2UgZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IHNvdXJjZUdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChzb3VyY2VJZCk7XG4gICAgaWYgKCFzb3VyY2VHcHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGdwdSBidWZmZXJcbiAgICBjb25zdCBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChkZXN0aW5hdGlvbklkKTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUgIT09IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShzb3VyY2VHcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKTtcblxuICAgIC8vIEdQVSBjb3B5XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICBzb3VyY2VHcHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsXG4gICAgICAwLFxuICAgICAgc2l6ZSxcbiAgICApO1xuICB9XG5cbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzPzogW0dwdURhdGFJZCwgR1BVQnVmZmVyXSk6IG51bWJlciB7XG4gICAgbGV0IGlkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICBpZCA9IHByZXZpb3VzWzBdO1xuICAgICAgaWYgKGJ1ZmZlciA9PT0gcHJldmlvdXNbMV0pIHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IGNyZWF0ZU5ld0dwdURhdGFJZCgpO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLnNldChpZCwgeyBncHVEYXRhOiB7IGlkLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXIgfSwgb3JpZ2luYWxTaXplIH0pO1xuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke2lkfSwgcmVnaXN0ZXJlZC5gLFxuICAgICk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGlkOiBHcHVEYXRhSWQpOiB2b2lkIHtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke2lkfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpOiBHcHVEYXRhIHtcbiAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY0J1Y2tldEJ1ZmZlclNpemUoc2l6ZSk7XG5cbiAgICBsZXQgZ3B1QnVmZmVyO1xuICAgIC8vIEN1cnJlbnRseSwgb25seSBzdG9yYWdlIGJ1ZmZlcnMgYXJlIHJldXNlZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IGlzU3RvcmFnZSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNVbmlmb3JtID0gKHVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07XG4gICAgaWYgKGlzU3RvcmFnZSB8fCBpc1VuaWZvcm0pIHtcbiAgICAgIGNvbnN0IGZyZWVCdWZmZXJzID0gaXNTdG9yYWdlID8gdGhpcy5mcmVlQnVmZmVycyA6IHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzO1xuICAgICAgY29uc3QgYnVmZmVycyA9IGZyZWVCdWZmZXJzLmdldChidWZmZXJTaXplKTtcbiAgICAgIGlmICghYnVmZmVycykge1xuICAgICAgICAvLyBubyBzdWNoIGJ1Y2tldC9mcmVlbGlzdCAtIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaW4gZnJlZWxpc3QsIHVzZSBpdFxuICAgICAgICAgIGdwdUJ1ZmZlciA9IGJ1ZmZlcnMucG9wKCkgYXMgR1BVQnVmZmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJ1Y2tldCBlbXB0eSwgY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdwdURhdGEgPSB7IGlkOiBjcmVhdGVOZXdHcHVEYXRhSWQoKSwgdHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCwgYnVmZmVyOiBncHVCdWZmZXIgfTtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZ3B1RGF0YS5pZCwgeyBncHVEYXRhLCBvcmlnaW5hbFNpemU6IHNpemUgfSk7XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHtzaXplfSkgPT4gaWQ9JHtncHVEYXRhLmlkfWApO1xuICAgIHJldHVybiBncHVEYXRhO1xuICB9XG5cbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKT8uZ3B1RGF0YTtcbiAgfVxuXG4gIHJlbGVhc2UoaWQ6IEdwdURhdGFJZCk6IG51bWJlciB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XG4gICAgICBpZiAodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBjYWNoZSB3YXMgcHJldmlvdXNseSBjbGVhcmVkLCBubyBuZWVkIHRvIHJlbGVhc2UgYW55dGhpbmcuXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7aWR9KSwgZ3B1RGF0YUlkPSR7Y2FjaGVkRGF0YS5ncHVEYXRhLmlkfWApO1xuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlcik7XG4gICAgLy8gY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG5cbiAgICByZXR1cm4gY2FjaGVkRGF0YS5vcmlnaW5hbFNpemU7XG4gIH1cblxuICBhc3luYyBkb3dubG9hZChpZDogR3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcy5iYWNrZW5kLCBjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyLCBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZSwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKSB7XG4gICAgICAvLyB1cGxvYWQgYnVmZmVyIGlzIG9ubHkgdXNlZnVsIGluIHRoZSBzZXNzaW9uIGNyZWF0aW9uIHRpbWUuIFNvIHdlIGRvbid0IG5lZWQgdG8gcmV1c2UgdGhlbSBpbiBzZXNzaW9uIHJ1bm5pbmcuXG4gICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nID0gW107XG5cbiAgICBpZiAodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdkZWZhdWx0Jykge1xuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgICBjb25zdCBtYXhJbkZyZWVMaXN0ID0gYnVja2V0RnJlZWxpc3QuZ2V0KGJ1ZmZlci5zaXplKTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSB7XG4gICAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgfSBlbHNlIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pIHtcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVVbmlmb3JtQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KGJ1ZmZlci5zaXplKSB8fCBbXTtcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgcmVsZWFzZSBpbnRlcm1lZGlhdGUgdGVuc29ycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgLy8gVE9ETzogcmV1c2UgdGhlIHN0b3JhZ2UgYnVmZmVycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgbGV0IGNhcHR1cmVkQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICAgIGlmICghY2FwdHVyZWRCdWZmZXJzKSB7XG4gICAgICAgIGNhcHR1cmVkQnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISwgY2FwdHVyZWRCdWZmZXJzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcbiAgICAgIHN0b3JhZ2UuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIG9uQ3JlYXRlU2Vzc2lvbigpIHtcbiAgICB0aGlzLnNlc3Npb25Db3VudCArPSAxO1xuICB9XG5cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcikge1xuICAgIC8vIHJlbGVhc2UgdGhlIGNhcHR1cmVkIHBlbmRpbmcgYnVmZmVycy5cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAocGVuZGluZ0J1ZmZlcnMpIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLy8gcmVsZWFzZSB0aGUgc3RvcmFnZSBjYWNoZSBpZiBubyBhY3RpdmUgc2Vzc2lvbnMuXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgLT0gMTtcbiAgICBpZiAodGhpcy5zZXNzaW9uQ291bnQgPT09IDApIHtcbiAgICAgIExPR19ERUJVRygnd2FybmluZycsICgpID0+ICdbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlJyk7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgICAgIHN0b3JhZ2UuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XG4gIG5ldyBHcHVEYXRhTWFuYWdlckltcGwoLi4uYXJncyk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNsYXNzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBrZXk6IHN0cmluZztcbiAgcHVibGljIGdldCBjYWNoZUtleSgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgIHRoaXMua2V5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcylcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChuYW1lKSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YClcbiAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY2FjaGVLZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBuZXcgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGF0dHJpYnV0ZSwgYW5kIGFkZCBhIGNhY2hlS2V5IHByb3BlcnR5IHRvIGl0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgYXR0cmlidXRlOiBULFxuKTogVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9PiBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShcbiAgICBhZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGlzTWF0TXVsID0gZmFsc2UsXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxuICAgICAgICBbYWRpbXNbYXJhbmsgLSAyXSwgYWRpbXNbYXJhbmsgLSAxXV0sXG4gICAgICAgIFtiZGltc1ticmFuayAtIDJdLCBiZGltc1ticmFuayAtIDFdXSxcbiAgICAgICk7XG4gICAgICBpZiAoY1NoYXBlTWF0TXVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFtjZGltc1tjcmFuayAtIDJdLCBjZGltc1tjcmFuayAtIDFdXSA9IGNTaGFwZU1hdE11bDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaXNNYXRNdWwgPyAzIDogMTsgaSA8PSBjcmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBhTGVuID0gYXJhbmsgLSBpIDwgMCA/IDEgOiBhZGltc1thcmFuayAtIGldO1xuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcblxuICAgICAgaWYgKGFMZW4gIT09IGJMZW4gJiYgYUxlbiA+IDEgJiYgYkxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXG4gICAgICAgIGlmIChtYXggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2RpbXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpXG4gICAqL1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGRpbXMgY29ycmVzcG9uZGluZyB0byB0eXBlIGNoYW5nZSB0byBwYWNrLiBleC4gdWludDggZGF0YSB0byB1aW50MzJcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNpemUgPSA0KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGxldCBpID0gcmFuayAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XG4gICAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldIC8gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZSAlIGRpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBzaGFwZScpO1xuICAgICAgfVxuICAgICAgbmV3RGltc1tpXSA9IDE7XG4gICAgICBzaXplIC89IGRpbXNbaV07XG4gICAgICBpLS07XG4gICAgfVxuICAgIGZvciAoaS0tOyBpID49IDA7IGktLSkge1xuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBuZXdEaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIHRvIHRoZSBnaXZlbiBheGlzIChleGNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIGFuZCB0byB0aGUgZ2l2ZW4gYXhpcyBbc3RhcnQsIGVuZClcbiAgICovXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzaXplICo9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAxXSA9IDE7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBkaW1zW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFpbHplIGF4aXMgb2YgcmFuZ2UgWy1yLCByKSBpbnRvIFswLCByKS5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVBeGlzKGF4aXM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rICYmIGF4aXMgPj0gdGVuc29yUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPCAwID8gYXhpcyArIHRlbnNvclJhbmsgOiBheGlzO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZUF4ZXMoYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHRlbnNvclJhbms/OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGEgZ2l2ZW4gYXJyYXkgYmFzZWQgb24gdGhlIGluZGljZXMgaW4gdGhlIFBlcm0gYXJyYXlcbiAgICogVXNlZCBpbiBUcmFuc3Bvc2VcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXG4gICAqIEBwYXJhbSBwZXJtIFBlcm0gZ2l2ZW47IGlmIG51bGwgYSB3aWxsIGJlIHJldmVyc2VkXG4gICAqL1xuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKHBlcm0pIHtcbiAgICAgIHJldHVybiBwZXJtLm1hcCgodikgPT4gYVt2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xuICAgKiBAcGFyYW0gZGltcyBzaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHBhZGRlZFxuICAgKiBAcGFyYW0gcGFkIHBhZCB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBwYWRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcGFkOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdHdvIHNoYXBlcyBhcmUgaWRlbnRpY2FsXG4gICAqIEBwYXJhbSBzaGFwZTFcbiAgICogQHBhcmFtIHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIGFyZUVxdWFsKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFhdXRvUGFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWRlcy5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICBpbnB1dERpbXNbZGltICsgKGlzQ2hhbm5lbExhc3QgPyAxIDogMildLFxuICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICBrZXJuZWxTaGFwZVtkaW1dLFxuICAgICAgICBwYWRzLFxuICAgICAgICBkaW0sXG4gICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICBhdXRvUGFkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICAgIGlucHV0RGltcyxcbiAgICAgIG91dHB1dERpbXMsXG4gICAgICBzdHJpZGVzLFxuICAgICAgZGlsYXRpb25zLFxuICAgICAga2VybmVsU2hhcGUsXG4gICAgICBwYWRzLFxuICAgICAgYXV0b1BhZCxcbiAgICApO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChcbiAgICAgICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXG4gICAgICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgICAgICBkaWxhdGlvbnNbZGltXSxcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgICAgICBwYWRzLFxuICAgICAgICAgICAgZGltLFxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgIGluU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLFxuICAgIGRpbGF0aW9uOiBudW1iZXIsXG4gICAga2VybmVsOiBudW1iZXIsXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgcGFkVGFpbEluZGV4OiBudW1iZXIsXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSBhdXRvUGFkID09PSAnU0FNRV9MT1dFUicgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNMZWZ0OiBib29sZWFuLFxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0sIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIGNvbnN0YW50IHZhbHVlIGZvciBhIHdvcmtncm91cCBzaXplLlxuICpcbiAqIFdlIGRlZmluaXRlbHkgY2FuIGRvIGZ1cnRoZXIgb3B0aW1pemF0aW9uIGluIGZ1dHVyZSwgYnV0IGZvciBub3cgd2UgdXNlIDY0LlxuICpcbiAqIHJ1bGUgb2YgdGh1bWI6IFVzZSBbYSB3b3JrZ3JvdXAgc2l6ZSBvZl0gNjQgdW5sZXNzIHlvdSBrbm93IHdoYXQgR1BVIHlvdSBhcmUgdGFyZ2V0aW5nIG9yIHRoYXQgeW91ciB3b3JrbG9hZFxuICogICAgICAgICAgICAgICAgbmVlZHMgc29tZXRoaW5nIGRpZmZlcmVudC5cbiAqXG4gKiBmcm9tOiBodHRwczovL3N1cm1hLmRldi90aGluZ3Mvd2ViZ3B1L1xuICoqL1xuZXhwb3J0IGNvbnN0IFdPUktHUk9VUF9TSVpFID0gNjQ7XG5cbmludGVyZmFjZSBJbmRpY2VzSGVscGVyVHlwZXMge1xuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIGluZGljZXMgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2YgYSB2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIHN0b3JhZ2UgdHlwZSByZXByZXNlbnRpbmcgYSB2YWx1ZVxuICAgKlxuICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgdG8gYHZhbHVlYCwgYnV0IGZvciBzb21lIHR5cGUgKGVnLiBib29sKSwgd2UgbmVlZCB0byB1c2UgYHUzMmAgYXMgc3RvcmFnZSB0eXBlIGZvclxuICAgKiB2YWx1ZSB0eXBlIGB2ZWM0PGJvb2w+YFxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3XG4gICAqL1xuICByZWFkb25seSB0ZW5zb3I6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIG9mZmVyIGEgdW5pZmllZCB3YXkgdG8gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXInc1xuICogaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHRlcm1pbm9sb2dpZXMgdXNlZCBpbiB0aGlzIGNsYXNzOlxuICogLSBgb2Zmc2V0YDogYSB1aW50MzIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCBpbiB0aGUgZGF0YSBidWZmZXIuXG4gKiAtIGBpbmRpY2VzYDogYW4gYWJzdHJhY3Rpb24gb2YgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSdzIGluZGljZXMgcmVwcmVzZW50aW5nIHRoZSBkYXRhJ3MgaW5kZXggb24gZWFjaCBkaW1lbnNpb24uXG4gKiAtIGB2YWx1ZWA6IGEgdmFsdWUgb2YgYSBkYXRhIGVsZW1lbnQuXG4gKlxuICogVXNlcnMgYXJlIGV4cGVjdGVkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZvciBlYWNoIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dCwgYW5kIHVzZSB0aGUgaW5zdGFuY2UgdG9cbiAqIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEuIFRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIGZvciB1c2VycyB0byBjYWxsIHRvXG4gKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaWNlcyBoZWxwZXI6XG4gKiAtIGBpbnB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGlucHV0LlxuICogLSBgb3V0cHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gb3V0cHV0LlxuICogLSBgaW50ZXJuYWxWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBBbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBjb250YWlucyBoZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gKiAtIGFjY2VzcyByZWFkb25seSBiYXNpYyBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgbmFtZWAodGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dCksIGB1c2FnZWAod2hldGhlciBpdCdzIGFuXG4gKiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlKSBhbmQgYHNoYXBlYCh0aGUgcGFzc2VkIGluIHNoYXBlKS5cbiAqIC0gYHR5cGVgOiBhY2Nlc3MgcmVhZG9ubHkgdHlwZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgaW5kaWNlc2AodGhlIHR5cGUgb2YgaW5kaWNlcyksIGB2YWx1ZWAodGhlIHR5cGUgb2YgdmFsdWUgYXRcbiAqIHJ1bnRpbWUpLCBgc3RvcmFnZWAodGhlIHR5cGUgb2YgdmFsdWUgYXQgc3RvcmFnZSkgYW5kIGB0ZW5zb3JgKHRoZSB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3KS5cbiAqIC0gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBnZXR0aW5nIGluZGljZXMgZnJvbSBvZmZzZXQuIFVzZSBgb2Zmc2V0VG9JbmRpY2VzKClgIGZvciBXR1NMIGNvZGUgc25pcHBldCB0byBjYWxjdWxhdGVcbiAqIGluZGljZXMgZnJvbSBvZmZzZXQsIGFuZCB1c2UgYGluZGljZXNUb09mZnNldCgpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlIG9mZnNldCBmcm9tIGluZGljZXMuXG4gKiAtIHRvIG1hbmlwdWxhdGUgYW4gaW5zdGFuY2Ugb2YgaW5kaWNlcywgdXNlIGBzZXRJbmRpY2VzKClgIGFuZCBgZ2V0SW5kaWNlcygpYCB0byBzZXQgYW5kIGdldCB0aGUgaW5kaWNlcyBvbiBhblxuICogaW5kaWNlcyB2YXJpYWJsZS5cbiAqIC0gdG8gbWFuaXB1bGF0ZSBkYXRhLCB1c2UgYHNldCgpYC9gZ2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gcGFyYW1ldGVyIGxpc3QsIHVzZVxuICogYHNldEJ5SW5kaWNlcygpYC9gZ2V0QnlJbmRpY2VzKClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gYW4gaW5kaWNlcyB2YXJpYWJsZSwgYW5kIHVzZVxuICogYHNldEJ5T2Zmc2V0KClgL2BnZXRCeU9mZnNldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICogLSBgaW1wbGA6IGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucyBtZW50aW9uZWQgYWJvdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kaWNlc0hlbHBlciB7XG4gIC8qKlxuICAgKiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMuXG4gICAqXG4gICAqL1xuICByZWFkb25seSBpbXBsOiAoKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGdldCB0eXBlIGluZm9cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IEluZGljZXNIZWxwZXJUeXBlcztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGEgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gdmFyT2Zmc2V0IC0gYSB1MzIgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgb2Zmc2V0VG9JbmRpY2VzOiAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb2Zmc2V0IGZyb20gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb3JpZ2luYWwgb2Zmc2V0IGZyb20gYnJvYWRjYXN0ZWQgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvdXRwdXQgaW5kaWNlcy5cbiAgICogQHBhcmFtIG91dHB1dCAtIG91dHB1dCBJbmRpY2VzSGVscGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBnZW5lcmF0aW5nIGFuIGluZGljZXMgbGl0ZXJhbFxuICAgKlxuICAgKiBAcGFyYW0gaW5pdCAtIGluaXRpYWwgdmFsdWUuXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzOiAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYSBXR1NMIHN0YXRlbWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBnZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc0dldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcbiAgICogICAgIGJ5IHRoZSB2YWx1ZSB0byBzZXQuIFRoaXMgYXJyYXkgc2hvdWxkIGhhdmUgZXhhY3RseSBgc2hhcGUubGVuZ3RoICsgMWAgZWxlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gc2hvdWxkIGJlIGEgV0dTTCBleHByZXNzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgc2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRpY2VzIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cbiAgICovXG4gIHJlYWRvbmx5IGdldDogKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZSBvZiB0aGUgZGF0YSB2YXJpYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBoZWxwZXIgaXMgZm9yIGFuIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gICAqL1xuICByZWFkb25seSB1c2FnZTogJ2lucHV0JyB8ICdvdXRwdXQnIHwgJ2ludGVybmFsJztcblxuICAvKipcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHNoYXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHN0cmlkZXMgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcbn1cblxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0KTogc3RyaW5nIHwgW3N0cmluZywgc3RyaW5nXSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkJyk7XG4gIH1cblxuICAvLyByZXR1cm4gdHlwZSBpcyBbIHN0b3JhZ2UgdHlwZSwgcnVudGltZSB0eXBlIF0gb3IgYSBzaW5nbGUgc3RyaW5nIGZvciBib3RoXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYxNj5gIDogJ2YxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYzMj5gIDogJ2YzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGkzMj5gIDogJ2kzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTx1MzI+YCA6ICd1MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICdpMzInXTtcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcbiAgICAgIGlmIChjb21wb25lbnRzID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsndmVjMjx1MzI+JywgJ3UzMiddO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGlmIChjb21wb25lbnRzICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm9vbCBtdXN0IGJlIHZlYzQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3UzMicsICd2ZWM0PGJvb2w+J107XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ0OlxuICAgICAgcmV0dXJuICdpMzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDQ6XG4gICAgICByZXR1cm4gJ3UzMic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMgPSAoLi4uZGltczogUmVhZG9ubHlBcnJheTxyZWFkb25seSBudW1iZXJbXT4pOiBQcm9ncmFtVW5pZm9ybVtdID0+IHtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGRpbXMuZm9yRWFjaCgoZGltKSA9PiB7XG4gICAgaWYgKGRpbS5sZW5ndGggIT09IDApIHtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZGltIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltKSB9LFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJvZ3JhbVVuaWZvcm1zO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgbWF4aW11bSB2ZWN0b3Igc2l6ZSBmb3Igc3BlY2lmaWVkIGRhdGEgbGVuZ3RoXG4gKiBAcGFyYW0gc2l6ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0TWF4Q29tcG9uZW50cyA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgLy8gd2UgY2Fubm90IHVzZSB2ZWMzIHR5cGUgc2luY2UgaXQgaGFzIGFsaWdubWVudCBvZiAxNiBieXRlc1xuICBpZiAoc2l6ZSAlIDQgPT09IDApIHtcbiAgICByZXR1cm4gNDtcbiAgfSBlbHNlIGlmIChzaXplICUgMiA9PT0gMCkge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdmFyaWFibGUgYXMgYSBzY2FsYXIgb3IgdmVjdG9yLiBlLmcuIGYzMigwKSBvciB2ZWM0ZigwLDAsMCwwKVxuICogQHBhcmFtIGRhdGFUeXBlXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBmaWxsVmVjdG9yID0gKGRhdGFUeXBlID0gJ2YzMicsIGNvbXBvbmVudHM/OiBudW1iZXIsIHZhbHVlID0gJzAnKSA9PiB7XG4gIGlmICghY29tcG9uZW50cyB8fCBjb21wb25lbnRzID09PSAxKSB7XG4gICAgcmV0dXJuIGAke2RhdGFUeXBlfSgke3ZhbHVlfSlgO1xuICB9XG5cbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PCR7ZGF0YVR5cGV9Pigke3ZhbHVlfSlgO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNhc3RzIHZhbHVlIG9yIHZlY3RvciB0byBmMzJcbiAqIEBwYXJhbSBkYXRhVHlwZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgY2FzdFRvRjMyID0gKGRhdGFUeXBlOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlciwgdmFsdWU6IHN0cmluZykgPT4ge1xuICBpZiAoZGF0YVR5cGUgPT09ICdmMzInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChjb21wb25lbnRzID09PSAxKSB7XG4gICAgcmV0dXJuIGBmMzIoJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiBgdmVjJHtjb21wb25lbnRzfTxmMzI+KCR7dmFsdWV9KWA7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBzY2FsYXIgb3Igc3VtcyBhbGwgY29tcG9uZW50cyBvZiBhIHZlY3RvclxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBzdW1WZWN0b3IgPSAobmFtZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIpID0+IHtcbiAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnogKyAke25hbWV9LncpYDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAyKSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55KWA7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSArICR7bmFtZX0ueilgO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB2YXJpYWJsZSBlbGVtZW50IGF0IGluZGV4LlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB2YXJpYWJsZS5cbiAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCBvZiB2YXJpYWJsZSBlbGVtZW50LlxuICogQHBhcmFtIGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdmFyaWFibGUuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHZhcmlhYmxlLCBvcHRpb25hbC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRBdCA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBpbmRleDogbnVtYmVyIHwgc3RyaW5nLFxuICBsZW5ndGg6IG51bWJlcixcbiAgdHlwZT86IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4pOiBzdHJpbmcgPT4ge1xuICBpZiAobmFtZS5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSAmJiBsZW5ndGggPiA0KSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDhdWygke2luZGV4fSkgJSA4IC8gNF1bKCR7aW5kZXh9KSAlIDggJSA0XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDRdWygke2luZGV4fSkgJSA0XWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gOCl9XVske01hdGguZmxvb3IoKGluZGV4ICUgOCkgLyA0KX1dWyR7KGluZGV4ICUgOCkgJSA0fV1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDQpfV1bJHtpbmRleCAlIDR9XWA7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsZW5ndGggPiAxID8gYCR7bmFtZX1bJHtpbmRleH1dYCA6IG5hbWU7XG4gIH1cbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgSW5kaWNlc0hlbHBlciBmb3IgYSBnaXZlbiBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHRlbnNvclR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSB1c2FnZSAtIHRoZSB1c2FnZSBvZiB0aGUgaW5kaWNlcyBoZWxwZXIuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgZWFjaCBlbGVtZW50LiAxIGZvciBzY2FsYXIsIDIgZm9yIHZlYzIsIDMgZm9yIHZlYzMsIDQgZm9yXG4gKiAgICB2ZWM0LlxuICovXG5jb25zdCBjcmVhdGVJbmRpY2VzSGVscGVyID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHRlbnNvclR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICB1c2FnZTogSW5kaWNlc0hlbHBlclsndXNhZ2UnXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCxcbik6IEluZGljZXNIZWxwZXIgPT4ge1xuICBjb25zdCB1c2VVbmlmb3JtID0gdHlwZW9mIHNoYXBlT3JSYW5rID09PSAnbnVtYmVyJztcbiAgY29uc3QgcmFuayA9IHVzZVVuaWZvcm0gPyBzaGFwZU9yUmFuayA6IHNoYXBlT3JSYW5rLmxlbmd0aDtcbiAgY29uc3QgcmFua0lkZW50aXR5ID0gWy4uLm5ldyBBcnJheShyYW5rKS5rZXlzKCldO1xuICBjb25zdCBpbmRpY2VzVHlwZSA9IHJhbmsgPCAyID8gJ3UzMicgOiByYW5rIDw9IDQgPyBgdmVjJHtyYW5rfTx1MzI+YCA6IGBhcnJheTx1MzIsICR7cmFua30+YDtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHRlbnNvclR5cGUsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcbiAgY29uc3Qgc3RvcmFnZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcbiAgY29uc3QgdHlwZSA9IHsgaW5kaWNlczogaW5kaWNlc1R5cGUsIHZhbHVlOiB2YWx1ZVR5cGUsIHN0b3JhZ2U6IHN0b3JhZ2VUeXBlLCB0ZW5zb3I6IHRlbnNvclR5cGUgfTtcblxuICBjb25zdCBub3JtYWxpemVEaW0gPSAoZGltOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4gKHR5cGVvZiBkaW0gPT09ICdzdHJpbmcnID8gZGltIDogYCR7ZGltfXVgKTtcblxuICBjb25zdCBpbXBsZW1lbnRhdGlvblVzZWQgPSB7XG4gICAgb2Zmc2V0VG9JbmRpY2VzOiBmYWxzZSxcbiAgICBpbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcbiAgICBzZXQ6IGZhbHNlLFxuICAgIHNldEJ5SW5kaWNlczogZmFsc2UsXG4gICAgZ2V0OiBmYWxzZSxcbiAgICBnZXRCeUluZGljZXM6IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0IHVuaWZvcm1QcmVmaXggPSB1c2VVbmlmb3JtID8gJ3VuaWZvcm1zLicgOiAnJztcbiAgY29uc3Qgc2hhcGUgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc2hhcGVgO1xuICBjb25zdCBzdHJpZGVzID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3N0cmlkZXNgO1xuXG4gIGxldCBvMmlTbmlwcGV0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7IGkrKykge1xuICAgIG8yaVNuaXBwZXQgKz0gYFxuICAgIGxldCBkaW0ke2l9ID0gY3VycmVudCAvICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcbiAgICBsZXQgcmVzdCR7aX0gPSBjdXJyZW50ICUgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xuICAgIGluZGljZXNbJHtpfV0gPSBkaW0ke2l9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtpfTtcbiAgICBgO1xuICB9XG4gIG8yaVNuaXBwZXQgKz0gYGluZGljZXNbJHtyYW5rIC0gMX1dID0gY3VycmVudDtgO1xuXG4gIGNvbnN0IG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiBgXG4gIGZuIG8yaV8ke25hbWV9KG9mZnNldDogdTMyKSAtPiAke3R5cGUuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke3R5cGUuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHtvMmlTbmlwcGV0fVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YDtcblxuICBjb25zdCBvZmZzZXRUb0luZGljZXMgPSAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHtcbiAgICBpbXBsZW1lbnRhdGlvblVzZWQub2Zmc2V0VG9JbmRpY2VzID0gdHJ1ZTtcbiAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJPZmZzZXQgOiBgbzJpXyR7bmFtZX0oJHt2YXJPZmZzZXR9KWA7XG4gIH07XG5cbiAgY29uc3Qgb2Zmc2V0czogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHJhbmsgPj0gMikge1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG9mZnNldHMucHVzaChgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9ICogKGluZGljZXNbJHtpfV0pYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6IGBcbiAgZm4gaTJvXyR7bmFtZX0oaW5kaWNlczogJHt0eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke29mZnNldHMuam9pbignKycpfTtcbiAgfWA7XG5cbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xuICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgIHJldHVybiByYW5rIDwgMiA/IHZhckluZGljZXMgOiBgaTJvXyR7bmFtZX0oJHt2YXJJbmRpY2VzfSlgO1xuICB9O1xuXG4gIGNvbnN0IGluZGljZXMgPSAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PlxuICAgIHJhbmsgPT09IDAgPyAnMHUnIDogYCR7dHlwZS5pbmRpY2VzfSgke2luaXQubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpfSlgO1xuXG4gIGNvbnN0IGluZGljZXNHZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGluZGljZXNTZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9PSR7dmFsdWV9O2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX09JHt2YWx1ZX07YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICAgIGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgY29uc3QgaW1wbEtleSA9IGAke291dHB1dC5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtuYW1lfU9mZnNldGA7XG4gICAgaWYgKGltcGxLZXkgaW4gYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikge1xuICAgICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGlkeCA9IG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgaSArIG91dHB1dC5yYW5rIC0gcmFuayk7XG4gICAgICBvZmZzZXRzLnB1c2goYCR7aW5kaWNlc0dldChzdHJpZGVzLCBpKX0gKiAoJHtpZHh9ICUgJHtpbmRpY2VzR2V0KHNoYXBlLCBpKX0pYCk7XG4gICAgfVxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb25baW1wbEtleV0gPSBgZm4gJHtpbXBsS2V5fShvdXRwdXRJbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke29mZnNldHMubGVuZ3RoID4gMCA/IG9mZnNldHMuam9pbignKycpIDogJzB1J307XG4gICAgICAgICAgIH1gO1xuXG4gICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgfTtcblxuICBjb25zdCBzZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT5cbiAgICAoKCkgPT4ge1xuICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT0ke3ZhbHVlfTtgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XG4gICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3ZhbHVlfSA8IDApKTtgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgMHUpO2A7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XG4gICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHt2YWx1ZX0pKTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gIGNvbnN0IGdldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nKSA9PlxuICAgICgoKSA9PiB7XG4gICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xuICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYGkzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYHUzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xuICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XG4gICAgICAgIHJldHVybiBgdmVjNDxib29sPihib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkZ1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDB1KSwgYm9vbCgke25hbWV9WyR7XG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH1dICYgMHhGRjAwMDB1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDAwMDAwdSkpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICBjb25zdCBnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBnZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgcmV0dXJuICR7Z2V0QnlPZmZzZXQoYGkyb18ke25hbWV9KGluZGljZXMpYCl9O1xuICB9YDtcblxuICBjb25zdCBnZXRJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYFxuICBmbiBnZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSkgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICByZXR1cm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSk7XG4gIH1gO1xuICAgICAgICB9KSgpO1xuXG4gIGNvbnN0IGdldCA9ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHtcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQoJzB1Jyk7XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0ID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYGdldF8ke25hbWV9KCR7bm9ybWFsaXplZEluZGljZXN9KWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBnZXRCeU9mZnNldCh2YXJJbmRpY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSlgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBzZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30sIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICAke3NldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWAsICd2YWx1ZScpfVxuICB9YDtcblxuICBjb25zdCBzZXRJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYFxuICBmbiBzZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgIHNldF8ke25hbWV9QnlJbmRpY2VzKCR7aW5kaWNlcyhkaW1zUGFyYW1zKX0sIHZhbHVlKTtcbiAgfWA7XG4gICAgICAgIH0pKCk7XG5cbiAgY29uc3Qgc2V0ID0gKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiB7XG4gICAgaWYgKGluZGljZXNBbmRWYWx1ZS5sZW5ndGggIT09IHJhbmsgKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtyYW5rfWApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGluZGljZXNBbmRWYWx1ZVtyYW5rXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlc0FuZFZhbHVlLnNsaWNlKDAsIHJhbmspLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQoJzB1JywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXQgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgc2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30sICR7dmFsdWV9KWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldCh2YXJJbmRpY2VzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYHNldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30sICR7dmFsdWV9KTtgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpbXBsID0gKCkgPT4ge1xuICAgIGNvbnN0IGltcGxzID0gW107XG4gICAgbGV0IG5lZWRTaGFwZVN0cmlkZXMgPSBmYWxzZTtcbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcykge1xuICAgICAgaW1wbHMucHVzaChvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgIGltcGxzLnB1c2goaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikuZm9yRWFjaCgoaW1wbCkgPT4gaW1wbHMucHVzaChpbXBsKSk7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXQpIHtcbiAgICAgIGltcGxzLnB1c2goc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzKSB7XG4gICAgICBpbXBscy5wdXNoKHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmdldCkge1xuICAgICAgaW1wbHMucHVzaChnZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMpIHtcbiAgICAgIGltcGxzLnB1c2goZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdXNlVW5pZm9ybSAmJiBuZWVkU2hhcGVTdHJpZGVzKSB7XG4gICAgICBpbXBscy51bnNoaWZ0KFxuICAgICAgICBgY29uc3QgJHtzaGFwZX0gPSAke3R5cGUuaW5kaWNlc30oJHtzaGFwZU9yUmFuay5qb2luKCcsJyl9KTtgLFxuICAgICAgICBgY29uc3QgJHtzdHJpZGVzfSA9ICR7dHlwZS5pbmRpY2VzfSgke1NoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZU9yUmFuaykuam9pbignLCcpfSk7YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbXBscy5qb2luKCdcXG4nKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGltcGwsXG4gICAgdHlwZSxcbiAgICBvZmZzZXRUb0luZGljZXMsXG4gICAgaW5kaWNlc1RvT2Zmc2V0LFxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0LFxuICAgIGluZGljZXMsXG4gICAgaW5kaWNlc0dldCxcbiAgICBpbmRpY2VzU2V0LFxuICAgIHNldCxcbiAgICBzZXRCeU9mZnNldCxcbiAgICBzZXRCeUluZGljZXMsXG4gICAgZ2V0LFxuICAgIGdldEJ5T2Zmc2V0LFxuICAgIGdldEJ5SW5kaWNlcyxcbiAgICAvLyBpc1ZlYzQsXG4gICAgdXNhZ2UsXG4gICAgbmFtZSxcbiAgICBzdHJpZGVzLFxuICAgIHNoYXBlLFxuICAgIHJhbmssXG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGlucHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgaW5wdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0VmFyaWFibGUgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgdHlwZTogbnVtYmVyLFxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxLFxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW5wdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBvdXRwdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBvdXRwdXRWYXJpYWJsZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0eXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdvdXRwdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIHZhcmlhYmxlLiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbFZhcmlhYmxlID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2ludGVybmFsJywgY29tcG9uZW50cyk7XG5cbmV4cG9ydCB0eXBlIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgPSAndTMyJyB8ICdmMTYnIHwgJ2YzMicgfCAnaTMyJztcbmV4cG9ydCB0eXBlIFVuaWZvcm1zQXJyYXlUeXBlID0gQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGU7IGxlbmd0aD86IG51bWJlciB9PjtcblxuLyoqXG4gKiBBIFNoYWRlckhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySGVscGVyIHtcbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBzdGFydCBvZiBtYWluIGZ1bmN0aW9uIGluIFdHU0wgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgKiAgLi4uXG4gICAqXG4gICAqICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICogYDtcbiAgICpcbiAgICogQHBhcmFtIHdvcmtncm91cFNpemUgLSBhbiBvcHRpb25hbCB3b3JrZ3JvdXAgc2l6ZS4gZGVmYXVsdCBpcyBXT1JLR1JPVVBfU0laRS5cbiAgICovXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBndWFyZGluZyBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgc2l6ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAqICAuLi5cbiAgICpcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgKiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgKlxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKiBgO1xuICAgKlxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBkYXRhIHRvIGd1YXJkIGFnYWluc3QuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICovXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogdW5rbm93bik6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNvZGUgc25pcHBldCBmb3IgZGVjbGFyaW5nIG11bHRpcGxlIGlucHV0cyBvciBvdXRwdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIGRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG9uZSB1bmlmb3JtLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgdW5pZm9ybSwgZGVmYXVsdCB0byAxIHdoZW4gaXQgaXMgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBTaGFkZXJIZWxwZXI7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gdW5pZm9ybXMgLSBhbiBhcnJheSBvZiB1bmlmb3Jtcy4gRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6IGBuYW1lYCBhbmRcbiAgICogICAgIGB0eXBlYC5cbiAgICovXG4gIHJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKTogU2hhZGVySGVscGVyO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSBpbnRlcm5hbCB2YXJpYWJsZXMuIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGVcbiAgICogaW50ZXJuYWwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXI7XG59XG5cbmNsYXNzIFNoYWRlckhlbHBlckltcGwgaW1wbGVtZW50cyBTaGFkZXJIZWxwZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgcHJpdmF0ZSBsaW1pdHM6IEdQVVN1cHBvcnRlZExpbWl0cyxcbiAgKSB7fVxuXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBHdWFyZCBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgd29yayBncm91cCBzaXplc1xuICAgIGNvbnN0IHNpemVJbkNvZGUgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBgJHtzaXplfXVgIDogc2l6ZTtcbiAgICByZXR1cm4gYGlmIChnbG9iYWxfaWR4ID49ICR7c2l6ZUluQ29kZX0pIHsgcmV0dXJuOyB9YDtcbiAgfVxuXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBXT1JLR1JPVVBfU0laRSkge1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVYID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gd29ya2dyb3VwU2l6ZSA6IHdvcmtncm91cFNpemVbMF07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVkgPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsxXTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWiA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzJdO1xuXG4gICAgaWYgKFxuICAgICAgd29ya2dyb3VwU2l6ZVggPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVggfHxcbiAgICAgIHdvcmtncm91cFNpemVZID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIHx8XG4gICAgICB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWlxuICAgICAgICB9XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBzaXplIFske3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWH0sICR7XG4gICAgICAgICAgdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZXG4gICAgICAgIH0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHdvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWlxuICAgICAgICB9XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gaXMxRGltZW5zaW9uRGlzcGF0Y2hcbiAgICAgID8gYEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YFxuICAgICAgOiBgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gO1xuICAgIGNvbnN0IGdsb2JhbElkeERlZmluaXRpb24gPSBpczFEaW1lbnNpb25EaXNwYXRjaFxuICAgICAgPyBgbGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcbiAgICAgICAgIGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueDtgXG4gICAgICA6IGBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLnogKiBudW1fd29ya2dyb3Vwc1swXSAqIG51bV93b3JrZ3JvdXBzWzFdICtcbiAgICAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqIG51bV93b3JrZ3JvdXBzWzBdICsgd29ya2dyb3VwX2lkLng7XG4gICAgICAgICBsZXQgZ2xvYmFsX2lkeCA9IHdvcmtncm91cF9pbmRleCAqICR7d29ya2dyb3VwU2l6ZVggKiB3b3JrZ3JvdXBTaXplWSAqIHdvcmtncm91cFNpemVafXUgKyBsb2NhbF9pZHg7YDtcblxuICAgIHJldHVybiBgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHt3b3JrZ3JvdXBTaXplWn0pXG4gIGZuIG1haW4oJHtwYXJhbUxpc3R9KSB7XG4gICAgJHtnbG9iYWxJZHhEZWZpbml0aW9ufVxuICBgO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyKTogdm9pZCB7XG4gICAgaWYgKHZhcmlhYmxlLnJhbmsgIT09IDApIHtcbiAgICAgIGlmICh2YXJpYWJsZS5zaGFwZS5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lOiB2YXJpYWJsZS5zaGFwZS5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmsgfSk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFibGUuc3RyaWRlcy5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lOiB2YXJpYWJsZS5zdHJpZGVzLnJlcGxhY2UoJ3VuaWZvcm1zLicsICcnKSwgdHlwZTogJ3UzMicsIGxlbmd0aDogdmFyaWFibGUucmFuayB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlY2xhcmVWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlciwgYmluZGluZ0luZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICh2YXJpYWJsZS51c2FnZSA9PT0gJ2ludGVybmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcblxuICAgIGNvbnN0IGFjY2VzcyA9IHZhcmlhYmxlLnVzYWdlID09PSAnaW5wdXQnID8gJ3JlYWQnIDogJ3JlYWRfd3JpdGUnO1xuICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdmFyaWFibGUudHlwZS5zdG9yYWdlO1xuICAgIHJldHVybiBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YmluZGluZ0luZGV4fSkgdmFyPHN0b3JhZ2UsICR7YWNjZXNzfT4gJHt2YXJpYWJsZS5uYW1lfTogYXJyYXk8JHtzdG9yYWdlVHlwZX0+O2A7XG4gIH1cblxuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFyaWFibGVzLm1hcCgodikgPT4gdGhpcy5kZWNsYXJlVmFyaWFibGUodiwgdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyKTogdm9pZCB7XG4gICAgaWYgKHZhcmlhYmxlLnVzYWdlICE9PSAnaW50ZXJuYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xuICB9XG5cbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlciB7XG4gICAgdmFyaWFibGVzLmZvckVhY2goKHYpID0+IHRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHYpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsIGxlbmd0aCA9IDEpOiBTaGFkZXJIZWxwZXIge1xuICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWUsIHR5cGUsIGxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybXMoYWRkaXRpb25hbFVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXMuY29uY2F0KGFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGludGVybmFsVmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1EZWNsYXJhdGlvbigpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1TbmlwcGV0czogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdHlwZSwgbGVuZ3RoIH0gb2YgdGhpcy51bmlmb3Jtcykge1xuICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggPiA0KSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGBAYWxpZ24oMTYpICR7bmFtZX06YXJyYXk8bWF0Mng0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA4KX0+YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06YXJyYXk8dmVjNDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gNCl9PmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlVGVtcCA9IGxlbmd0aCA9PSBudWxsIHx8IGxlbmd0aCA9PT0gMSA/IHR5cGUgOiBgdmVjJHtsZW5ndGh9PCR7dHlwZX0+YDtcbiAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06JHt0eXBlVGVtcH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt1bmlmb3JtU25pcHBldHMuam9pbignLCAnKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YDtcbiAgfVxuICBwcml2YXRlIHZhcmlhYmxlSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBHZXQgYWRkaXRpb25hbCBpbXBsZW1lbnRhdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXIgc291cmNlLlxuICAgKi9cbiAgZ2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSArXG4gICAgICB0aGlzLnZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKSArXG4gICAgICB0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCgoaSkgPT4gaS5pbXBsKCkpLmpvaW4oJ1xcbicpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhcmlhYmxlIGluZm8gb2YgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKi9cbiAgZ2V0IHZhcmlhYmxlc0luZm8oKTogUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1XZ3NsVHlwZVRvRGF0YVR5cGUgPSAodHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSkgPT5cbiAgICAgIFtEYXRhVHlwZS51aW50MzIsIERhdGFUeXBlLmZsb2F0MTYsIERhdGFUeXBlLmZsb2F0LCBEYXRhVHlwZS5pbnQzMl1bWyd1MzInLCAnZjE2JywgJ2YzMicsICdpMzInXS5pbmRleE9mKHR5cGUpXTtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAoKHUpID0+IFt1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlKHUudHlwZSksIHUubGVuZ3RoID8/IDFdKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU2hhZGVySGVscGVyID0gKGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgbGltaXRzOiBHUFVTdXBwb3J0ZWRMaW1pdHMpID0+XG4gIG5ldyBTaGFkZXJIZWxwZXJJbXBsKGRpc3BhdGNoR3JvdXAsIGxpbWl0cyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvYmxvYi9tYXN0ZXIvdGZqcy1jb3JlL3NyYy9vcHMvYnJvYWRjYXN0X3V0aWwudHMjTDE4LUw0MFxuICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBpbiB0aGUgaW5wdXQgc2hhcGUgdGhhdCBhcmUgYnJvYWRjYXN0ZWQgdG9cbiAqIHByb2R1Y2UgdGhlIHByb3ZpZGVkIG91dHB1dCBzaGFwZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgMC1pbmRleGVkIGFuZCBzb3J0ZWQuIEFuIGV4YW1wbGU6XG4gKiBpblNoYXBlID0gWzQsIDEsIDNdXG4gKiBvdXRTaGFwZSA9IFs1LCA0LCAzLCAzXVxuICogcmVzdWx0ID0gWzFdLiBEaW1lbnNpb24gMSAoMm5kIGRpbWVuc2lvbiBvZiBpbnB1dCkgZ2V0cyBicm9hZGNhc3RlZCAxID0+IDMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCcm9hZGNhc3REaW1zID0gKGluU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgY29uc3QgZGltID0gaW5SYW5rIC0gMSAtIGk7XG4gICAgY29uc3QgYSA9IGluU2hhcGVbZGltXSB8fCAxO1xuICAgIGNvbnN0IGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICBpZiAoYiA+IDEgJiYgYSA9PT0gMSkge1xuICAgICAgZGltcy51bnNoaWZ0KGRpbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaW1zO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBwZXJtOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUGVybSA9IChpbnB1dFJhbms6IG51bWJlciwgcGVybTogbnVtYmVyW10pOiBudW1iZXJbXSA9PlxuICBwZXJtICYmIHBlcm0ubGVuZ3RoICE9PSBpbnB1dFJhbmsgPyBbLi4ubmV3IEFycmF5KGlucHV0UmFuaykua2V5cygpXS5yZXZlcnNlKCkgOiBwZXJtO1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PlxuICBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIGdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlLmxlbmd0aCwgcGVybSkpO1xuXG5jb25zdCBwZXJtRnVuY3Rpb25Cb2R5ID0gKHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIsIGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgcmV2ZXJzZUZ1bmMgPSBgZm4gcGVybShpOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICByZXZlcnNlRnVuYyArPSBpbnB1dC5pbmRpY2VzU2V0KCdhJywgcGVybVtpXSwgYGlbJHtpfV1gKTtcbiAgfVxuICByZXR1cm4gKHJldmVyc2VGdW5jICs9ICdyZXR1cm4gYTt9Jyk7XG59O1xuXG5jb25zdCBzcXVlZXplU2hhcGUgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhZGp1c3RlZFBlcm06IG51bWJlcltdKTogeyBuZXdTaGFwZTogbnVtYmVyW107IG5ld1Blcm06IG51bWJlcltdIH0gPT4ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgbmV3UGVybTogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgfVxuICAgIGlmIChzaGFwZVthZGp1c3RlZFBlcm1baV1dICE9PSAxKSB7XG4gICAgICBuZXdQZXJtLnB1c2goYWRqdXN0ZWRQZXJtW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbmV3U2hhcGUsIG5ld1Blcm0gfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgcGVybUF0dHI6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dERhdGFUeXBlID0gaW5wdXRUZW5zb3IuZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xuICBjb25zdCBwZXJtID0gZ2V0QWRqdXN0ZWRQZXJtKGlucHV0UmFuaywgcGVybUF0dHIpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0VGVuc29yLmRpbXMsIHBlcm0pO1xuICBjb25zdCB7IG5ld1NoYXBlLCBuZXdQZXJtIH0gPSBzcXVlZXplU2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XG4gIGNvbnN0IGNoYW5uZWxzTGFzdCA9IFNoYXBlVXRpbC5hcmVFcXVhbChuZXdQZXJtLCBbMiwgMywgMV0pO1xuICBjb25zdCBjaGFubmVsc0ZpcnN0ID0gU2hhcGVVdGlsLmFyZUVxdWFsKG5ld1Blcm0sIFszLCAxLCAyXSk7XG4gIGNvbnN0IHVzZVNoYXJlZCA9IChuZXdTaGFwZS5sZW5ndGggPT09IDIgJiYgbmV3UGVybVswXSA+IG5ld1Blcm1bMV0pIHx8IGNoYW5uZWxzTGFzdCB8fCBjaGFubmVsc0ZpcnN0O1xuICBsZXQgbmV3SW5wdXRTaGFwZSA9IHVzZVNoYXJlZCA/IG5ld1NoYXBlIDogaW5wdXRUZW5zb3IuZGltcztcbiAgbGV0IG5ld091dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gIGlmICh1c2VTaGFyZWQpIHtcbiAgICBuZXdJbnB1dFNoYXBlID0gY2hhbm5lbHNMYXN0XG4gICAgICA/IFtuZXdTaGFwZVswXSwgbmV3U2hhcGVbMV0gKiBuZXdTaGFwZVsyXV1cbiAgICAgIDogY2hhbm5lbHNGaXJzdFxuICAgICAgICA/IFtuZXdTaGFwZVswXSAqIG5ld1NoYXBlWzFdLCBuZXdTaGFwZVsyXV1cbiAgICAgICAgOiBuZXdTaGFwZTtcbiAgICBuZXdPdXRwdXRTaGFwZSA9IFtuZXdJbnB1dFNoYXBlWzFdLCBuZXdJbnB1dFNoYXBlWzBdXTtcbiAgfVxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCBuZXdJbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBuZXdPdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCB0aWxlU2l6ZSA9IDE2O1xuICBsZXQgZ2V0U2hhZGVyU291cmNlO1xuICBpZiAodXNlU2hhcmVkKSB7XG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3RpbGVTaXplICsgMX0+LCAke3RpbGVTaXplfT47XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbdGlsZVNpemUsIHRpbGVTaXplLCAxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7dGlsZVNpemV9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtpbnB1dC5nZXRCeUluZGljZXMoYCR7aW5wdXQudHlwZS5pbmRpY2VzfShpbnB1dF9yb3csIGlucHV0X2NvbClgKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcyhgJHtvdXRwdXQudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsICd0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldJyl9XG4gICAgfVxuICB9YDtcbiAgfSBlbHNlIHtcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCBpbnB1dFJhbmssIGlucHV0LCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJykpfVxuICB9YDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHVzZVNoYXJlZCA/ICdUcmFuc3Bvc2VTaGFyZWQnIDogJ1RyYW5zcG9zZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7cGVybUF0dHJ9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHVzZVNoYXJlZFxuICAgICAgICAgID8geyB4OiBNYXRoLmNlaWwobmV3T3V0cHV0U2hhcGVbMV0gLyB0aWxlU2l6ZSksIHk6IE1hdGguY2VpbChuZXdPdXRwdXRTaGFwZVswXSAvIHRpbGVTaXplKSB9XG4gICAgICAgICAgOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMobmV3SW5wdXRTaGFwZSwgbmV3T3V0cHV0U2hhcGUpLFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybTogYXR0cmlidXRlcy5wZXJtIGFzIG51bWJlcltdIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzLCBSZWR1Y2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9yZWR1Y2UnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IHJlZHVjZU9wczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcbiAgbWluOiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpJyxcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUgKiBjYW5kaWRhdGUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKScsXG4gIGwxOiAnYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSknLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG59O1xuXG5jb25zdCByZWR1Y2VTaGFyZWRPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDE6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG59O1xuXG5jb25zdCByZWR1Y2VJbml0VmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICBtYXg6ICdfQVtvZmZzZXRdJyxcbiAgbWluOiAnX0Fbb2Zmc2V0XScsXG4gIG1lYW46ICcwJyxcbiAgc3VtOiAnMCcsXG4gIHByb2Q6ICcxJyxcbiAgc3VtU3F1YXJlOiAnMCcsXG4gIGxvZ1N1bUV4cDogJzAnLFxuICBsMTogJzAnLFxuICBsMjogJzAnLFxuICBsb2dTdW06ICcwJyxcbn07XG5cbmNvbnN0IHJlZHVjZU91dHB1dFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnYmVzdFZhbHVlJyxcbiAgbWluOiAnYmVzdFZhbHVlJyxcbiAgc3VtOiAnYmVzdFZhbHVlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZScsXG4gIGxvZ1N1bUV4cDogJ2xvZyhiZXN0VmFsdWUpJyxcbiAgbDE6ICdiZXN0VmFsdWUnLFxuICBsMjogJ3NxcnQoYmVzdFZhbHVlKScsXG4gIGxvZ1N1bTogJ2xvZyhiZXN0VmFsdWUpJyxcbn07XG5cbmNvbnN0IGdldElubmVyTW9zdEF4ZXMgPSAobnVtSW5uZXJBeGVzOiBudW1iZXIsIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSByYW5rIC0gbnVtSW5uZXJBeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmVzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IFtudW1iZXJbXSwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbXTtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKHNoYXBlW2RpbV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKChkaW0pID0+IHNoYXBlW2RpbV0pO1xuICByZXR1cm4gW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV07XG59O1xuXG5jb25zdCBleHBhbmRTaGFwZVRvS2VlcERpbSA9IChzaGFwZTogbnVtYmVyW10sIGF4ZXM6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoICsgYXhlcy5sZW5ndGg7XG4gIGNvbnN0IGV4cGFuZFNoYXBlID0gW107XG4gIGxldCBzaGFwZUlkeCA9IDA7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgZXhwYW5kU2hhcGUucHVzaChzaGFwZVtzaGFwZUlkeCsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBhbmRTaGFwZTtcbn07XG5cbmNvbnN0IGFyZUF4ZXNJbm5lck1vc3REaW1zID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEF4ZXNQZXJtdXRhdGlvbiA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgaWYgKCFhcmVBeGVzSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXhlcy5mb3JFYWNoKChheGlzKSA9PiByZXMucHVzaChheGlzKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBzaGFkZXJDYWNoZTogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIHJlZHVjZVR5cGU6IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IERhdGFUeXBlLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gIHJlZHVjZVNoYXBlOiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHJlZHVjZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShyZWR1Y2VTaGFwZSk7XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdfQScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSAzMjtcblxuICBjb25zdCBzaGFyZWRNZW1vcnlTbmlwcGV0ID0gYFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8ZjMyLCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgICBgO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3JlZHVjZVNpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFyZWRNZW1vcnlTbmlwcGV0fVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtyZWR1Y2VJbml0VmFsdWVzW3JlZHVjZVR5cGVdfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke3dvcmtncm91cFNpemV9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHtpbnB1dC5nZXRCeU9mZnNldCgnb2Zmc2V0ICsgaycpfSk7XG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlT3BzW3JlZHVjZVR5cGVdfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHt3b3JrZ3JvdXBTaXplfXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlU2hhcmVkT3BzW3JlZHVjZVR5cGVdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICdvdXRwdXRJbmRleCcsXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgcmVkdWNlVHlwZSA9PT0gJ21lYW4nXG4gICAgICAgICAgICAgICAgPyBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYFxuICAgICAgICAgICAgICAgIDogYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oJHtyZWR1Y2VPdXRwdXRWYWx1ZXNbcmVkdWNlVHlwZV19KWBcbiAgICAgICAgICAgIH1gLFxuICAgICAgICAgICl9O1xuICAgICAgICAgfVxuICAgICAgICB9YDtcblxuICAvLyBPbmUgd29yayBncm91cCBpcyByZXNwb25zaWJsZSBmb3Igb25seSBvbmUgZWxlbWVudCBvZiBvdXRwdXQuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG91dHB1dFNpemUgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZWR1Y2VTaXplIH1dLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgcmVkdWNlQ29tbW9uID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgbmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICByZWR1Y2VUeXBlOiAnc3VtJyB8ICdzdW1TcXVhcmUnIHwgJ3Byb2QnIHwgJ21pbicgfCAnbWF4JyB8ICdtZWFuJyB8ICdsb2dTdW1FeHAnIHwgJ2wxJyB8ICdsMicgfCAnbG9nU3VtJyxcbik6IHZvaWQgPT4ge1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICBsZXQgdXBkYXRlZEF4ZXMgPSB1cGRhdGVkQXR0cmlidXRlcy5heGVzO1xuICBpZiAodXBkYXRlZEF4ZXMubGVuZ3RoID09PSAwICYmICF1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykge1xuICAgIHVwZGF0ZWRBeGVzID0gY29udGV4dC5pbnB1dHNbMF0uZGltcy5tYXAoKF9kaW0sIGkpID0+IGkpO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZUF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyh1cGRhdGVkQXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuXG4gIGxldCBheGVzID0gbm9ybWFsaXplQXhlcztcbiAgbGV0IGlucHV0ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IHBlcm11dGVkQXhlcyA9IGdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGlmIChwZXJtdXRlZEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGlucHV0ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBwZXJtdXRlZEF4ZXMpLCB7XG4gICAgICBpbnB1dHM6IFswXSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gICAgYXhlcyA9IGdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5kaW1zLCBheGVzKTtcbiAgbGV0IGZpbmFsT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgaWYgKHVwZGF0ZWRBdHRyaWJ1dGVzLmtlZXBEaW1zKSB7XG4gICAgZmluYWxPdXRwdXRTaGFwZSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltKG91dHB1dFNoYXBlLCBub3JtYWxpemVBeGVzKTtcbiAgfVxuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyhcbiAgICAgIG5hbWUsXG4gICAgICB7IGhpbnQ6IHVwZGF0ZWRBdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcbiAgICAgIFtpbnB1dF0sXG4gICAgICByZWR1Y2VUeXBlLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBmaW5hbE91dHB1dFNoYXBlLFxuICAgICAgcmVkdWNlU2hhcGUsXG4gICAgKSxcbiAgICB7IGlucHV0czogW2lucHV0XSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW5TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNZWFuU2hhcmVkJywgYXR0cmlidXRlcywgJ21lYW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwxU2hhcmVkJywgYXR0cmlidXRlcywgJ2wxJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDJTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMlNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW1FeHAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXhTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNYXhTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWF4Jyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWluU2hhcmVkJywgYXR0cmlidXRlcywgJ21pbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2RTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VQcm9kU2hhcmVkJywgYXR0cmlidXRlcywgJ3Byb2QnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU3F1YXJlU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU3F1YXJlU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bVNxdWFyZScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW0nKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIHJlZHVjZUwxU2hhcmVkLFxuICByZWR1Y2VMMlNoYXJlZCxcbiAgcmVkdWNlTG9nU3VtRXhwU2hhcmVkLFxuICByZWR1Y2VMb2dTdW1TaGFyZWQsXG4gIHJlZHVjZU1heFNoYXJlZCxcbiAgcmVkdWNlTWVhblNoYXJlZCxcbiAgcmVkdWNlTWluU2hhcmVkLFxuICByZWR1Y2VQcm9kU2hhcmVkLFxuICByZWR1Y2VTdW1TaGFyZWQsXG4gIHJlZHVjZVN1bVNxdWFyZVNoYXJlZCxcbn0gZnJvbSAnLi9yZWR1Y2Utc2hhcmVkJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMiAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhlcyBpbnB1dCBkaW1zLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlZHVjZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW47XG4gIGF4ZXM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VPcCA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sXG4pID0+IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIC4uLnN0cmluZ1tdXTtcblxuY29uc3Qgbm9PcDogUmVkdWNlT3AgPSAoaW5wdXQpID0+IFsnJywgJycsIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLCAnJ107XG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgc2hhZGVyQ2FjaGU6IFByb2dyYW1TaGFkZXJDYWNoZUluZm8sXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICByZWR1Y2VPcDogUmVkdWNlT3AsXG4gIGF4ZXNJbnB1dDogbnVtYmVyW10sXG4gIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSxcbiAga2VlcERpbXMgPSBmYWxzZSxcbiAgbm9vcFdpdGhFbXB0eUF4ZXMgPSBmYWxzZSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzSW5wdXQsIGlucHV0UmFuayk7XG4gIGNvbnN0IHJlZHVjZU9uQWxsQXhlcyA9ICFub29wV2l0aEVtcHR5QXhlcyAmJiBheGVzLmxlbmd0aCA9PT0gMDtcbiAgaW5wdXRTaGFwZS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaSkgPj0gMCkge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XG4gICAgICB9IC8vIGVsc2UgeyAvLyBza2lwIHRoaXMgYXhpc31cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0U2hhcGUucHVzaChkKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdOyAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuayk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dCwgb3V0cHV0LCBheGVzKTtcbiAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzJdO1xuXG4gICAgZm9yIChsZXQgayA9IDAsIGwgPSAwOyBrIDwgaW5wdXRSYW5rOyBrKyspIHtcbiAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgIGwrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGQtdGggYXhpc1xuICAgICAgICByZWR1Y2VPcHMgPSBgZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke2lucHV0U2hhcGVba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke29wc1syXS5pbmNsdWRlcygnbGFzdF9pbmRleCcpID8gYGxldCBsYXN0X2luZGV4ID0gaiR7a307YCA6ICcnfVxuICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeENvcHkucHVzaChgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgbCkpfTtgKTtcbiAgICAgICAgbCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAgICR7b3BzWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke29wc1sxXX1cbiAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAke29wc1szXX1cbiAgICAgICAgICAke29wcy5sZW5ndGggPT09IDQgPyBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKSA6IG9wcy5zbGljZSg0KS5qb2luKCdcXG4nKX1cbiAgICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFJlZHVjZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBheGVzOiBudW1iZXJbXSA9IFtdO1xuICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBheGVzLnB1c2goTnVtYmVyKHYpKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYXhlcyxcbiAgICBrZWVwRGltczogYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICBub29wV2l0aEVtcHR5QXhlczogYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyxcbiAgfSk7XG59O1xuXG5jb25zdCBydW5SZWR1Y2VQcm9ncmFtID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgbmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICByZWR1Y2VPcDogUmVkdWNlT3AsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cbiAgICBpbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxuICAgICAgbmFtZSxcbiAgICAgIHsgaGludDogdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgICAgW2lucHV0c1swXV0sXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyAmJiB1cGRhdGVkQXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCA/IG5vT3AgOiByZWR1Y2VPcCxcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXMsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuY29uc3QgcmVkdWNlTG9nU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VMMU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSBhYnMoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwxJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDJOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB0ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO2AsXG4gICAgJycsXG4gICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFxuICAgICd2YWx1ZSA9IHNxcnQodmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwyJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTG9nU3VtRXhwTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9IGV4cCgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1heE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgYHZhbHVlID0gbWF4KHZhbHVlLCAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICcnLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1heCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1lYW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgbGV0IHNpemUgPSAxLjA7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRlcGVuZHMgb24gdGhlIGlucHV0IGRpbXMuIElmIHdlIHdhbnQgdG8gdXNlIHVuaWZvcm0sIHRoaXMgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAgICBzaXplICo9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICd2YXIgc3VtID0gZjMyKDApOycsXG4gICAgICAnJyxcbiAgICAgIGBzdW0gKz0gZjMyKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgYGxldCB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHN1bSAvICR7c2l6ZX0pO2AsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWVhbicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1pbk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNaW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VQcm9kTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDEpO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICo9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVByb2QnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdmFsdWUgKz0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtU3F1YXJlTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICcnLFxuICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9IHQgKiB0O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHVzZU5haXZlUmVkdWNlTWV0aG9kID0gKFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbixcbik6IGJvb2xlYW4gPT4ge1xuICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9vcFdpdGhFbXB0eUF4ZXM7XG4gIH1cblxuICBsZXQgb3V0cHV0U2l6ZSA9IDE7XG4gIGxldCByZWR1Y2VTaXplID0gMTtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgYXhlcy5sZW5ndGg7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgb3V0cHV0U2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VTaXplICo9IHNoYXBlW2RpbV07XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIGNvbmRpdGlvbiBkYXRhIGlzIHZlcnkgcm91Z2gsIGFsdGhvdWdoIGNvbnNpZGVyaW5nIHRoZSBjb3VudCBvZiBFeGVjdXRpb24gVW5pdCAoRVUpLCB0aGUgcG90ZW50aWFsXG4gIC8vIHdvcmsgZ3JvdXBzIGluIGEgRVUgYW5kIHRoZSBjb3VudHMgb2YgbG9vcHMgaW4gdGhlIG5haXZlIGFuZCBzaGFyZWQgbWV0aG9kcywgYWxzbyBkb2luZyBleHBlcmltZW50c1xuICAvLyBvbiBzb21lIG1hY2hpbmVzLlxuICByZXR1cm4gcmVkdWNlU2l6ZSA8IDMyICYmIG91dHB1dFNpemUgPiAxMDI0O1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNZWFuTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTWVhblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwxID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDFOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDJOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMlNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bUV4cE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1heE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1heFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1pbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1pblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VQcm9kTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlUHJvZFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bVNxdWFyZU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNxdWFyZVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXG4vLyBhIG9wdGltaXplZCBjb2RlcGF0aCBmb3IgdGhpcy5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvLCBSZWR1Y2VPcCB9IGZyb20gJy4vcmVkdWNlJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ01pbk1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBzZWxlY3RMYXN0SW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ01pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc8PScgOiAnPCd9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLFxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICdBcmdNaW4nLFxuICAgICAgeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgICBhcmdNaW5NYXhPcCxcbiAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLFxuICAgICAgRGF0YVR5cGUuaW50NjQsXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGFyZ01heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc+PScgOiAnPid9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLFxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICdhcmdNYXgnLFxuICAgICAgeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgICBhcmdNaW5NYXhPcCxcbiAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLFxuICAgICAgRGF0YVR5cGUuaW50NjQsXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXJnTWluTWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFyZ01pbk1heEF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxBcmdNaW5NYXhBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25Ra3ZGb3JtYXQge1xuICB1bmtub3duLCAvLyBlbnVtIHZhbHVlIG5vdCBzZXQsIG9yIGRlcGVuZHMgb24gcWt2IHByb2plY3Rpb24gaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICBxa3ZCTlNILCAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIHBlcm11dGVkXG4gIHFrdkJTTkgsIC8vIGZvciBub24tcGFja2VkIHFrdiwgbm90IHBlcm11dGVkLCB1c2VkIGJ5IG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uIG9yIE11bHRpSGVhZEF0dGVudGlvblxuICBxa3ZCU04zSCwgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkXG4gIHFrdkJOU0hxa3ZCUzNOSCwgLy8gZm9yIFRSVCBmdXNlZCBjYXVzYWwgYXR0ZW50aW9uLCBkYXRhIGhhcyB0d28gZm9ybWF0cyAocWt2IGlzIDNCTlNILCBnZW1tX2J1ZmZlciBpcyBCUzNOSClcbiAgcUt2QlNOSHhCU04ySCwgLy8gZm9yIFRSVCBmdXNlZCBjcm9zcyBhdHRlbnRpb24sIGt2IGFyZSBwYWNrZWRcbiAgcWt2VE5ILCAvLyBmb3IgbWVtb3J5IGVmZmljaWVudCBhdHRlbnRpb24sIHFrdiBhcmUgbm90IHBhY2tlZCwgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkLlxuICBxa3ZUTjNILCAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWQgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvbk1hc2tUeXBlIHtcbiAgbm9uZSwgLy8gTm8gbWFza1xuICBtYXNrMWRLZXlTZXFMZW4sIC8vIFtiYXRjaF9zaXplXSwga2V5IHNlcXVlbmNlIGxlbmd0aFxuICBtYXNrMWRFbmRTdGFydCwgLy8gWzIgKiBiYXRjaF9zaXplXSB3aXRoIGVuZCBwb3NpdGlvbnMgYW5kIHN0YXJ0IHBvc2l0aW9uc1xuICBtYXNrMURLZXlTZXFMZW5TdGFydCwgLy8gWzMgKiBiYXRjaF9zaXplICsgMl0gd2l0aCBba2V5X2xlblswXSwgLi4uLCBrZXlfbGVuW2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfc3RhcnRbMF0sXG4gIC8vIC4uLiwgcXVlcnlfc3RhcnRbYmF0Y2hfc2l6ZSAtIDFdLCBxdWVyeV9lbmRbYmF0Y2hfc2l6ZSAtIDFdLCBrZXlfc3RhcnRbMF0sIC4uLixcbiAgLy8ga2V5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwga2V5X2VuZFtiYXRjaF9zaXplIC0gMV1dXG4gIG1hc2syZER1bW15LCAvLyBkdW1teSBtYXNrIHdpdGggc2hhcGUgWzEsIDFdIG9yIFtiYXRjaF9zaXplLCAxXS4gSXQgaGFzIHNhbWUgZWZmZWN0IGFzIG5vIG1hc2suXG4gIG1hc2syZEtleVBhZGRpbmcsIC8vIFtiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2szZEF0dGVudGlvbiwgLy8gW2JhdGNoX3NpemUsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrNGRNZWdhdHJvbiwgLy8gTWVnYXRyb24gY2F1c2FsIG1hc2sgd2l0aCBzaGFwZSBbYmF0Y2hfc2l6ZSwgMSwgbWF4X3NlcXVlbmNlX2xlbmd0aCwgbWF4X3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFza1Vua25vd24sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uUGFyYW1ldGVycyB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAga3ZTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICB0b3RhbFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIG1heFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGlucHV0SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoaWRkZW5TaXplOiBudW1iZXI7XG4gIHZIaWRkZW5TaXplOiBudW1iZXI7XG4gIGhlYWRTaXplOiBudW1iZXI7XG4gIHZIZWFkU2l6ZTogbnVtYmVyO1xuICBudW1IZWFkczogbnVtYmVyO1xuICBrdk51bUhlYWRzPzogbnVtYmVyO1xuICBuUmVwcz86IG51bWJlcjtcbiAgaXNVbmlkaXJlY3Rpb25hbD86IGJvb2xlYW47XG4gIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGJvb2xlYW47XG4gIG1hc2tGaWx0ZXJWYWx1ZT86IG51bWJlcjtcbiAgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlO1xuICBzY2FsZTogbnVtYmVyO1xuICBicm9hZGNhc3RSZXNQb3NCaWFzOiBib29sZWFuO1xuICBwYXNzUGFzdEluS3Y6IGJvb2xlYW47XG4gIHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBzb2Z0Y2FwPzogbnVtYmVyO1xuICBkb1JvdGFyeT86IG51bWJlcjtcbiAgcm90YXJ5SW50ZXJMZWF2ZWQ/OiBudW1iZXI7XG4gIHNvbW1vb3RoU29mdG1heD86IG51bWJlcjtcbiAgbG9jYWxXaW5kb3dzU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25BdHRycyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw6IG51bWJlcjtcbiAgbWFza0ZpbHRlclZhbHVlOiBudW1iZXI7XG4gIHNjYWxlOiBudW1iZXI7XG4gIGRvUm90YXJ5OiBudW1iZXI7XG4gIHFrdkhpZGRlblNpemVzOiBudW1iZXJbXTtcbiAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogYm9vbGVhbjtcbn1cblxuY29uc3QgdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vIFdoZW4gcGFzdCBzdGF0ZSBpcyB1c2VkLCBRLCBLIGFuZCBWIHNob3VsZCBoYXZlIHNhbWUgaGlkZGVuIHNpemUgKHVubGVzcyB3ZSBzcGxpdCBpdCBpbnRvIHBhc3Rfa2V5IGFuZCBwYXN0X3ZhbHVlKS5cblxuICAvLyBJbnB1dCBzaGFwZXM6XG4gIC8vICAgaW5wdXQgICAgICAgIChRL0svVikgICAgOiAoQiwgUywgRF9pKVxuICAvLyAgIHdlaWdodHMgICAgICAoUS9LL1YpICAgIDogKERfaSwgRCArIEQgKyBEX3YpXG4gIC8vICAgYmlhcyAgICAgICAgIChRL0svVikgICAgOiAoRCArIEQgKyBEX3YpXG4gIC8vICAgbWFza19pbmRleCAgICAgICAgICAgICAgOiBzZWUgYmVsb3dcbiAgLy8gICBwYXN0ICAgICAgICAgKEsvVikgICAgICA6ICgyLCBCLCBOLCBQLCBIKSBvciBOVUxMXG4gIC8vICAgYXR0ZW50aW9uX2JpYXMgICAgICAgICAgOiAoQiwgTiwgUywgVCkgb3IgTlVMTFxuXG4gIC8vIEZvciBtYXNrX2luZGV4LCB0aGUgZm9sbG93aW5nIHNoYXBlcyBhcmUgc3VwcG9ydGVkOlxuICAvLyAgICAgTlVMTCwgKEIsIDEpLCAoMSwgMSlcbiAgLy8gICAgIChCKSwgKDIgKiBCKSwgKDMgKiBCICsgMilcbiAgLy8gICAgIChCLCBUKVxuICAvLyAgICAgKEIsIFMsIFQpXG4gIC8vICAgICAoQiwgMSwgTSwgTSlcbiAgLy9cbiAgLy8gV2hlbiBhIG1vZGVsIGlzIHBydW5lZCAobGlrZSBzb21lIGF0dGVudGlvbiBoZWFkcyBhcmUgcmVtb3ZlZCBpbiBRL0svViksIGlucHV0X2hpZGRlbl9zaXplIGNvdWxkIGJlIGxhcmdlclxuICAvLyB0aGFuIGhpZGRlbiBkaW1lbnNpb24gb2YgUSwgSyBhbmQgVi5cblxuICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IGlucHV0c1sxXTtcbiAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcbiAgY29uc3QgbWFza0luZGV4ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0ID0gaW5wdXRzWzRdO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID0gaW5wdXRzWzVdO1xuXG4gIGlmIChwYXN0ICYmIGF0dGVudGlvbkJpYXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzJyk7XG4gIH1cblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dC5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbMV07XG4gIGNvbnN0IGlucHV0SGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbMl07XG5cbiAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAod2VpZ2h0cy5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICh3ZWlnaHRzLmRpbXNbMF0gIT09IGlucHV0SGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgMSBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMiBvZiBpbnB1dCAwJyk7XG4gIH1cblxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSB3ZWlnaHRzLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAxIG9mIGlucHV0IFwid2VpZ2h0c1wiJyk7XG4gIH1cblxuICBsZXQgcUhpZGRlblNpemUgPSBiaWFzLmRpbXNbMF0gLyAzO1xuICBsZXQga0hpZGRlblNpemUgPSBxSGlkZGVuU2l6ZTtcbiAgbGV0IHZIaWRkZW5TaXplID0ga0hpZGRlblNpemU7XG4gIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50cycpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN6IG9mIGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMpIHtcbiAgICAgIGlmIChzeiAlIGF0dHJpYnV0ZXMubnVtSGVhZHMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcUhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzBdO1xuICAgIGtIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1sxXTtcbiAgICB2SGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMl07XG4gIH1cblxuICBjb25zdCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgaWYgKHFIaWRkZW5TaXplICE9PSBrSGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmQnKTtcbiAgfVxuXG4gIGlmIChiaWFzLmRpbXNbMF0gIT09IHFIaWRkZW5TaXplICsga0hpZGRlblNpemUgKyB2SGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO1xuICB9XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGlmIChwYXN0KSB7XG4gICAgaWYgKGtIaWRkZW5TaXplICE9PSB2SGlkZGVuU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1swXSAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaXJzdCBkaW1lbnNpb24gbXVzdCBiZSAyJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMV0gIT09IGJhdGNoU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHRoaXJkIGRpbWVuc2lvbiBtdXN0IGJlIG51bV9oZWFkcycpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzRdICE9PSBrSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO1xuICAgIH1cblxuICAgIGlmICghYXR0cmlidXRlcy5wYXN0UHJlc2VudFNoYXJlQnVmZmVyKSB7XG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0LmRpbXNbM107XG4gICAgfVxuICAgIC8vIFRPRE86IGhhbmRsZSBwYXN0X3NlcV9sZW5cbiAgfVxuXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBrdlNlcXVlbmNlTGVuZ3RoICsgcGFzdFNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IC0xO1xuXG4gIGNvbnN0IG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgaWYgKG1hc2tJbmRleCkge1xuICAgIC8vIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUuTUFTS19VTktOT1dOO1xuICAgIC8vIFRPRE86IGhhbmRsZSBtYXNrXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXNrIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChwYXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XG4gICAgaWYgKGF0dGVudGlvbkJpYXMuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIG11c3QgaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGJyb2FkY2FzdGluZyB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zIG9mIGF0dGVudGlvbl9iaWFzXG4gICAgaWYgKFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemUsXG4gICAgaGlkZGVuU2l6ZTogcUhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemU6IE1hdGguZmxvb3IocUhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXM6IGZhbHNlLFxuICAgIHBhc3NQYXN0SW5LdjogZmFsc2UsXG4gICAgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSCxcbiAgfTtcbn07XG5cbmNvbnN0IGluaXRWYXJTdHViID0gKFxuICBzZXFMZW5zSW5wdXQ6IEluZGljZXNIZWxwZXIgfCB1bmRlZmluZWQsXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogSW5kaWNlc0hlbHBlciB8IHVuZGVmaW5lZCxcbiAgaW5pdFBhc3RTZXF1ZW5jZUxlbmd0aDogYm9vbGVhbixcbikgPT4ge1xuICAvLyBJbiB0aGUgY2FzZSBvZiBHUUEsIHJlZGVmaW5lIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggYW5kIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIGJhc2VkIG9uIHNlcWxlbl9rIGlucHV0XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgJiYgc2VxTGVuc0lucHV0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZ2V0QnlPZmZzZXQoJzAnKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtzZXFMZW5zSW5wdXQ/LmdldEJ5T2Zmc2V0KCdiYXRjaElkeCcpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgJHtpbml0UGFzdFNlcXVlbmNlTGVuZ3RoID8gJ2xldCBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoJyA6ICcnfTtcbiAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgYDtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBudW1IZWFkczogbnVtYmVyLFxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgLy8gU2V0IGNvbXBvbmVudHMgdG8gMSBpZiBzZXFMZW5zIGlzIHNwZWNpZmllZCwgaS5lLiBHcm91cFF1ZXJ5QXR0ZW50aW9uLlxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhzZXFMZW5zID8gMSA6IHRvdGFsU2VxdWVuY2VMZW5ndGgpO1xuICBsZXQgV0cgPSA2NDtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aENvbXAgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gY29tcG9uZW50cztcbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wIDwgV0cpIHtcbiAgICBXRyA9IDMyO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gTWF0aC5jZWlsKHRvdGFsU2VxdWVuY2VMZW5ndGggLyBjb21wb25lbnRzIC8gV0cpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJhdGNoU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aENvbXAgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWxlbWVudHNQZXJUaHJlYWQgfSxcbiAgXTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXQuZGF0YVR5cGUsIGNvbXBvbmVudHMpO1xuICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJ107XG4gIGlmIChzZXFMZW5zKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dEhlbHBlcnMgPSBbaW5wdXRIZWxwZXJdO1xuICAgIGNvbnN0IHNlcUxlbnNJbnB1dEhlbHBlciA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcUxlbnNJbnB1dEhlbHBlcikge1xuICAgICAgaW5wdXRIZWxwZXJzLnB1c2goc2VxTGVuc0lucHV0SGVscGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIpIHtcbiAgICAgIGlucHV0SGVscGVycy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dEhlbHBlcik7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1WYWx1ZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGlucHV0LmRhdGFUeXBlKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdiYXRjaF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAndG90YWxfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2VsZW1lbnRzX3Blcl90aHJlYWQnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7V0d9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke1dHfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRIZWxwZXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtXRywgMSwgMV0pfVxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0SGVscGVyLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIsIGZhbHNlKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gKGdsb2JhbF9pZHggLyAke1dHfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHtzZXFMZW5zID8gJ3UzMihwYXN0X3NlcXVlbmNlX2xlbmd0aCArIHdvcmtncm91cF9pZC55ICsgMSknIDogJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aCd9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7ZjMyVHlwZX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpID0+IHtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuICd0aHJlYWRfbWF4X3ZlY3Rvcic7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gJ21heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gJ21heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bV92ZWN0b3IgKz0gZXhwKCR7ZjMyVHlwZX0oeFtvZmZzZXQgKyBpXSkgLSBtYXhfdmFsdWUpO1xuICAgIH1cbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvcic7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iudyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICB9XG4gICAgfSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBzdW0gKz0gdGhyZWFkX3N1bVtpXTtcbiAgICB9XG5cbiAgICBpZiAoc3VtID09IDApIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KCR7ZWxlbVZhbHVlVHlwZX0oMS4wKSAvICR7ZWxlbVZhbHVlVHlwZX0oc2VxX2NhdXNhbF9sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHtmMzJUeXBlfSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHtcbiAgICAgICAgc2VxTGVuc1xuICAgICAgICAgID8gYFxuICAgICAgICBmb3IgKHZhciB0b3RhbF9zZXFfaWQ6IHUzMiA9IHNlcV9jYXVzYWxfbGVuZ3RoOyB0b3RhbF9zZXFfaWQgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IHRvdGFsX3NlcV9pZCsrKSB7XG4gICAgICAgICAgeFtvZmZzZXQgKyB0b3RhbF9zZXFfaWRdID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfSgke2VsZW1WYWx1ZVR5cGV9KDApKTtcbiAgICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9O1xuICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9ic1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke1dHfTske2RhdGFUeXBlfTske2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwodG90YWxTZXF1ZW5jZUxlbmd0aCAvIFdHKSwgeTogc2VxdWVuY2VMZW5ndGgsIHo6IGJhdGNoU2l6ZSAqIG51bUhlYWRzIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvID0gKFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBxOiBUZW5zb3JWaWV3LFxuICBrZXk6IFRlbnNvclZpZXcsXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIGF0dGVudGlvbkJpYXM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgcHJvYnNTaGFwZSA9IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCwgdG90YWxTZXF1ZW5jZUxlbmd0aF07XG4gIGNvbnN0IHByZXNlbnRLZXkgPSBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleTtcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA/IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA6IHBhcmFtZXRlcnMubnVtSGVhZHM7XG4gIGNvbnN0IHByZXNlbnRLZXlTaGFwZSA9IHByZXNlbnRLZXlcbiAgICA/IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV1cbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3QgblJlcHMgPSBwYXJhbWV0ZXJzLm5SZXBzID8gcGFyYW1ldGVycy5uUmVwcyA6IDE7XG4gIC8vIFRPRE86IGhhbmRsZSBtYXNrXG5cbiAgY29uc3QgYWxwaGEgPSBwYXJhbWV0ZXJzLnNjYWxlID09PSAwID8gMS4wIC8gTWF0aC5zcXJ0KHBhcmFtZXRlcnMuaGVhZFNpemUpIDogcGFyYW1ldGVycy5zY2FsZTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMocGFyYW1ldGVycy5oZWFkU2l6ZSk7XG4gIGNvbnN0IHZlY3Rvcml6ZWRIZWFkU2l6ZSA9IHBhcmFtZXRlcnMuaGVhZFNpemUgLyBjb21wb25lbnRzO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHRvdGFsU2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gIH07XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB2ZWN0b3JpemVkSGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhbHBoYSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5SZXBzIH0sXG4gIF07XG4gIC8vIEZlZWQgcGFzdEtleSB0byB0aGUgc2hhZGVyLWNvZGUgb25seSBpZiBpdCBpcyBub24temVybyBhbmQgcHJlc2VudEtleSBpcyBiZWluZyBwcm9kdWNlZFxuICBjb25zdCBmZWVkUGFzdEtleSA9IHByZXNlbnRLZXkgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoZmVlZFBhc3RLZXkpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHNlcUxlbnMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogcHJvYnNTaGFwZSwgZGF0YVR5cGU6IHEuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH1dO1xuICBpZiAocHJlc2VudEtleSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRLZXlTaGFwZSEsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcbiAgfVxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBxSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxJywgcS5kYXRhVHlwZSwgcS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBrSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdrZXknLCBrZXkuZGF0YVR5cGUsIGtleS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcUlucHV0LCBrSW5wdXRdO1xuICAgIGlmIChmZWVkUGFzdEtleSkge1xuICAgICAgY29uc3QgcGFzdEtleUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncGFzdF9rZXknLCBwYXN0S2V5LmRhdGFUeXBlLCBwYXN0S2V5LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgaW5wdXRWYXJzLnB1c2gocGFzdEtleUlucHV0KTtcbiAgICB9XG4gICAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ2F0dGVudGlvbl9iaWFzJywgYXR0ZW50aW9uQmlhcy5kYXRhVHlwZSwgYXR0ZW50aW9uQmlhcy5kaW1zKSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcUxlbnNJbnB1dFZhcmlhYmxlID0gc2VxTGVucyA/IGlucHV0VmFyaWFibGUoJ3NlcV9sZW5zJywgc2VxTGVucy5kYXRhVHlwZSwgc2VxTGVucy5kaW1zKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2VxTGVuc0lucHV0VmFyaWFibGUpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKHNlcUxlbnNJbnB1dFZhcmlhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSkge1xuICAgICAgaW5wdXRWYXJzLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcS5kYXRhVHlwZSwgcHJvYnNTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgIGlmIChwcmVzZW50S2V5KSB7XG4gICAgICBvdXRwdXRWYXJzLnB1c2gob3V0cHV0VmFyaWFibGUoJ3ByZXNlbnRfa2V5JywgcS5kYXRhVHlwZSwgcHJlc2VudEtleVNoYXBlISwgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIC4uLm91dHB1dFZhcnMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xuICAgIGxldCBrdl9udW1faGVhZHMgPSAke25SZXBzID09PSAxID8gJ3VuaWZvcm1zLm51bV9oZWFkcycgOiAndW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzJ307XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cbiAgICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7XG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICAgJHtmZWVkUGFzdEtleSAmJiBwcmVzZW50S2V5ID8gJ2xldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LOycgOiAnJ307XG4gICAgbGV0IGtPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1xuICAgICR7cHJlc2VudEtleSA/ICdsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LOycgOiAnJ31cbiAgICB2YXIgdmFsdWUgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBpZiAoZmVlZFBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgIH1gO1xuICAgICAgICB9XG4gICAgICB9KSgpfVxuICAgICAgJHtcbiAgICAgICAgcHJlc2VudEtleVxuICAgICAgICAgID8gYGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YFxuICAgICAgICAgIDogJydcbiAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJHtmMzJUeXBlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSc7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53JztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke1xuICAgICAgICAgIGF0dGVudGlvbkJpYXMgPyAnYXR0ZW50aW9uX2JpYXNbb3V0cHV0SWR4XScgOiAnMC4wJ1xuICAgICAgICB9O1xuICAgIH1cbiAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblByb2JzJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHthdHRlbnRpb25CaWFzICE9PSB1bmRlZmluZWR9OyR7cGFzdEtleSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXMgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvID0gKFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBwcm9iczogVGVuc29yVmlldyxcbiAgdjogVGVuc29yVmlldyxcbiAgcGFzdFZhbHVlOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pID0+IHtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyA/IHBhcmFtcy5uUmVwcyA6IDE7XG4gIGNvbnN0IHJlcGVhdGVkVkhpZGRlblNpemUgPSBwYXJhbXMudkhpZGRlblNpemUgKiBuUmVwcztcbiAgY29uc3QgcHJlc2VudFZhbHVlID0gb3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZTtcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtcy5rdk51bUhlYWRzID8gcGFyYW1zLmt2TnVtSGVhZHMgOiBwYXJhbXMubnVtSGVhZHM7XG4gIGNvbnN0IHByZXNlbnRWYWx1ZVNoYXBlID0gcHJlc2VudFZhbHVlXG4gICAgPyBbcGFyYW1zLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplXVxuICAgIDogdW5kZWZpbmVkO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHJlcGVhdGVkVkhpZGRlblNpemVdO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtcy52SGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbXMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHo6IHBhcmFtcy5iYXRjaFNpemUgKiBwYXJhbXMubnVtSGVhZHMsXG4gIH07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMudkhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVwZWF0ZWRWSGlkZGVuU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogblJlcHMgfSxcbiAgXTtcbiAgLy8gRmVlZCBwYXN0VmFsdWUgdG8gdGhlIHNoYWRlci1jb2RlIG9ubHkgaWYgaXQgaXMgbm9uLWVtcHR5IGFuZCBwcmVzZW50VmFsdWUgaXMgYmVpbmcgcHJvZHVjZWRcbiAgY29uc3QgZmVlZFBhc3RWYWx1ZSA9IHByZXNlbnRWYWx1ZSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoZmVlZFBhc3RWYWx1ZSkge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcbiAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRWYWx1ZVNoYXBlISwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcbiAgfVxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBwcm9ic0hlbHBlciA9IGlucHV0VmFyaWFibGUoJ3Byb2JzJywgcHJvYnMuZGF0YVR5cGUsIHByb2JzLmRpbXMpO1xuICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcHJvYnNIZWxwZXIsIHZIZWxwZXJdO1xuICAgIGlmIChmZWVkUGFzdFZhbHVlKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdwYXN0X3ZhbHVlJywgcGFzdFZhbHVlLmRhdGFUeXBlLCBwYXN0VmFsdWUuZGltcykpO1xuICAgIH1cbiAgICBjb25zdCBzZXFMZW5zSW5wdXRWYXJpYWJsZSA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcUxlbnMpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKHNlcUxlbnNJbnB1dFZhcmlhYmxlISk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XG4gICAgICA/IGlucHV0VmFyaWFibGUoJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCcsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kYXRhVHlwZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRpbXMpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgICBpbnB1dFZhcnMucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSEpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcHJvYnMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRWYXJzID0gW291dHB1dF07XG4gICAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X3ZhbHVlJywgcHJvYnMuZGF0YVR5cGUsIHByZXNlbnRWYWx1ZVNoYXBlISkpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3ZfaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtwcm9ic0hlbHBlci50eXBlLnZhbHVlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7blJlcHMgPT09IDEgPyAndW5pZm9ybXMubnVtX2hlYWRzJyA6ICd1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHMnfTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke2ZlZWRQYXN0VmFsdWUgJiYgcHJlc2VudFZhbHVlID8gJ2xldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuOycgOiAnJ307XG4gICBsZXQgdk9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKyBuO1xuICAgJHtwcmVzZW50VmFsdWUgPyAnbGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjsnIDogJyd9XG4gICB2YXIgdmFsdWUgPSAke3Byb2JzSGVscGVyLnR5cGUuc3RvcmFnZX0oMCk7XG4gICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHByb2JzW29mZnNldEEgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChmZWVkUGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgICAke1xuICAgICAgICAgIHByZXNlbnRWYWx1ZVxuICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZVZbaWR4XTtcbiAgICAgICAgfWBcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQXR0ZW50aW9uU2NvcmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3Bhc3RWYWx1ZSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3JtcyB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYXBwbHlBdHRlbnRpb24gPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBxOiBUZW5zb3JWaWV3LFxuICBrOiBUZW5zb3JWaWV3LFxuICB2OiBUZW5zb3JWaWV3LFxuICBfbWFza0luZGV4OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBfcGFzdDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFzdEtleTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFzdFZhbHVlOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBhdHRlbnRpb25CaWFzSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbikgPT4ge1xuICAvLyBBc3N1bXB0aW9uIGlzIHRoYXQgcHJlc2VudEtleS9wcmVzZW50VmFsdWUgZXhpc3RzIG9ubHkgaWYgcGFzdEtleS9wYXN0VmFsdWUgZXhpc3RzLlxuICBjb25zdCBvdXRwdXRDb3VudCA9IE1hdGgubWluKGNvbnRleHQub3V0cHV0Q291bnQsIDEgKyAocGFzdEtleSA/IDEgOiAwKSArIChwYXN0VmFsdWUgPyAxIDogMCkpO1xuICBjb25zdCBwYXN0U2VxdWVuY2VMZW5ndGggPSBvdXRwdXRDb3VudCA+IDEgPyBwYXJhbWV0ZXJzLnBhc3RTZXF1ZW5jZUxlbmd0aCA6IDA7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPVxuICAgIGF0dGVudGlvbkJpYXNJbnB1dCAmJiBTaGFwZVV0aWwuc2l6ZShhdHRlbnRpb25CaWFzSW5wdXQuZGltcykgPiAwID8gYXR0ZW50aW9uQmlhc0lucHV0IDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGlucHV0c0sgPSBbcSwga107XG4gIGlmIChvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMCkge1xuICAgIGlucHV0c0sucHVzaChwYXN0S2V5KTtcbiAgfVxuICBpZiAoYXR0ZW50aW9uQmlhcykge1xuICAgIGlucHV0c0sucHVzaChhdHRlbnRpb25CaWFzKTtcbiAgfVxuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0c0sucHVzaChzZXFMZW5zKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXRzSy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCk7XG4gIH1cbiAgLy8gUnVuIEF0dGVudGlvblByb2JzXG4gIGNvbnN0IHByb2JzID0gY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUF0dGVudGlvblByb2JzUHJvZ3JhbUluZm8oXG4gICAgICBvdXRwdXRDb3VudCxcbiAgICAgIHEsXG4gICAgICBrLFxuICAgICAgcGFzdEtleSxcbiAgICAgIGF0dGVudGlvbkJpYXMsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgc2VxTGVucyxcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBpbnB1dHNLLCBvdXRwdXRzOiBvdXRwdXRDb3VudCA+IDEgPyBbLTEsIDFdIDogWy0xXSB9LFxuICApWzBdO1xuXG4gIC8vIFJ1biBTb2Z0bWF4XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVJblBsYWNlU29mdG1heFByb2dyYW1JbmZvKFxuICAgICAgcHJvYnMsXG4gICAgICBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSxcbiAgICAgIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAgICBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICAgIHNlcUxlbnMsXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXG4gICAgKSxcbiAgICB7IGlucHV0czogc2VxTGVucyAmJiB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgPyBbcHJvYnMsIHNlcUxlbnMsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dF0gOiBbcHJvYnNdLCBvdXRwdXRzOiBbXSB9LFxuICApO1xuXG4gIC8vIFJ1biBBdHRlbnRpb25TY29yZVxuICBjb25zdCBpbnB1dHNWID0gW3Byb2JzLCB2XTtcbiAgaWYgKG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMCkge1xuICAgIGlucHV0c1YucHVzaChwYXN0VmFsdWUpO1xuICB9XG4gIGlmIChzZXFMZW5zKSB7XG4gICAgaW5wdXRzVi5wdXNoKHNlcUxlbnMpO1xuICB9XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcbiAgICBpbnB1dHNWLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvKFxuICAgICAgb3V0cHV0Q291bnQsXG4gICAgICBwcm9icyxcbiAgICAgIHYsXG4gICAgICBwYXN0VmFsdWUsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgc2VxTGVucyxcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcbiAgICApLFxuICAgIHtcbiAgICAgIGlucHV0czogaW5wdXRzVixcbiAgICAgIG91dHB1dHM6IG91dHB1dENvdW50ID4gMSA/IFswLCAyXSA6IFswXSxcbiAgICB9LFxuICApO1xufTtcblxuY29uc3QgcHJlcGFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcGFyYW1ldGVyczogQXR0ZW50aW9uUGFyYW1ldGVycykgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV07XG4gIGNvbnN0IE0gPSBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBLID0gcGFyYW1ldGVycy5pbnB1dEhpZGRlblNpemU7XG4gIGNvbnN0IE4gPSBwYXJhbWV0ZXJzLmhlYWRTaXplO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtZXRlcnMuaGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gIH07XG4gIGNvbnN0IGlucHV0cyA9IFtjb250ZXh0LmlucHV0c1swXSwgY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSArIHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSArIHBhcmFtZXRlcnMudkhpZGRlblNpemUgfSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXRRID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9xJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0SyA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfaycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFYgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X3YnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XG4gICAgY29uc3Qgd2VpZ2h0ID0gaW5wdXRWYXJpYWJsZSgnd2VpZ2h0JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUuc3RvcmFnZTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoZWFkX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbGRiJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHdlaWdodCwgYmlhcywgb3V0cHV0USwgb3V0cHV0Sywgb3V0cHV0Vil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke2RhdGFUeXBlfSgwKTtcbiAgICB2YXIgdmFsdWVLID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdBdHRlbnRpb25QcmVwYXJlJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxuICAgICAgICAgIHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHMsIG91dHB1dHM6IFstMSwgLTEsIC0xXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IFtxLCBrLCB2XSA9IHByZXBhcmUoY29udGV4dCwgcGFyYW1zKTtcblxuICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXG4gICAgY29udGV4dCxcbiAgICBxLFxuICAgIGssXG4gICAgdixcbiAgICBjb250ZXh0LmlucHV0c1s0XSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBjb250ZXh0LmlucHV0c1s1XSxcbiAgICBwYXJhbXMsXG4gICk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hOb3JtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9tZW50dW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BhdGlhbDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgdHJhaW5pbmdNb2RlOiBib29sZWFuO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XG4gIH1cblxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcbiAgICB9XG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IGRpbVske2l9XSBkbyBub3QgbWF0Y2hgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNoYXBlID1cbiAgICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQydcbiAgICAgICAgPyBhdHRyaWJ1dGVzLnNwYXRpYWxcbiAgICAgICAgICA/IGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKVxuICAgICAgICAgIDogaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSlcbiAgICAgICAgOiBpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBhdHRyaWJ1dGVzLnNwYXRpYWwgPyAyIDogdW5kZWZpbmVkKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzFdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBtZWFuJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1s0XS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1syXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmF0Y2hOb3JtSW5mZXJlbmNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB7IGVwc2lsb24sIHNwYXRpYWwsIGZvcm1hdCB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgeVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzcGF0aWFsID8gZ2V0TWF4Q29tcG9uZW50cyh5U2hhcGVbeVNoYXBlLmxlbmd0aCAtIDFdKSA6IDE7XG4gIGNvbnN0IGNDb21wb25lbnRzID0gZm9ybWF0ID09PSAnTkhXQycgJiYgeVNoYXBlLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzIDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHlTaGFwZSkgLyBjb21wb25lbnRzO1xuICAvLyBPbmx5IHN1cHBvcnQgdW5pZm9ybXMgZm9yIG9wc2V0IHZlcnNpb24gPj0gOSAoc3BhdGlhbCA9IHRydWUpLlxuICBjb25zdCB1c2VTaGFwZXNVbmlmb3JtcyA9IHNwYXRpYWw7XG4gIGNvbnN0IHNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyB5U2hhcGUubGVuZ3RoIDogeVNoYXBlO1xuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgaW5wdXRNZWFuID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRNZWFuJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhciA9IGlucHV0VmFyaWFibGUoJ2lucHV0VmFyJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBpbnB1dHMgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlLiBDdXJyZW50IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBpbnB1dHMgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXG4gIC8vIE90aGVyd2lzZSwgdGhlIHNoYWRlciBjb21waWxhdGlvbiB3aWxsIGZhaWwuXG4gIGNvbnN0IGNhbGNDT2Zmc2V0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgbGV0IGNPZmZzZXQgPSAnJztcbiAgICBpZiAoc3BhdGlhbCkge1xuICAgICAgY09mZnNldCA9IGBsZXQgY09mZnNldCA9ICR7XG4gICAgICAgIHlTaGFwZS5sZW5ndGggPT09IDFcbiAgICAgICAgICA/ICcwdSdcbiAgICAgICAgICA6IGZvcm1hdCA9PT0gJ05IV0MnXG4gICAgICAgICAgICA/IGBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XSAvICR7Y29tcG9uZW50c31gXG4gICAgICAgICAgICA6ICdvdXRwdXRJbmRpY2VzWzFdJ1xuICAgICAgfTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICAgICAgY09mZnNldCA9IGBcbiAgICAgICAgICAgICR7eS5pbmRpY2VzU2V0KCdvdXRwdXRJbmRpY2VzJywgJzAnLCAnMCcpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgQyBjaGFubmVsLlxuICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xuICAgICAgICAvLyB1cGRhdGUgRDEgeCAuLi4geCBEbiBjaGFubmVscy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzY2FsZS5yYW5rOyBpKyspIHtcbiAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcbiAgICAgICAgfVxuICAgICAgICBjT2Zmc2V0ICs9IGBsZXQgY09mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdjSW5kaWNlcycpfTtgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY09mZnNldDtcbiAgfTtcbiAgY29uc3QgZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSA9IChoZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBlcHNpbG9uID0gJHtlcHNpbG9ufTtcbiAgJHtoZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoeCwgc2NhbGUsIGJpYXMsIGlucHV0TWVhbiwgaW5wdXRWYXIsIHkpfVxuICAke2hlbHBlci5tYWluU3RhcnQoKX1cbiAgJHtoZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c31gKX07XG4gICAgJHtjYWxjQ09mZnNldCgpfVxuICAgIGxldCBzY2FsZSA9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7aW5wdXRNZWFuLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7aW5wdXRWYXIuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuZXBzaWxvbn1fJHthdHRyaWJ1dGVzLmZvcm1hdH1fJHtzcGF0aWFsfV8ke2NvbXBvbmVudHN9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3Jtc1xuICAgICAgICA/IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh5U2hhcGUpXVxuICAgICAgICA6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9XSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBCYXRjaE5vcm1BdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QmF0Y2hOb3JtQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG5cbmV4cG9ydCBjb25zdCBiYXRjaE5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRDb3VudCB9ID0gY29udGV4dDtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMoeyAuLi5hdHRyaWJ1dGVzLCBvdXRwdXRDb3VudCB9KTtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzMyMCwgNjQwLCAxMjgwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1syXTtcbiAgLy8gc2luY2UgY2hhbm5lbCBudW1iZXIgY2FuIGJlIG9ubHkgMzIwLzY0MC8xMjgwLCBpdCdzIGFsd2F5cyBkaXZpc2FibGUgYnkgNFxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFtjaGFubmVsc10sIDQpO1xuICBjb25zdCByZXNpZHVhbCA9IGlucHV0VmFyaWFibGUoJ3Jlc2lkdWFsJywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtjaGFubmVsc311IC8gNDtcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgcmVzaWR1YWwsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9XG4gICAgICArICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlIGNoYW5uZWxzJyl9ICsgJHtyZXNpZHVhbC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzQWRkJyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGJpYXNBZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWUgfCBFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb247XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlciA9IChcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIGRhdGFzaXplOiBudW1iZXIsXG4gIGlucHV0RGF0YVR5cGU6IG51bWJlcixcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlcixcbiAgZnVuY0NhbGw6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4gIGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGU/OiBVbmlmb3Jtc0FycmF5VHlwZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwoZGF0YXNpemUgLyA0KTtcblxuICBsZXQgZXhwcmVzc2lvbiA9ICcnO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb24gPSBgJHtmdW5jQ2FsbH0oYSlgO1xuICB9IGVsc2Uge1xuICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dERhdGEnLCBpbnB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIG91dHB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbeyBuYW1lOiAndmVjX3NpemUnLCB0eXBlOiAndTMyJyB9XTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cblxuICAgIGxldCBhID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGV4cHJlc3Npb24pfVxuICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICBjYWNoZUtleT86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlLFxuICBhZGRpdGlvbmFsVW5pZm9ybXM/OiBQcm9ncmFtVW5pZm9ybVtdLFxuICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlPzogVW5pZm9ybXNBcnJheVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpIC8gNCkgfSxcbiAgXTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSxcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUsXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxuICAgICAgICBmdW5jQ2FsbCxcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlLFxuICAgICAgKSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXQuZGltcywgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge1xuICAgICAgICB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKSxcbiAgICAgIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWJzJywgJ2FicycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW4nLCAnYXNpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgdG86IG51bWJlcjtcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgdG86IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGNhc3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENhc3RBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGxldCBmdW5jOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbDtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLnRvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYxNj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIGZ1bmMgPSAndmVjNDxmMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PHUzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIGZ1bmMgPSAndmVjNDxpMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGZ1bmMgPSAndmVjNDxib29sPic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHthdHRyaWJ1dGVzLnRvfWApO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2FzdCcsIGZ1bmMsIHVuZGVmaW5lZCwgYXR0cmlidXRlcy5jYWNoZUtleSwgYXR0cmlidXRlcy50byksXG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaXBBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbWluOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1heDogbnVtYmVyO1xufVxuXG5jb25zdCBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgbGV0IG1pbjogbnVtYmVyO1xuICBsZXQgbWF4OiBudW1iZXI7XG4gIGNvbnN0IGhhc01pbiA9IGlucHV0cy5sZW5ndGggPj0gMiAmJiBpbnB1dHNbMV0uZGF0YSAhPT0gMDtcbiAgY29uc3QgaGFzTWF4ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhICE9PSAwO1xuXG4gIHN3aXRjaCAoaW5wdXRzWzBdLmRhdGFUeXBlKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIG1pbiA9IGhhc01pbiA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBtYXggPSBoYXNNYXggPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAzLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0VWludDE2QXJyYXkoKVswXSA6IDY0NTExOyAvLyB1aW50MTYoNjQ1MTEpIDwtPiBmbG9hdDE2KC02NTUwNC4wKVxuICAgICAgbWF4ID0gaGFzTWF4ID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF0gOiAzMTc0MzsgLy8gdWludDE2KDMxNzQzKSA8LT4gZmxvYXQxNig2NTUwNC4wKVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0IGRhdGEgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG1pbiwgbWF4IH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGNsaXBBdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gY2xpcEF0dHJpYnV0ZXMgPyBjbGlwQXR0cmlidXRlcyA6IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdDbGlwJyxcbiAgICAgIChhKSA9PiBgY2xhbXAoJHthfSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWluKSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWF4KSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIFtcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5taW4gfSxcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5tYXggfSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIHsgbmFtZTogJ21pbicsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgICAgeyBuYW1lOiAnbWF4JywgdHlwZTogZGF0YVR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgXSxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjZWlsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nvc2gnLCAnY29zaCcpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxwaGFBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgYWxwaGE6IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnRWx1JyxcbiAgICAgIChhKSA9PiBgZWx1X3ZmMzIoJHthfSlgLFxuICAgICAgYFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke2RhdGFUeXBlfSkgLT4gJHtkYXRhVHlwZX0ge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke2RhdGFUeXBlfT4pIC0+IHZlYzQ8JHtkYXRhVHlwZX0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZXJmSW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IHIwOiAke3ZhclR5cGV9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7dmFyVHlwZX0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke3ZhclR5cGV9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7dmFyVHlwZX0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke3ZhclR5cGV9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7dmFyVHlwZX0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gO1xuXG5leHBvcnQgY29uc3QgZXJmID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXJmJywgKGEpID0+IGBlcmZfdmYzMigke2F9KWAsIGVyZkltcGwoZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdHZWx1JyxcbiAgICAgIChhKSA9PiBgMC41ICogJHthfSAqICgxLjAgKyBlcmZfdmYzMigke2F9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLFxuICAgICAgZXJmSW1wbChkYXRhVHlwZSksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ0xlYWt5UmVsdScsXG4gICAgICAoYSkgPT4gYHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7YX0sICR7YX0sICR7YX0gPj0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxuICAgICAgYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOb3QnLCAoYSkgPT4gYCEke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05lZycsIChhKSA9PiBgLSR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVjaXByb2NhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1JlY2lwcm9jYWwnLCAoYSkgPT4gYDEuMC8ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWAsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2lnbW9pZCcsIChhKSA9PiBgKDEuMCAvICgxLjAgKyBleHAoLSR7YX0pKSlgKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhcmRTaWdtb2lkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG4gIHJlYWRvbmx5IGJldGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICBhdHRyaWJ1dGVzIGFzIHtcbiAgICAgIGFscGhhOiBudW1iZXI7XG4gICAgICBiZXRhOiBudW1iZXI7XG4gICAgfSxcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGhhcmRTaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdIYXJkU2lnbW9pZCcsXG4gICAgICAoYSkgPT5cbiAgICAgICAgYG1heCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCBtaW4odmVjNDwke2RhdGFUeXBlfT4oMS4wKSwgJHthdHRyaWJ1dGVzLmFscGhhfSAqICR7YX0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pigke2F0dHJpYnV0ZXMuYmV0YX0pKSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbicsICdzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbmgnLCAnc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU3FydCcsICdzcXJ0JykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbicsICd0YW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGFuaEV4cHJlc3Npb24gPSAoYTogc3RyaW5nKSA9PiBgc2lnbigke2F9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7YX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2F9KSkpYDtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogcmV2aXNpdCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL2dwdXdlYi9pc3N1ZXMvNDQ1OCBpcyByZXNvbHZlZFxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbmgnLCB0YW5oRXhwcmVzc2lvbikpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1SW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke3ZhclR5cGV9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7dmFyVHlwZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHt2YXJUeXBlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIHJldHVybiAke3RhbmhFeHByZXNzaW9uKCd2Jyl9O1xufVxuYDtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+XG4gIGAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke3h9ICogKGZhc3RfZ2VsdV9jICogJHt4fSAqICR7eH0gKyBmYXN0X2dlbHVfYikpKSAqICR7eH1gO1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdGYXN0R2VsdScsXG4gICAgICBmYXN0R2VsdUV4cHJlc3Npb24sXG4gICAgICBmYXN0R2VsdUltcGwoZGF0YVR5cGUpLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aHJlc2hvbGRlZFJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnVGhyZXNob2xkZWRSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLFxuICAgICAgYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke2RhdGFUeXBlfT4oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVJbXBsID0gKHZhclR5cGU6IHN0cmluZywgYWxwaGE6IG51bWJlcikgPT4gYFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7dmFyVHlwZX0+KCR7YWxwaGF9KTtcbmNvbnN0IG9uZSA9ICR7dmFyVHlwZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke3ZhclR5cGV9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke3ZhclR5cGV9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVFeHByZXNzaW9uID0gKHg6IHN0cmluZykgPT4gYHF1aWNrX2dlbHVfaW1wbCgke3h9KWA7XG5cbmV4cG9ydCBjb25zdCBxdWlja2dlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ1F1aWNrR2VsdScsXG4gICAgICBxdWlja0dlbHVFeHByZXNzaW9uLFxuICAgICAgcXVpY2tHZWx1SW1wbChkVHlwZSwgYXR0cmlidXRlcy5hbHBoYSksXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgZXJmSW1wbCB9IGZyb20gJy4vdW5hcnktb3AnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzI1NjAsIDUxMjAsIDEwMjQwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbMl0gPSBvdXRwdXRTaGFwZVsyXSAvIDI7XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1swXS5kYXRhVHlwZSwgW2lucHV0c1swXS5kaW1zWzJdXSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtpbnB1dHNbMF0uZGltc1syXSAvIDQgLyAyfXU7XG5cbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgb3V0cHV0KX1cblxuICAke2VyZkltcGwoZGF0YVR5cGUpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWVMZWZ0ICogZ2VsdVJpZ2h0Jyl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JpYXNTcGxpdEdlbHUnLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NwbGl0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xudHlwZSBCaW5hcnlDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb25BOiBzdHJpbmcsIGV4cHJlc3Npb25COiBzdHJpbmcpID0+IHN0cmluZztcbnR5cGUgQmluYXJ5RnVuY3Rpb25DYWxsID1cbiAgfCBCdWlsdGluRnVuY3Rpb25OYW1lXG4gIHwgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvblxuICB8IHtcbiAgICAgIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIHZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBkaW1zQTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbXNCOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHZlY3Rvcml6ZTogYm9vbGVhbixcbiAgZG9Ccm9hZGNhc3Q6IGJvb2xlYW4sXG4gIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NDogYm9vbGVhbixcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcbiAgdHlwZUE6IG51bWJlcixcbiAgdHlwZUI6IG51bWJlcixcbiAgdHlwZU91dHB1dDogbnVtYmVyLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4pID0+IHtcbiAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gIGxldCBleHByZXNzaW9uVmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbDtcbiAgfSBlbHNlIHtcbiAgICBleHByZXNzaW9uU2NhbGFyID0gZnVuY0NhbGwuc2NhbGFyO1xuICAgIGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbC52ZWN0b3I7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcbiAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FEYXRhJywgdHlwZUEsIGRpbXNBLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBkaW1zQi5sZW5ndGgsIDQpO1xuXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gIGlmICh2ZWN0b3JpemUpIHtcbiAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcbiAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSkgPT09IDE7XG4gICAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0IpID09PSAxO1xuICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0IubGVuZ3RoID4gMCAmJiBkaW1zQltkaW1zQi5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50KSB7XG4gICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICBpc0FPbmVFbGVtZW50ID8gYCR7YS50eXBlLnZhbHVlfSgke2EuZ2V0QnlPZmZzZXQoJzAnKX0ueClgIDogYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLFxuICAgICAgICAgICAgaXNCT25lRWxlbWVudCA/IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0XG4gICAgICAgICAgICAgICAgICA/IGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpXG4gICAgICAgICAgICAgICAgICA6IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCdvZmZzZXRBIC8gNHUnKX1bb2Zmc2V0QSAlIDR1XSlgLFxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NFxuICAgICAgICAgICAgICAgICAgPyBiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKVxuICAgICAgICAgICAgICAgICAgOiBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1Jyl9W29mZnNldEIgJSA0dV0pYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghZG9Ccm9hZGNhc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhRGF0YVtpbmRleEEke3h9XVtjb21wb25lbnRBJHt4fV1gO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYkRhdGFbaW5kZXhCJHt4fV1bY29tcG9uZW50QiR7eH1dYDtcbiAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7eH0gPSBvZmZzZXRCJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb25TY2FsYXIoZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CKX0pO1xuICAgICAgICAgIGA7XG4gICAgfTtcbiAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMCl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMyl9XG4gICAgICAgICAgYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYSwgYiwgb3V0cHV0KX1cblxuICAgICAgICAke2FkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiA/PyAnJ31cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNhY2hlS2V5OiBzdHJpbmcsXG4gIGE6IFRlbnNvclZpZXcsXG4gIGI6IFRlbnNvclZpZXcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGEuZGF0YVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChhLmRpbXMsIGIuZGltcyk7XG4gIGxldCBvdXRwdXRTaGFwZSA9IGEuZGltcztcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpO1xuXG4gIGxldCB2ZWN0b3JpemUgPSBmYWxzZTtcbiAgbGV0IHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxuICBjb25zdCBjYWNoZUtleUF1eCA9IFtpc0Jyb2FkY2FzdF07XG4gIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGEuZGltcywgYi5kaW1zLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICAgIH1cbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZTtcbiAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpID09PSAxO1xuICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShiLmRpbXMpID09PSAxO1xuICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYS5kaW1zLmxlbmd0aCA+IDAgJiYgYS5kaW1zW2EuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgY29uc3QgYkxhc3REaW1EaXZpc2libGVCeTQgPSBiLmRpbXMubGVuZ3RoID4gMCAmJiBiLmRpbXNbYi5kaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICBjYWNoZUtleUF1eC5wdXNoKGlzQU9uZUVsZW1lbnQpO1xuICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChhTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChiTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcbiAgICBsZXQgc2hhcmVkRGltZW5zaW9uID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaW1BID0gYS5kaW1zW2EuZGltcy5sZW5ndGggLSBpXSA/PyAxO1xuICAgICAgY29uc3QgZGltQiA9IGIuZGltc1tiLmRpbXMubGVuZ3RoIC0gaV0gPz8gMTtcbiAgICAgIGlmIChkaW1BID09PSBkaW1CKSB7XG4gICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFyZWREaW1lbnNpb24gJSA0ID09PSAwKSB7XG4gICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NCkge1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxlbWVudC13aXNlXG4gICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgfVxuICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBjYWNoZUtleSArIGNhY2hlS2V5QXV4Lm1hcCgoeCkgPT4geC50b1N0cmluZygpKS5qb2luKCdfJyksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBhLmRpbXMsXG4gICAgICAgIGIuZGltcyxcbiAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgIHZlY3Rvcml6ZSxcbiAgICAgICAgaXNCcm9hZGNhc3QsXG4gICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCxcbiAgICAgICAgZnVuY0NhbGwsXG4gICAgICAgIGEuZGF0YVR5cGUsXG4gICAgICAgIGIuZGF0YVR5cGUsXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxuICAgICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24sXG4gICAgICApLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiBjb21wb25lbnQgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQpIH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGEuZGltcywgYi5kaW1zLCBvdXRwdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgcnVuQmluYXJ5T3AgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlPzogbnVtYmVyLFxuKTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvKFxuICAgICAgbmFtZSxcbiAgICAgIGNhY2hlS2V5ID8/ICcnLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICBjb250ZXh0LmlucHV0c1sxXSxcbiAgICAgIGZ1bmNDYWxsLFxuICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgb3V0cHV0RGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0FkZCcsIChhLCBiKSA9PiBgJHthfSske2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZGl2ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdEaXYnLCAoYSwgYikgPT4gYCR7YX0vJHtifWApO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0VxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ011bCcsIChhLCBiKSA9PiBgJHthfSoke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgcG93ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IHR5cGUgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBjb250ZXh0LmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO1xuICBjb25zdCByb3VuZFN0ciA9IHR5cGUgPT09ICdpMzInID8gJ3JvdW5kJyA6ICcnO1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdQb3cnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYCB9LFxuICAgIGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R5cGV9LCBiIDogJHt0eXBlfSkgLT4gJHt0eXBlfSB7XG4gICAgICBpZiAoYiA9PSAke3R5cGV9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dHlwZX0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dHlwZX0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dHlwZX0oMi4wKSkpICE9IDEuMCkgKiAke3R5cGV9KCR7XG4gICAgICAgIHJvdW5kU3RyXG4gICAgICB9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R5cGV9PiwgYiA6IHZlYzQ8JHt0eXBlfT4pIC0+IHZlYzQ8JHt0eXBlfT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R5cGV9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdHcmVhdGVyJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT4ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT4ke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdMZXNzJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfTwke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgY29udGV4dCxcbiAgICAnR3JlYXRlck9yRXF1YWwnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9Pj0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT49JHtifSlgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBEYXRhVHlwZS5ib29sLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0xlc3NPckVxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTw9JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xuICBjb25zdCByZWZlcmVuY2VJbnB1dCA9IGlucHV0c1tyZWZlcmVuY2VJbmRleF07XG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gICAgaW5wdXQuZGltcy5mb3JFYWNoKChkaW0sIGkpID0+IHtcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbiAgfWA7XG5cbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dHNbaV0uZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJykpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWRqdXN0ZWRBeGlzOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgZGF0YVR5cGU6IERhdGFUeXBlLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXRWYXJzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGlucHV0cy5sZW5ndGgpO1xuXG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gIGNvbnN0IGlucHV0UmFua3MgPSBbXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgIHByZXZpb3VzU3VtICs9IGlucHV0c1tpXS5kaW1zW2FkanVzdGVkQXhpc107XG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGlucHV0UmFua3MucHVzaChpbnB1dHNbaV0uZGltcy5sZW5ndGgpO1xuICAgIGlucHV0VmFyc1tpXSA9IGlucHV0VmFyaWFibGUoYGlucHV0JHtpfWAsIGRhdGFUeXBlLCBpbnB1dFJhbmtzW2ldKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV0gfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbaV0uZGltcykpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpc1N0ciA9IEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSlcbiAgICAubWFwKChpKSA9PiBgdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7aX1gKVxuICAgIC5qb2luKCcsJyk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuXG4gICR7KCgpID0+IHtcbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtpfWAsICd1MzInKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KTtcbiAgfSkoKX1cblxuICAke2NhbGN1bGF0ZUlucHV0SW5kZXhJbXBsKHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoLCBzaXplSW5Db25jYXRBeGlzU3RyKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2luZGljZXNBeGlzfSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3NpemVJbkNvbmNhdEF4aXMubGVuZ3RofXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xuICAgICAgJHtpbmRpY2VzQXhpc30gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7YXNzaWduT3V0cHV0RGF0YShpbnB1dFZhcnMsIG91dHB1dCl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbmNhdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YWRqdXN0ZWRBeGlzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGFkanVzdGVkQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGFkanVzdGVkQXhpcyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICBvdXRwdXRTaGFwZVthZGp1c3RlZEF4aXNdID0gaW5wdXRzLnJlZHVjZShcbiAgICAoc3VtLCBpbnB1dCkgPT4gc3VtICsgKGlucHV0LmRpbXMubGVuZ3RoID4gYWRqdXN0ZWRBeGlzID8gaW5wdXQuZGltc1thZGp1c3RlZEF4aXNdIDogMCksXG4gICAgMCxcbiAgKTtcbiAgLy8gMCBsZW5ndGggdGVuc29ycyBhcmUgdmFsaWQgZm9yIGNvbmNhdCwgcmVtb3ZlIHRoZW1cbiAgY29uc3Qgbm9uRW1wdHlJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKChpbnB1dCkgPT4gU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgPiAwKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKG5vbkVtcHR5SW5wdXRzLCBhZGp1c3RlZEF4aXMsIG91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZGF0YVR5cGUpLCB7XG4gICAgaW5wdXRzOiBub25FbXB0eUlucHV0cyxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29uY2F0QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IE1BWF9DTElQLCBNSU5fQ0xJUCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFscGhhPzogbnVtYmVyO1xuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPSAoXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIHZhbHVlVHlwZTogc3RyaW5nLFxuICBiYXNlVHlwZSA9ICdmMzInLFxuKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgodmFsdWUsICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcbiAgICBjYXNlICdDbGlwJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KCR7YmFzZVR5cGV9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dmFsdWVUeXBlfSgke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xuICAgIGNhc2UgJ0hhcmRTaWdtb2lkJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgoJHt2YWx1ZVR5cGV9KDAuMCksIG1pbigke3ZhbHVlVHlwZX0oMS4wKSwgJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5iZXRhKSkpO2A7XG4gICAgY2FzZSAnTGVha3lSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBzZWxlY3QoJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcbiAgICBjYXNlICdUYW5oJzpcbiAgICAgIHJldHVybiBgbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO1xuICAgIGNhc2UgJyc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHthdHRyaWJ1dGVzLmFjdGl2YXRpb259YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhID0gKFxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICBwcm9ncmFtVW5pZm9ybTogUHJvZ3JhbVVuaWZvcm1bXSxcbikgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWF4ISB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluISB9LFxuICAgICk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEhIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaCh7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmFscGhhISB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyA9IChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdjbGlwX21heCcsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2NsaXBfbWluJywgdHlwZTogJ2YzMicgfSk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCxcbik6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nKSB8fCAnJztcbiAgaWYgKGFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICBjb25zdCBbYWxwaGEsIGJldGFdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0pIHx8IFswLjIsIDAuNV07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEsIGJldGEgfTtcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlciwgbnVtYmVyXSkgfHwgW01JTl9DTElQLCBNQVhfQ0xJUF07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiB9O1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgY29uc3QgW2FscGhhXSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyXSkgfHwgWzAuMDFdO1xuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGFscGhhIH07XG4gIH1cbiAgcmV0dXJuIHsgYWN0aXZhdGlvbiB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdHlwZVNuaXBwZXQgPSAoY29tcG9uZW50OiBudW1iZXIsIGRhdGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9PmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NuaXBwZXQgPSAoaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyA9PiBgXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cbiAgICAgIGA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuZXhwb3J0IGNvbnN0IHV0aWxGdW5jdGlvbnMgPSAoc3RyaWRlU3RyOiBzdHJpbmcpID0+IGBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke3N0cmlkZVN0cn0ueCksIGkzMigke3N0cmlkZVN0cn0ueSksIGkzMigke3N0cmlkZVN0cn0ueiksIDEpKTtcbn1cbmA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL21hdG11bF9wYWNrZWRfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0QnJvYWRjYXN0RGltcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgaW50ZXJuYWxWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQgeyB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBVmVjNFNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2UpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlUmVzdWx0U25pcHBldCA9ICh0cmFuc3Bvc2VBOiBib29sZWFuLCBpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZUEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2xldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107J31cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSA9IChcbiAgd29ya1BlclRocmVhZDogbnVtYmVyW10sXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgdHlwZSA9ICdmMzInLFxuICBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyLFxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXG4gIHRpbGVJbm5lciA9IDMyLFxuICBzcGxpdEsgPSBmYWxzZSxcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XG4gIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrZ3JvdXBTaXplWzBdICogd29ya1BlclRocmVhZFswXTtcbiAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgY29uc3Qgcm93UGVyVGhyZWFkQiA9IHRpbGVJbm5lciAvIHdvcmtncm91cFNpemVbMV07XG5cbiAgaWYgKFxuICAgICEoXG4gICAgICAoKHRyYW5zcG9zZUEgJiYgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCAmJiB3b3JrUGVyVGhyZWFkWzFdID09PSA0KSB8fFxuICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxuICAgICAgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiZcbiAgICAgIHRpbGVJbm5lciAlIHdvcmtncm91cFNpemVbMV0gPT09IDAgJiZcbiAgICAgIHdvcmtQZXJUaHJlYWRbMF0gPT09IDRcbiAgICApXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke3RyYW5zcG9zZUF9IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3dvcmtncm91cFNpemVbMV19LiBjb2xQZXJUaHJlYWQgJHt3b3JrUGVyVGhyZWFkWzBdfSBtdXN0IGJlIDQuYCk7XG4gIH1cbiAgcmV0dXJuIGBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aW5uZXJFbGVtZW50U2l6ZX07XG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7c3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XG4gIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7dHlwZX0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7cm93UGVyVGhyZWFkQn07XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke1xuICAgICAgICAgICAgYmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2xldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTsnfVxuXG4gICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHRTbmlwcGV0KHRyYW5zcG9zZUEsIGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YDtcbn07XG5cbmNvbnN0IHdyaXRlRGF0YVRvU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2UpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgICAgIGA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgICAgICBgO1xuICB9XG59O1xuXG5jb25zdCByZWFkRGF0YUZyb21TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2VBOiBib29sZWFuKSA9PlxuICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9IChcbiAgd29ya1BlclRocmVhZDogbnVtYmVyW10sXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgdHlwZSA9ICdmMzInLFxuICBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyLFxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXG4gIHRpbGVJbm5lciA9IDMyLFxuICBzcGxpdEsgPSBmYWxzZSxcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXG4gIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrUGVyVGhyZWFkWzFdICogd29ya2dyb3VwU2l6ZVsxXTtcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xuICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gIGNvbnN0IHRpbGVBSGlnaHQgPSB0cmFuc3Bvc2VBID8gdGlsZUlubmVyIDogdGlsZUFPdXRlcjtcblxuICBpZiAoXG4gICAgISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJiB0aWxlSW5uZXIgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdGlsZUFIaWdodCAke3RpbGVBSGlnaHR9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3dvcmtncm91cFNpemVbMV19LCB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gLFxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm93UGVyVGhyZWFkQSA9IHRpbGVBSGlnaHQgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICBjb25zdCBjb2xQZXJUaHJlYWRBID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICBjb25zdCBtYXRtdWxTbmlwcGV0ID0gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkc1xuICAgID8gYFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHt0aWxlQk91dGVyfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlQUhpZ2h0fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3RpbGVBV2lkdGh9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrZ3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUlubmVyfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQk91dGVyfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3dvcmtncm91cFNpemVbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtcbiAgICAgICAgICAgIHRyYW5zcG9zZUFcbiAgICAgICAgICAgICAgPyBgbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV07YFxuICAgICAgICAgICAgICA6IGBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XVtrXTtgXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7d29ya2dyb3VwU2l6ZVswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGBcbiAgICA6IGBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRBfTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHtjb2xQZXJUaHJlYWRBfTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRCfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEF9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke2NvbFBlclRocmVhZEF9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEJ9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7cmVhZERhdGFGcm9tU3ViQVNuaXBwZXQodHJhbnNwb3NlQSl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7XG5cbiAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUFXaWR0aH0+LCAke3RpbGVBSGlnaHR9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cbiAgICBsZXQgbnVtX3RpbGVzID0gJHtcbiAgICAgIHNwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSdcbiAgICB9O1xuICAgIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7bWF0bXVsU25pcHBldH1cbiAgfVxuYDtcbn07XG5cbmNvbnN0IG1hdE11bFJlYWRXcml0ZUZuU291cmNlID0gKFxuICBjb21wb25lbnQ6IG51bWJlcixcbiAgaGFzQmlhczogYm9vbGVhbixcbiAgYXBwbHlBY3RpdmF0aW9uOiBzdHJpbmcsXG4gIHZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdLFxuICBiYXRjaFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgW2JhdGNoQVNoYXBlLCBiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZV0gPSBiYXRjaFNoYXBlcztcbiAgY29uc3QgW2JhdGNoVmFyaWFibGUsIGFWYXJpYWJsZSwgYlZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZV0gPSB2YXJpYWJsZXM7XG4gIGNvbnN0IGJyb2FkQ2FzdEFEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEFTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gIGNvbnN0IGJyb2FkQ2FzdEJEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHZhcmlhYmxlc1swXS50eXBlLnRlbnNvcik7XG4gIGNvbnN0IGdldEFJbmRpY2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFSYW5rID0gYVZhcmlhYmxlLnJhbms7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgIGxldCByZXNTdHIgPSBgdmFyIGFJbmRpY2VzOiAke2FWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgZm9yIChsZXQgaSA9IGFSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICB9XG4gICAgYnJvYWRDYXN0QURpbXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgcmVzU3RyICs9IGBcXG5hSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICB9KTtcbiAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7YVJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBhSW5kaWNlc1ske2FSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgIHJldHVybiByZXNTdHI7XG4gIH07XG4gIGNvbnN0IGdldEJJbmRpY2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IGJSYW5rID0gYlZhcmlhYmxlLnJhbms7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgIGxldCByZXNTdHIgPSBgdmFyIGJJbmRpY2VzOiAke2JWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgZm9yIChsZXQgaSA9IGJSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICB9XG4gICAgYnJvYWRDYXN0QkRpbXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgcmVzU3RyICs9IGBcXG5iSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICB9KTtcbiAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7YlJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske2JSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgIHJldHVybiByZXNTdHI7XG4gIH07XG4gIGNvbnN0IHNvdXJjZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHt0eXBlU25pcHBldChcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIGRhdGFUeXBlLFxuICAgICl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgICR7Z2V0QUluZGljZXMoKX1cbiAgICAgICAgdmFsdWUgPSAke2FWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke3R5cGVTbmlwcGV0KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgZGF0YVR5cGUsXG4gICAgKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgJHtnZXRCSW5kaWNlcygpfVxuICAgICAgICB2YWx1ZSA9ICR7YlZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYkluZGljZXMnKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7XG4gICAgICAgICAgaGFzQmlhc1xuICAgICAgICAgICAgPyBgdmFsdWUgPSB2YWx1ZSArICR7aXNDaGFubmVsc0xhc3QgPyAnYmlhc1tjb2xJbl0nIDogYCR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KGJpYXNbcm93XSlgfTtgXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgICR7b3V0cHV0VmFyaWFibGUuc2V0QnlJbmRpY2VzKCd2ZWMzPHUzMj4oY29vcmRzKScsICd2YWx1ZScpfVxuICAgICAgfVxuICAgIH1cbiAgICBgO1xuICByZXR1cm4gc291cmNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3Qgb3V0ZXJEaW1zQiA9IGJTaGFwZS5zbGljZSgwLCAtMik7XG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgY29uc3QgZGltQU91dGVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcbiAgY29uc3QgZGltSW5uZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBiU2hhcGVbYlNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBpc1ZlYzQgPSBkaW1Jbm5lciAlIDQgPT09IDAgJiYgZGltQk91dGVyICUgNCA9PT0gMDtcblxuICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xuICBjb25zdCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaW1CT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaW1BT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrZ3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgY29uc3QgYVNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNBLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gY29tcG9uZW50c107XG4gIGNvbnN0IGFSYW5rID0gYVNoYXBlVGVtcC5sZW5ndGg7XG4gIGNvbnN0IGJTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQiwgZGltSW5uZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBiUmFuayA9IGJTaGFwZVRlbXAubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhY3RpdmF0aW9uQXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGVUZW1wLCBiU2hhcGVUZW1wKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcblxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gb3V0ZXJEaW1zLmxlbmd0aDtcbiAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaERpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGJhdGNoUmFuaywgMSk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgIGNvbnN0IEEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhUmFuaywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgQiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJSYW5rLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtBLCBCXTtcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IGRlY2xhcmVGdW5jdGlvbnMgPSBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICBoYXNCaWFzLFxuICAgICAgYXBwbHlBY3RpdmF0aW9uLFxuICAgICAgW2JhdGNoRGltcywgQSwgQiwgb3V0cHV0XSxcbiAgICAgIFtvdXRlckRpbXNBLCBvdXRlckRpbXNCLCBvdXRlckRpbXNdLFxuICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAke1xuICAgIGlzVmVjNFxuICAgICAgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgfVxuICAgICAgICAgICAgICAgICAgIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2VsZW1lbnRzUGVyVGhyZWFkfTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7aXNWZWM0fTske2lzQ2hhbm5lbHNMYXN0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IGJpYXNTbmlwcGV0LCB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRDb21tb25TbmlwcGV0ID0gKFxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcbiAgZml0QU91dGVyOiBib29sZWFuLFxuICBmaXRCT3V0ZXI6IGJvb2xlYW4sXG4gIGZpdElubmVyOiBib29sZWFuLFxuICBhZGRCaWFzID0gZmFsc2UsXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBpbm5lckVsZW1lbnRTaXplWCA9IDQsXG4gIGlubmVyRWxlbWVudFNpemVXID0gNCxcbiAgaW5uZXJFbGVtZW50U2l6ZSA9IDQsXG4gIGRhdGFUeXBlID0gJ2YzMicsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBnZXRYU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXhdOyc7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBgcmVzRGF0YSA9IHZlYzM8JHtkYXRhVHlwZX0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXggLyA0XTsnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTsnO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3RcbiAgICA/IGBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgO1xuXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcbiAgY29uc3QgcmVhZFhTbmlwcGV0ID0gYFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgbGV0IG91dFJvdyA9ICR7cm93fSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHtjb2x9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHVuaWZvcm1zLnN0cmlkZVsxXSArIHVuaWZvcm1zLmRpbGF0aW9uWzFdICogV0NvbCAtIHVuaWZvcm1zLnBhZFsxXTtcbiAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eEhlaWdodH0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3hXaWR0aH0pIHtcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7Z2V0WFNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgO1xuXG4gIGNvbnN0IHNhbXBsZVggPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gZml0QU91dGVyICYmIGZpdElubmVyXG4gICAgICA/IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICAke3JlYWRYU25pcHBldH1gXG4gICAgICA6IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3JlYWRYU25pcHBldH1cbiAgICB9XG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtgXG4gICAgOiBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcbiAgICAgID8gYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgICR7cmVhZFhTbmlwcGV0fWBcbiAgICAgIDogYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2A7XG5cbiAgY29uc3Qgc2FtcGxlVyA9IGAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKX1gO1xuXG4gIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XG4gIGNvbnN0IGFUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcbiAgY29uc3QgYlR5cGUgPSBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpO1xuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCBkYXRhVHlwZSk7XG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7YVR5cGV9IHtcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVYIDogc2FtcGxlV31cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2JUeXBlfSB7XG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZVh9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7cmVzVHlwZX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWA7XG4gIHJldHVybiB1c2VyQ29kZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbUFPdXRlcjogbnVtYmVyLFxuICBkaW1CT3V0ZXI6IG51bWJlcixcbiAgZGltSW5uZXI6IG51bWJlcixcbiAgaGFzQmlhczogYm9vbGVhbixcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbixcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCBiYXRjaFNpemUgPSBvdXRwdXRTaGFwZVswXTtcbiAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XG4gIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XG4gIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXG4gIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya0dyb3VwU2l6ZVsxXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdO1xuICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gIGNvbnN0IGZpdEFPdXRlciA9IGRpbUFPdXRlciAlIHRpbGVBT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdEJPdXRlciA9IGRpbUJPdXRlciAlIHRpbGVCT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XG4gIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IGlzVmVjNCA/IFtpbm5lckVsZW1lbnRTaXplLCA0LCA0XSA6IFsxLCAxLCAxXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ3BhZCcsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZScsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9uJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgY29tcG9uZW50IDIsIDMuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9IGBcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHtpc1ZlYzQgPyAnLyA0JyA6ICcnfSwgdmFsdWUpO1xuICAgICAgfWA7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgIH1gO1xuICAgIH1cblxuICAgIHJldHVybiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgICAgICAgJHtjb252MmRDb21tb25TbmlwcGV0KFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIGZpdEFPdXRlcixcbiAgICAgICAgICBmaXRCT3V0ZXIsXG4gICAgICAgICAgZml0SW5uZXIsXG4gICAgICAgICAgaGFzQmlhcyxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVswXSxcbiAgICAgICAgICBlbGVtZW50c1NpemVbMV0sXG4gICAgICAgICAgZWxlbWVudHNTaXplWzJdLFxuICAgICAgICAgIHQsXG4gICAgICAgICl9XG4gICAgICAgICR7XG4gICAgICAgICAgaXNWZWM0XG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKVxuICAgICAgICAgICAgOiBtYWtlTWF0TXVsUGFja2VkU291cmNlKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIWlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgICAgICAgIHRpbGVJbm5lcixcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjJETWF0TXVsJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbm5lckVsZW1lbnRTaXplfTske2lzVmVjNH07JHtmaXRBT3V0ZXJ9OyR7Zml0Qk91dGVyfTske2ZpdElubmVyfTske3RpbGVBT3V0ZXJ9OyR7dGlsZUJPdXRlcn07JHt0aWxlSW5uZXJ9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252M2RfbmFpdmVfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCBhcnJheVByb2R1Y3QgPSAoYXJyOiBudW1iZXJbXSkgPT4ge1xuICBsZXQgcHJvZHVjdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCAqPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Q7XG59O1xuXG5jb25zdCBwYXJzZTNUdXBsZVBhcmFtID0gKHBhcmFtOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT5cbiAgdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xuXG5jb25zdCBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplID0gKGZpbHRlclNpemU6IG51bWJlciwgZGlsYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGlmIChkaWxhdGlvbiA8PSAxKSB7XG4gICAgcmV0dXJuIGZpbHRlclNpemU7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcbn07XG5cbmNvbnN0IGNvbXB1dGVEZWZhdWx0UGFkID0gKFxuICBpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpZWxkU2l6ZTogbnVtYmVyLFxuICBzdHJpZGU6IG51bWJlcixcbiAgZGlsYXRpb24gPSAxLFxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBlZmZlY3RpdmVGaWVsZFNpemUpIC8gMik7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0cHV0U2hhcGU0RCA9IChcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIG91dENoYW5uZWxzOiBudW1iZXIsXG4gIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgemVyb1BhZD86IG51bWJlcixcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWx0ZXJTaGFwZVswXSwgc3RyaWRlc1swXSk7XG4gIH1cbiAgY29uc3Qgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIG91dENoYW5uZWxzXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDM7IGluZGV4KyspIHtcbiAgICBpZiAoaW5TaGFwZVtpbmRleF0gKyAyICogemVyb1BhZCA+PSBmaWx0ZXJTaGFwZVtpbmRleF0pIHtcbiAgICAgIG91dFNoYXBlW2luZGV4XSA9IE1hdGgudHJ1bmMoKGluU2hhcGVbaW5kZXhdIC0gZmlsdGVyU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlc1tpbmRleF0gKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFNoYXBlO1xufTtcblxuY29uc3QgZ2V0M0RQYWRBbmRPdXRJbmZvID0gKFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBpbkRlcHRoOiBudW1iZXIsXG4gIGluSGVpZ2h0OiBudW1iZXIsXG4gIGluV2lkdGg6IG51bWJlcixcbiAgc3RyaWRlRGVwdGg6IG51bWJlcixcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXIsXG4gIHN0cmlkZVdpZHRoOiBudW1iZXIsXG4gIGZpbHRlckRlcHRoOiBudW1iZXIsXG4gIGZpbHRlckhlaWdodDogbnVtYmVyLFxuICBmaWx0ZXJXaWR0aDogbnVtYmVyLFxuKTogeyBwYWRJbmZvOiBQYWRJbmZvM0Q7IG91dERlcHRoOiBudW1iZXI7IG91dEhlaWdodDogbnVtYmVyOyBvdXRXaWR0aDogbnVtYmVyIH0gPT4ge1xuICBsZXQgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBsZXQgb3V0RGVwdGg6IG51bWJlcjtcbiAgbGV0IG91dEhlaWdodDogbnVtYmVyO1xuICBsZXQgb3V0V2lkdGg6IG51bWJlcjtcblxuICBpZiAocGFkID09PSAnVkFMSUQnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcGFkID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgIHBhZEluZm8gPSB7IHRvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkLCBmcm9udDogcGFkLCBiYWNrOiBwYWQgfTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxuICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSxcbiAgICAgIFtmaWx0ZXJEZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aF0sXG4gICAgICAxLFxuICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSxcbiAgICAgIHBhZCxcbiAgICApO1xuICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XG4gICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhZCkpIHtcbiAgICBpZiAoIXBhZC5ldmVyeSgodmFsLCBfLCBhcnIpID0+IHZhbCA9PT0gYXJyWzBdKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgICB9XG4gICAgcGFkSW5mbyA9IHsgdG9wOiBwYWRbMF0sIGJvdHRvbTogcGFkWzFdLCBsZWZ0OiBwYWRbMl0sIHJpZ2h0OiBwYWRbM10sIGZyb250OiBwYWRbNF0sIGJhY2s6IHBhZFs1XSB9O1xuICAgIGNvbnN0IG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlNEQoXG4gICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLFxuICAgICAgW2ZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSxcbiAgICAgIDEsXG4gICAgICBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdLFxuICAgICAgcGFkWzBdLFxuICAgICk7XG4gICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcbiAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVsxXTtcbiAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzJdO1xuICB9IGVsc2UgaWYgKHBhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCAnU0FNRV9MT1dFUicuXG4gICAgb3V0RGVwdGggPSBNYXRoLmNlaWwoaW5EZXB0aCAvIHN0cmlkZURlcHRoKTtcbiAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKGluV2lkdGggLyBzdHJpZGVXaWR0aCk7XG4gICAgY29uc3QgcGFkQWxvbmdEZXB0aCA9IChvdXREZXB0aCAtIDEpICogc3RyaWRlRGVwdGggKyBmaWx0ZXJEZXB0aCAtIGluRGVwdGg7XG4gICAgY29uc3QgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICBjb25zdCBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICBjb25zdCBmcm9udCA9IE1hdGguZmxvb3IocGFkQWxvbmdEZXB0aCAvIDIpO1xuICAgIGNvbnN0IGJhY2sgPSBwYWRBbG9uZ0RlcHRoIC0gZnJvbnQ7XG4gICAgY29uc3QgdG9wID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHBhZEFsb25nSGVpZ2h0IC0gdG9wO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICBjb25zdCByaWdodCA9IHBhZEFsb25nV2lkdGggLSBsZWZ0O1xuXG4gICAgcGFkSW5mbyA9IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBmcm9udCwgYmFjayB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgfVxuICByZXR1cm4geyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9O1xufTtcblxudHlwZSBQYWRJbmZvM0QgPSB7XG4gIHRvcDogbnVtYmVyO1xuICBsZWZ0OiBudW1iZXI7XG4gIHJpZ2h0OiBudW1iZXI7XG4gIGJvdHRvbTogbnVtYmVyO1xuICBmcm9udDogbnVtYmVyO1xuICBiYWNrOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDb252M0RJbmZvID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgaW5EZXB0aDogbnVtYmVyO1xuICBpbkhlaWdodDogbnVtYmVyO1xuICBpbldpZHRoOiBudW1iZXI7XG4gIGluQ2hhbm5lbHM6IG51bWJlcjtcbiAgb3V0RGVwdGg6IG51bWJlcjtcbiAgb3V0SGVpZ2h0OiBudW1iZXI7XG4gIG91dFdpZHRoOiBudW1iZXI7XG4gIG91dENoYW5uZWxzOiBudW1iZXI7XG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnO1xuICBzdHJpZGVEZXB0aDogbnVtYmVyO1xuICBzdHJpZGVIZWlnaHQ6IG51bWJlcjtcbiAgc3RyaWRlV2lkdGg6IG51bWJlcjtcbiAgZGlsYXRpb25EZXB0aDogbnVtYmVyO1xuICBkaWxhdGlvbkhlaWdodDogbnVtYmVyO1xuICBkaWxhdGlvbldpZHRoOiBudW1iZXI7XG4gIGZpbHRlckRlcHRoOiBudW1iZXI7XG4gIGZpbHRlckhlaWdodDogbnVtYmVyO1xuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJEZXB0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVyV2lkdGg6IG51bWJlcjtcbiAgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUNvbnYzREluZm8gPSAoXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBzdHJpZGVzOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGRpbGF0aW9uczogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBkZXB0aHdpc2UgPSBmYWxzZSxcbiAgZGF0YUZvcm1hdDogJ2NoYW5uZWxzRmlyc3QnIHwgJ2NoYW5uZWxzTGFzdCcgPSAnY2hhbm5lbHNMYXN0Jyxcbik6IENvbnYzREluZm8gPT4ge1xuICBsZXQgYmF0Y2hTaXplLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgaW5DaGFubmVscztcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgW2JhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHNdID0gaW5TaGFwZTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICBbYmF0Y2hTaXplLCBpbkNoYW5uZWxzLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aF0gPSBpblNoYXBlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7ZGF0YUZvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbZmlsdGVyQ2hhbm5lbHMsICwgZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdID0gZmlsdGVyU2hhcGU7XG5cbiAgY29uc3QgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSA9IHBhcnNlM1R1cGxlUGFyYW0oc3RyaWRlcyk7XG4gIGNvbnN0IFtkaWxhdGlvbkRlcHRoLCBkaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKGRpbGF0aW9ucyk7XG5cbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlckRlcHRoLCBkaWxhdGlvbkRlcHRoKTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcbiAgY29uc3QgeyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9ID0gZ2V0M0RQYWRBbmRPdXRJbmZvKFxuICAgIHBhZCxcbiAgICBpbkRlcHRoLFxuICAgIGluSGVpZ2h0LFxuICAgIGluV2lkdGgsXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRlcHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckhlaWdodCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcbiAgKTtcblxuICBjb25zdCBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xuXG4gIGxldCBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoXTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIGRhdGFGb3JtYXQsXG4gICAgaW5EZXB0aCxcbiAgICBpbkhlaWdodCxcbiAgICBpbldpZHRoLFxuICAgIGluQ2hhbm5lbHMsXG4gICAgb3V0RGVwdGgsXG4gICAgb3V0SGVpZ2h0LFxuICAgIG91dFdpZHRoLFxuICAgIG91dENoYW5uZWxzLFxuICAgIHBhZEluZm8sXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGZpbHRlckRlcHRoLFxuICAgIGZpbHRlckhlaWdodCxcbiAgICBmaWx0ZXJXaWR0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXG4gICAgZWZmZWN0aXZlRmlsdGVyV2lkdGgsXG4gICAgZGlsYXRpb25EZXB0aCxcbiAgICBkaWxhdGlvbkhlaWdodCxcbiAgICBkaWxhdGlvbldpZHRoLFxuICAgIGluU2hhcGUsXG4gICAgb3V0U2hhcGUsXG4gICAgZmlsdGVyU2hhcGUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBwYWRzOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGF0YUZvcm1hdDogc3RyaW5nLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQuXG4gIGNvbnN0IGlzVmVjNCA9IGZhbHNlO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICBjb25zdCBkaXNwYXRjaExheW91dCA9IHsgeDogb3V0cHV0U2hhcGUubWFwKChfLCBpKSA9PiBpKSB9O1xuICBjb25zdCBkaXNwYXRjaCA9IFtNYXRoLmNlaWwoYXJyYXlQcm9kdWN0KGRpc3BhdGNoTGF5b3V0LngubWFwKChkKSA9PiBvdXRwdXRTaGFwZVtkXSkpIC8gd29ya0dyb3VwU2l6ZVswXSksIDEsIDFdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogcGFkcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cbiAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgY29uc3QgdCA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gJyc7XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChiaWFzKTtcbiAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCA1KSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgNSl9JHtcbiAgICAgICAgICAgIGlzVmVjNCA/ICcvIDQnIDogJydcbiAgICAgICAgICB9XTtcbiAgICAgICAgfWA7XG4gICAgfVxuICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCB0KTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCB0KTtcblxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICAgICBmbiBnZXRYKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt4LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt3LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke2dldEVsZW1lbnRBdCgnY29vcmRzJywgMCwgeC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgeC5yYW5rIC0gMSwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDIsIHgucmFuaylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspfSxcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAyLCB4LnJhbmspXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVcgPSAke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMywgeC5yYW5rKVxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDQsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGB2YWx1ZSArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyknIDogJyd9O1xuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjNETmFpdmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aXNDaGFubmVsTGFzdH07JHtpbm5lckVsZW1lbnRTaXplfTske2hhc0JpYXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuLyoqXG4gKiBuYWl2ZSBncm91cGVkIGNvbnYgaW1wbGVtZW50YXRpb24sIHN1cHBvcnRzIDFkLzJkIGNvbnZcbiAqIEBwYXJhbSBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiAtIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNxdWVlemUgdGhlIG91dHB1dCBzaGFwZSwgb25seSB1c2VkIGluIGNvbnYxZFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGlzQ2hhbm5lbExhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gb3V0cHV0Q2hhbm5lbHMgLyBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsTGFzdCAmJiBvdXRwdXRDaGFubmVsc1Blckdyb3VwID49IDQgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzKSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgW3dTaGFwZVswXSwgd1NoYXBlWzFdLCB3U2hhcGVbMl0sIHdTaGFwZVszXSAvIGNvbXBvbmVudHNdKSxcbiAgKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c10pLFxuICApO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSBpc0NoYW5uZWxMYXN0XG4gICAgICA/IGBcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVswXTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt4LmdldCgnYmF0Y2gnLCAneEhlaWdodCcsICd4V2lkdGgnLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnd0hlaWdodCcsICd3V2lkdGgnLCAnd0luQ2hhbm5lbCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYFxuICAgICAgOiBgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ2lucHV0X2NoYW5uZWwnLCAneEhlaWdodCcsICd4V2lkdGgnKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ291dHB1dF9jaGFubmVsJywgJ3dJbkNoYW5uZWwnLCAnd0hlaWdodCcsICd3V2lkdGgnKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMyA6IDF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAxIDogMn1dLCBvdXRwdXRJbmRpY2VzWyR7XG4gICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDNcbiAgICB9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHtjb21wb25lbnRzfSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7aXNDaGFubmVsTGFzdCA/IDIgOiAxfV07XG5cbiAgICB2YXIgdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtjYWxjdWxhdGVSZXN1bHR9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9XyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVszXSk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbMl0pO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgY29uc3QgeFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzBdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHdTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMV0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c107XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSwgb3V0cHV0U2hhcGVJblNoYWRlcikpO1xuICBjb25zdCB4TnVtYmVyID0gKG91dHB1dE51bWJlciAtIDEpICogYXR0cmlidXRlcy5zdHJpZGVzWzFdICsgd1NoYXBlWzFdO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyB3aWR0aDA7XG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtvdXRwdXROdW1iZXJ9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt4LnR5cGUudmFsdWV9LCAke3hOdW1iZXJ9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3dTaGFwZVswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3hOdW1iZXJ9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LmdldCgnYmF0Y2gnLCAndTMyKHhfaGVpZ2h0KScsICd1MzIoeF93aWR0aCknLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7d1NoYXBlWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHt3LmdldCgnd19oZWlnaHQnLCAnd193aWR0aCcsICcwJywgJ291dHB1dF9jaGFubmVsJyl9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyb3cnLCAnY29sICsgaScsICdvdXRwdXRfY2hhbm5lbCcsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dyb3VwZWRDb252LVZlY3Rvcml6ZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7eE51bWJlcn07JHt3U2hhcGVbMF19OyR7d1NoYXBlWzFdfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3R5cGUnXSA6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEJyb2FkY2FzdERpbXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIGludGVybmFsVmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IE0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICBjb25zdCBOID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSyA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKE4pO1xuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoSyk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMoTSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtiYXRjaFNpemUsIE0sIE5dO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZSwgYlNoYXBlKSk7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZUluU2hhZGVyKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hfZGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0ZXJEaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFTaGFwZS5sZW5ndGgsIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgYlNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYl07XG4gICAgbGV0IHByb2Nlc3NCaWFzID0gJyc7XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBiaWFzQ29tcG9uZW50cykpO1xuICAgICAgcHJvY2Vzc0JpYXMgPSBgJHtcbiAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBgdmFsdWUgKz0gYmlhc1tjb2wgLyAke2JpYXNDb21wb25lbnRzfV07YCA6IGB2YWx1ZSArPSAke291dHB1dC50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgXG4gICAgICB9YDtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICBjb25zdCBvdXRlckRpbXNCID0gYlNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICBjb25zdCBicm9hZENhc3RBRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQSwgb3V0ZXJEaW1zKTtcbiAgICBjb25zdCBicm9hZENhc3RCRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQiwgb3V0ZXJEaW1zKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgIGNvbnN0IGdldEluZGljZXMgPSAodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJyb2FkQ2FzdERpbXM6IG51bWJlcltdKSA9PiB7XG4gICAgICBjb25zdCByYW5rID0gdmFyaWFibGUucmFuaztcbiAgICAgIGNvbnN0IG5hbWUgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGB2YXIgJHtuYW1lfV9pbmRpY2VzID0gJHt2YXJpYWJsZS50eXBlLmluZGljZXN9KDB1LCAwdSk7YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoUmFuayA9IGJhdGNoRGltcy5yYW5rO1xuICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgJHtuYW1lfV9pbmRpY2VzOiAke3ZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoX2luZGljZXNbJHtqfV1gIDogJ2JhdGNoX2luZGljZXMnfTtgO1xuICAgICAgfVxuICAgICAgYnJvYWRDYXN0RGltcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgfSk7XG4gICAgICByZXNTdHIgKz0gYCR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAyfV0gPSAwdTtcbiAgICAgICAgICAgICAgICAgICAgICR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAxfV0gPSAwdTtgO1xuICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICB9O1xuXG4gICAgY29uc3QgY2FsY1Jlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFDb21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2l9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7aX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2NvbXBvbmVudHN9XTtgO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXROdW1iZXI7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2l9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7YUNvbXBvbmVudHN9XTtgO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgdmFsdWVzWyR7aX1dID0gZm1hKCR7Yi50eXBlLnZhbHVlfShhX2RhdGEke2FDb21wb25lbnRzID09PSAxID8gJycgOiBgWyR7an1dYH0pLCBiX2RhdGEke2p9LCB2YWx1ZXNbJHtpfV0pO1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pKSAqICR7Y29tcG9uZW50c307XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7b3V0cHV0TnVtYmVyfTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke291dHB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/ICcnIDogYGxldCBiYXRjaF9pbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCdiYXRjaCcpfTtgfVxuICAgICR7Z2V0SW5kaWNlcyhhLCBicm9hZENhc3RBRGltcyl9XG4gICAgbGV0IGFfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldCgnYV9pbmRpY2VzJyl9O1xuICAgICR7Z2V0SW5kaWNlcyhiLCBicm9hZENhc3RCRGltcyl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtiLmluZGljZXNUb09mZnNldCgnYl9pbmRpY2VzJyl9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke2FDb21wb25lbnRzfSkge1xuICAgICAgJHtjYWxjUmVzdWx0KCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtvdXRwdXQudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke291dHB1dC5pbmRpY2VzVG9PZmZzZXQoJ2N1cl9pbmRpY2VzJyl9O1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7Y29tcG9uZW50c31gLCAndmFsdWUnKX07XG4gICAgfVxuICB9XG4gIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bE5haXZlJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtjb21wb25lbnRzfTske2FDb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoY29udGV4dC5pbnB1dHNbMF0uZGltcywgY29udGV4dC5pbnB1dHNbMV0uZGltcywgdHJ1ZSk7XG4gIGlmICghb3V0cHV0U2hhcGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGNvbnN0IE4gPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcbiAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xuaW1wb3J0IHsgY29tcHV0ZUNvbnYzREluZm8sIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252M2RfbmFpdmVfd2ViZ3B1JztcbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbywgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyB9IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi9tYXRtdWwnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYWRqdXN0UGFkczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoaXNDaGFubmVsTGFzdCA/IDEgOiAyLCBpc0NoYW5uZWxMYXN0ID8gMyA6IDQpO1xuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVswXTtcbiAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XG4gIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcbiAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkID0gaW5wdXRTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgYWRqdXN0UGFkc1tpXSArIGFkanVzdFBhZHNbaSArIHNwYXRpYWxSYW5rXSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT5cbiAgICBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSxcbiAgKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252QXR0cmlidXRlcyBleHRlbmRzIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB3SXNDb25zdDogYm9vbGVhbjtcbn1cblxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbTSwgQy9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBDL2dyb3VwLCBNXVxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPiA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgd2VsbCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIGtlcm5lbFNoYXBlLnB1c2goLi4uQXJyYXkoaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMiAtIGtlcm5lbFNoYXBlLmxlbmd0aCkuZmlsbCgwKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChrZXJuZWxTaGFwZVtpIC0gMl0gPT09IDApIHtcbiAgICAgIGtlcm5lbFNoYXBlW2kgLSAyXSA9IGlucHV0c1sxXS5kaW1zW2ldO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyxcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzIH0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVthdHRyaWJ1dGVzLmF1dG9fcGFkIGFzIG51bWJlcl07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlcltdO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIG51bWJlcltdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIG51bWJlcltdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIG51bWJlcltdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndfaXNfY29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcblxuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBwYWRzLFxuICAgIHN0cmlkZXMsXG4gICAgd0lzQ29uc3QsXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259O2AsXG4gIH07XG59O1xuXG5jb25zdCBjb252MmQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgLy8gY2hlY2sgYXR0cmlidXRlc1xuXG4gIC8vIGNvbnN0IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBmYWxzZTsgLyogVE9ETzogYWRkIHN1cHBvcnQgZm9yIHByZWx1IGFjdGl2YXRpb24gd2VpZ2h0cyAqL1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgaW5wdXRzWzFdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMsXG4gICAgYXR0cmlidXRlcy5wYWRzLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICBpc0NoYW5uZWxzTGFzdCxcbiAgKTtcbiAgaWYgKGF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEpIHtcbiAgICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXV07XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XG4gICAgICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICAgICAgfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBjb252SW5wdXRzLnB1c2godHJhbnNwb3NlZFdlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMV0pO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29udklucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICAgIC8vIE5WSURJQSBHUFUgd2l0aCBhbXBlcmUgYXJjaGl0ZWN0dXJlIGZhaWxzIHdpdGggYmVsb3cgMiBjYXNlcywgYnV0IHdlIGNvdWxkbid0IHJlcHJvIHRoZW0gd2l0aCBhbnkgb3RoZXJcbiAgICAvLyBHUFVzLiBTbyBqdXN0IGRpc2FibGUgdmVjdG9yaXplIG9uIE5WSURJQSBhbXBlcmUgdG8gZW5zdXJlIGFsd2F5cyBjb3JyZWN0IG91dHB1dHMuXG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIEJcbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gRFxuICAgIGNvbnN0IGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplID0gIWNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2FtcGVyZScpO1xuICAgIGlmIChcbiAgICAgIGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplICYmXG4gICAgICBpc0NoYW5uZWxzTGFzdCAmJlxuICAgICAgaW5wdXRzWzFdLmRpbXNbMF0gPT09IGF0dHJpYnV0ZXMuZ3JvdXAgJiZcbiAgICAgIGlucHV0c1sxXS5kaW1zWzFdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDFcbiAgICApIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyhjb252SW5wdXRzLCBhdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLFxuICAgICAgICB7IGlucHV0czogY29udklucHV0cyB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oY29udklucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKSwge1xuICAgICAgICBpbnB1dHM6IGNvbnZJbnB1dHMsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3QgaW5wdXRDaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBvdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXTtcbiAgY29uc3Qgb3V0V2lkdGggPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcblxuICBjb25zdCBzYW1lU2l6ZSA9XG4gICAgaXNDaGFubmVsc0xhc3QgJiZcbiAgICB3ZWlnaHRIZWlnaHQgPT09IGlucHV0SGVpZ2h0ICYmXG4gICAgd2VpZ2h0V2lkdGggPT09IGlucHV0V2lkdGggJiZcbiAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcbiAgICBhdHRyaWJ1dGVzLnBhZHNbMV0gPT09IDA7XG4gIGlmIChcbiAgICBzYW1lU2l6ZSB8fFxuICAgICh3ZWlnaHRIZWlnaHQgPT09IDEgJiZcbiAgICAgIHdlaWdodFdpZHRoID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuc3RyaWRlc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5zdHJpZGVzWzFdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcbiAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMClcbiAgKSB7XG4gICAgLy8gY29udjJkQnlNYXRNdWxcbiAgICBjb25zdCBiYXRjaCA9IG91dHB1dFNoYXBlWzBdO1xuICAgIGxldCB4UmVzaGFwZWQsIHdSZXNoYXBlZCwgbWF0bXVsT3V0cHV0U2hhcGU7XG4gICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW107XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XG4gICAgICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICAgICAgfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAoc2FtZVNpemUpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltID0gaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoICogaW5wdXRDaGFubmVscztcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoWzEsIGJhdGNoLCBzaGFyZWREaW1dKTtcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBzaGFyZWREaW0sIG91dENoYW5uZWxzXSk7XG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gWzEsIGJhdGNoLCBvdXRDaGFubmVsc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCwgaW5wdXRDaGFubmVsc10pO1xuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIGlucHV0Q2hhbm5lbHMsIG91dENoYW5uZWxzXSk7XG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gW2JhdGNoLCBvdXRIZWlnaHQgKiBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xuICAgICAgfVxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRDaGFubmVscywgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoXSk7XG4gICAgICB3UmVzaGFwZWQgPSBpbnB1dHNbMV0ucmVzaGFwZShbMSwgb3V0Q2hhbm5lbHMsIGlucHV0Q2hhbm5lbHNdKTtcbiAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gW2JhdGNoLCBvdXRDaGFubmVscywgb3V0SGVpZ2h0ICogb3V0V2lkdGhdO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgfVxuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgIH1cbiAgICBjb25zdCBOID0gbWF0bXVsT3V0cHV0U2hhcGVbMl07XG4gICAgY29uc3QgSyA9IG1hdG11bElucHV0c1swXS5kaW1zW21hdG11bElucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xuICAgIC8vIFR1bmUgdGhlIHRocmVzaG9sZC5cbiAgICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogaW1wbGVtZW50IGNvbnYyZFdpdGhJbTJDb2woKVxuXG4gIGNvbnN0IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSAvKiBiYWNrZW5kLmFkYXB0ZXJJbmZvLmlzSW50ZWwoKSAqLyB0cnVlO1xuXG4gIC8vIFNURVAuMTogdHJhbnNwb3NlIHdlaWdodFxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSwge1xuICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgIH0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udklucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnZJbnB1dHMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBkaW1BT3V0ZXIsXG4gICAgICBkaW1CT3V0ZXIsXG4gICAgICBkaW1Jbm5lcixcbiAgICAgIGhhc0JpYXMsXG4gICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXG4gICAgKSxcbiAgICB7IGlucHV0czogY29udklucHV0cyB9LFxuICApO1xufTtcblxuY29uc3QgY29udjFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxuICAgICksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgY29uc3QgcGFkcyA9IFswLCBhdHRyaWJ1dGVzLnBhZHNbMF0sIDAsIGF0dHJpYnV0ZXMucGFkc1sxXV07XG4gIGNvbnN0IHN0cmlkZXMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gIGNvbnN0IGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5kaWxhdGlvbnMpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoXG4gICAgeyAuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICBjb252MmQoY29udGV4dCwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIChvdXRwdXRTaGFwZSkgPT5cbiAgICBpc0NoYW5uZWxMYXN0ID8gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM11dIDogW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dLFxuICApO1xufTtcblxuY29uc3QgY29udjNkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/ICdjaGFubmVsc0xhc3QnIDogJ2NoYW5uZWxzRmlyc3QnO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLmF1dG9QYWQgPT09ICdOT1RTRVQnID8gYXR0cmlidXRlcy5wYWRzIDogYXR0cmlidXRlcy5hdXRvUGFkO1xuICBjb25zdCBjb252SW5mbyA9IGNvbXB1dGVDb252M0RJbmZvKFxuICAgIGlucHV0c1swXS5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgaW5wdXRzWzFdLmRpbXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBwYWRzIGFzIHN0cmluZyB8IG51bWJlcltdLFxuICAgIGZhbHNlLFxuICAgIGZvcm1hdCxcbiAgKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8oXG4gICAgICBpbnB1dHMsXG4gICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICBjb252SW5mby5vdXRTaGFwZSxcbiAgICAgIFtjb252SW5mby5maWx0ZXJEZXB0aCwgY29udkluZm8uZmlsdGVySGVpZ2h0LCBjb252SW5mby5maWx0ZXJXaWR0aF0sXG4gICAgICBbY29udkluZm8ucGFkSW5mby5mcm9udCwgY29udkluZm8ucGFkSW5mby50b3AsIGNvbnZJbmZvLnBhZEluZm8ubGVmdF0sXG4gICAgICBmb3JtYXQsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb252ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgIGNvbnYxZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIGNvbnYzZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBjb250ZXh0LmlucHV0cyk7XG4gICAgY29udjJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xuICB9XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252X2JhY2twcm9wX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHsgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCB9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQgeyBiaWFzU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRUcmFuc3Bvc2VDb21tb25TbmlwcGV0ID0gKFxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcbiAgYWRkQmlhcyA9IGZhbHNlLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgdHlwZTogc3RyaW5nLFxuICBpbm5lckVsZW1lbnRTaXplID0gNCxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTsnO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IGNvb3JkMSA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMSwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMiA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMiwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMyA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMywgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IHYwID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjEgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMSwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjIgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMiwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjMgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMywgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICByZXR1cm4gJHt0eXBlfSh2MCwgdjEsIHYyLCB2Myk7XG4gICAgICAgICAgICBgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gYFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcbiAgICAgIGBcbiAgICA6IGBcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCBpWFIsIGlYQyk7XG4gICAgICBgO1xuXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcblxuICBjb25zdCByZWFkQVNuaXBwZXQgPSBgXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknfTtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XG4gICAgICBsZXQgb3V0Q29sID0gJHtyb3d9ICUgb3V0V2lkdGg7XG5cbiAgICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcbiAgICAgIGxldCB4UiA9IGYzMihvdXRSb3cgLSB1bmlmb3Jtcy5wYWRzWzBdICsgdW5pZm9ybXMuZGlsYXRpb25zWzBdICogV1JvdykgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gdW5pZm9ybXMucGFkc1sxXSArIHVuaWZvcm1zLmRpbGF0aW9uc1sxXSAqIFdDb2wpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pO1xuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke3hIZWlnaHR9KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHt4V2lkdGh9KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dO2A7XG5cbiAgY29uc3Qgc2FtcGxlQSA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgICAke3JlYWRBU25pcHBldH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3R5cGV9KDAuMCk7YFxuICAgIDogYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgJHtyZWFkQVNuaXBwZXR9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlfSgwLjApO2A7XG5cbiAgY29uc3Qgc2FtcGxlVyA9IGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknfTtcbiAgICAgIGxldCBjb29yZFggPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXSAtIDEgLSByb3cgLyAodW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBjb29yZFkgPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAtIDEgLSAocm93IC8gaW5DaGFubmVscykgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcbiAgICAgIGlmICgke1xuICAgICAgICBpc0NoYW5uZWxzTGFzdFxuICAgICAgICAgID8gJ3JvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcidcbiAgICAgICAgICA6ICdyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXInXG4gICAgICB9ICAmJiBjb29yZFggPj0gMCAmJiBjb29yZFkgPj0gMCkge1xuICAgICAgICBsZXQgcm93SW5uZXIgPSByb3cgJSBpbkNoYW5uZWxzO1xuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xuICAgICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIGA7XG5cbiAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgdHlwZSk7XG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlQSA6IHNhbXBsZVd9XG4gIH1cblxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZUF9XG4gIH1cblxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHt0eXBlfSkge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcywgdmVjNDxpMzI+KHVuaWZvcm1zLnJlc3VsdF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dID0gdmFsdWU7XG4gICAgfVxuICB9YDtcbiAgcmV0dXJuIHVzZXJDb2RlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGltQU91dGVyOiBudW1iZXIsXG4gIGRpbUJPdXRlcjogbnVtYmVyLFxuICBkaW1Jbm5lcjogbnVtYmVyLFxuICBoYXNCaWFzOiBib29sZWFuLFxuICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzOiBib29sZWFuLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IG91dHB1dFNoYXBlWzBdO1xuICBjb25zdCBvdXRXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMl0gOiBvdXRwdXRTaGFwZVszXTtcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsxXSA6IG91dHB1dFNoYXBlWzJdO1xuICBjb25zdCBvdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQgZm9yIE5DSFdcbiAgY29uc3QgaXNWZWM0ID0gaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgPT09IDAgJiYgaW5DaGFubmVscyAlIDMgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udl9iYWNrcHJvcF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gNCA6IDE7XG4gIGNvbnN0IHRpbGVJbm5lciA9IE1hdGgubWF4KHdvcmtHcm91cFNpemVbMF0gKiBpbm5lckVsZW1lbnRTaXplLCB3b3JrR3JvdXBTaXplWzFdKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICBjb25zdCBmaWx0ZXJEaW1zID0gW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zID0gW1xuICAgIGZpbHRlckRpbXNbMF0gKyAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPD0gMSA/IDAgOiAoZmlsdGVyRGltc1swXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIC0gMSkpLFxuICAgIGZpbHRlckRpbXNbMV0gKyAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMSA/IDAgOiAoZmlsdGVyRGltc1sxXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpLFxuICBdO1xuICBjb25zdCBwYWRzID0gW1xuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzBdICsgYXR0cmlidXRlcy5wYWRzWzJdKSAvIDIpLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzFdICsgYXR0cmlidXRlcy5wYWRzWzNdKSAvIDIpLFxuICBdO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcblxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCAxKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW3gsIHddO1xuXG4gICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSAnJztcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xuICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtiaWFzLnR5cGUudmFsdWV9IHtcbiAgICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgICAgICAgIH1gO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHBhZHMubGVuZ3RoIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgIGNvbnN0IGVsZW1UeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSwgMSk7XG4gICAgaWYgKGVsZW1UeXBlICE9PSAnZjE2JyAmJiBlbGVtVHlwZSAhPT0gJ2YzMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWxlbVR5cGUgJHtlbGVtVHlwZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHt1dGlsRnVuY3Rpb25zKCd1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlcycpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfTtcbiAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAke2NvbnYyZFRyYW5zcG9zZUNvbW1vblNuaXBwZXQoaXNDaGFubmVsc0xhc3QsIGhhc0JpYXMsIGF0dHJpYnV0ZXMsIHgudHlwZS52YWx1ZSwgaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgICAgICR7XG4gICAgICAgICAgaXNWZWM0XG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgZWxlbVR5cGUsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICFpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICAgICAgICB0aWxlSW5uZXIsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCxcbiAgICAgICAgICAgICAgICB3b3JrR3JvdXBTaXplLFxuICAgICAgICAgICAgICAgIGVsZW1UeXBlLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAhaXNDaGFubmVsc0xhc3QsXG4gICAgICAgICAgICAgICAgdGlsZUlubmVyLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICAgICAgICAgICApXG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbnYyRFRyYW5zcG9zZU1hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtlbGVtZW50c1BlclRocmVhZH07JHt3b3JrR3JvdXBTaXplfTske2lzVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuXG5jb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRPcFByb2dyYW1TaGFkZXJTb3VyY2UgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBoYXNCaWFzOiBib29sZWFuLFxuICBpczFEaW1lbnNpb25EaXNwYXRjaDogYm9vbGVhbixcbiAgaXNWZWM0ID0gZmFsc2UsXG4gIGRhdGFUeXBlOiBzdHJpbmcsXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gIGNvbnN0IGNoYW5uZWxEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDMgOiAxO1xuICBjb25zdCB3b3JrUGVyVGhyZWFkID0gaXNWZWM0ID8gMiA6IDE7XG5cbiAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogdTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHtkYXRhVHlwZX0+YCA6IGRhdGFUeXBlfSkge1xuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9KHZhbHVlKTtcbiAgfWA7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9IHtcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgIH1gO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGR5ID0gaW5wdXRWYXJpYWJsZSgnRHknLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2R5LCB3XTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIFtvdXRwdXRTaGFwZVtjaGFubmVsRGltXV0ubGVuZ3RoLCBjb21wb25lbnRzKSk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICBjb25zdCBjb2RlU25pcHBldDQgPSBge1xuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLnonIDogJ3dvcmtncm91cF9pZC56J30gLyB1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMV07XG4gICAgICAgIGxldCByID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueicgOiAnd29ya2dyb3VwX2lkLnonfSAlIHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsxXTtcbiAgICAgICAgbGV0IGMgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC55JyA6ICd3b3JrZ3JvdXBfaWQueSd9ICogJHt3b3JrUGVyVGhyZWFkfTtcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC54JyA6ICd3b3JrZ3JvdXBfaWQueCd9ICogNDtcblxuICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdmVjMjxpMzI+KHVuaWZvcm1zLnBhZHMpO1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgdmFyIGRvdFByb2Q6IGFycmF5PHZlYzQ8JHtkYXRhVHlwZX0+LCAke3dvcmtQZXJUaHJlYWR9PjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3dvcmtQZXJUaHJlYWR9OyBpKyspIHtcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICB2YXIgZHlSID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLngpICsgJHtkYXRhVHlwZX0od1IpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueCk7XG4gICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWzFdKSB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDb3JuZXIueSkgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCBkeUMyID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLnkpICsgMS4wICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gd0M7XG4gICAgICAgICAgICBpZiAod0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiRHlDVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiRHlDVmFsMiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVsyXSkgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG5cbiAgICAgICAgICAgICAgICB4VmFsdWUgPSAgJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QzInLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IHVuaWZvcm1zLkR5X3NoYXBlWyR7Y2hhbm5lbERpbX1dO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAyJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAzJywgJ2QyJyl9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7ZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2RhdGFUeXBlfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7d29ya1BlclRocmVhZH07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke2hhc0JpYXMgPyAnYmlhc1tjK2ldJyA6IGB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApYH07XG4gICAgICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyJywgJ2MgKyBpJywgJ2QxJywgJ3ZhbHVlJyl9O1xuICAgICAgICB9XG4gICAgICB9YDtcbiAgY29uc3QgY29kZVNuaXBwZXQgPSBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgbGV0IGJhdGNoID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIDApfTtcbiAgICAgICAgICBsZXQgZDEgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY2hhbm5lbERpbSl9O1xuICAgICAgICAgIGxldCByID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIHJvd0RpbSl9O1xuICAgICAgICAgIGxldCBjID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNvbERpbSl9O1xuICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgdmFyIGRvdFByb2QgPSAke2RhdGFUeXBlfSgwLjApO1xuICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkYXRhVHlwZX0oZHlSQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVske3Jvd0RpbX1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7ZGF0YVR5cGV9KGR5Q0Nvcm5lcikgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtjb2xEaW19XSkgfHxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtcbiAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0XG4gICAgICAgICAgICAgICAgICAgID8gZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnaW5wdXRDaGFubmVsJylcbiAgICAgICAgICAgICAgICAgICAgOiBkeS5nZXQoJ2JhdGNoJywgJ2lucHV0Q2hhbm5lbCcsICdpZHlSJywgJ2lkeUMnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXQoJ2lucHV0Q2hhbm5lbCcsICd3T3V0Q2hhbm5lbCcsICd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScpfTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke2hhc0JpYXMgPyAnYmlhc1tkMV0nIDogYCR7ZGF0YVR5cGV9KDAuMClgfTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgICAgYDtcblxuICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke2RlY2xhcmVGdW5jdGlvbnN9XG5cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfTtcbiAgJHtpc1ZlYzQgPyBjb2RlU25pcHBldDQgOiBjb2RlU25pcHBldH19YDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIC8vIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIC8vIGNvbnN0IGluQ2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgLy8gVE9ETyBFbmFibGUgaXNWZWM0IGZvciBwZXJmb3JtYW5jZVxuICAvLyBEaXNhYmxlZCBkdWUgdG8gd2VpZ2h0IG1hdHJpeCBsYXlvdXQgaXNzdWVcbiAgLy8gY29uc3QgaXNWZWM0ID0gYXR0cmlidXRlcy5ncm91cCA9PT0gMSAmJiBpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCA9PT0gMCAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XG4gIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChvdXRwdXRTaXplIC8gNjQpLCAxLCAxXTtcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gIGNvbnN0IHN0cmlkZXMgPSBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dO1xuICBjb25zdCBmaWx0ZXJEaW1zID0gW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICBjb25zdCBkaWxhdGlvbnMgPSBbYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0sIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdXTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA9IFtcbiAgICBmaWx0ZXJEaW1zWzBdICtcbiAgICAgIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA8PSAxXG4gICAgICAgID8gMFxuICAgICAgICA6IChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gLSAxKSksXG4gICAgZmlsdGVyRGltc1sxXSArXG4gICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMVxuICAgICAgICA/IDBcbiAgICAgICAgOiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpLFxuICBdO1xuICBjb25zdCBwYWRzID0gW1xuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzBdICsgYXR0cmlidXRlcy5wYWRzWzJdKSAvIDIpLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcihhdHRyaWJ1dGVzLnBhZHNbMV0gKyBhdHRyaWJ1dGVzLnBhZHNbM10pIC8gMixcbiAgXTtcblxuICBjb25zdCBpc1ZlYzQgPSBmYWxzZTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gZ3JvdXA7XG4gIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMV07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0cmlkZXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaWxhdGlvbnMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWZmZWN0aXZlRmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpLFxuICBdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBkaXNwYXRjaFsxXSA9PT0gMSAmJiBkaXNwYXRjaFsyXSA9PT0gMTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZWZmZWN0aXZlX2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZWZmZWN0aXZlRmlsdGVyRGltcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICByZXR1cm4gYCR7Y3JlYXRlQ29udlRyYW5zcG9zZTJET3BQcm9ncmFtU2hhZGVyU291cmNlKFxuICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBoYXNCaWFzLFxuICAgICAgaXMxRGltZW5zaW9uRGlzcGF0Y2gsXG4gICAgICBpc1ZlYzQsXG4gICAgICBkYXRhVHlwZSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgKX1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdDb252VHJhbnNwb3NlMkQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9O2AsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF9tbV93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX3dlYmdwdSc7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGNvbXB1dGVUb3RhbFBhZCA9IChcbiAgaW5EaW06IG51bWJlcixcbiAgc3RyaWRlOiBudW1iZXIsXG4gIGFkajogbnVtYmVyLFxuICBrZXJuZWw6IG51bWJlcixcbiAgZGlsYXRpb246IG51bWJlcixcbiAgb3V0U2l6ZTogbnVtYmVyLFxuKSA9PiAoaW5EaW0gLSAxKSAqIHN0cmlkZSArIGFkaiArIChrZXJuZWwgLSAxKSAqIGRpbGF0aW9uICsgMSAtIG91dFNpemU7XG5cbmNvbnN0IGRpc3RyaWJ1dGVQYWRkaW5nID0gKHRvdGFsUGFkOiBudW1iZXIsIGF1dG9QYWQ6IHN0cmluZywgcGFkczogbnVtYmVyW10sIGhlYWQ6IG51bWJlciwgdGFpbDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHNtYWxsUGFkID0gTWF0aC5mbG9vcih0b3RhbFBhZCAvIDIpO1xuICBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICB9IGVsc2UgaWYgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykge1xuICAgIHBhZHNbaGVhZF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSBzbWFsbFBhZDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzID0gKFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdXRvUGFkOiBzdHJpbmcsXG4gIGdyb3VwOiBudW1iZXIsXG4gIHBhZHM6IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcbiAgb3V0cHV0UGFkZGluZzogbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbikgPT4ge1xuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoIC0gMjtcbiAgY29uc3QgdXBkYXRlT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDA7XG4gIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA8IHNwYXRpYWxSYW5rKSB7XG4gICAgb3V0cHV0UGFkZGluZy5wdXNoKC4uLkFycmF5KHNwYXRpYWxSYW5rIC0gb3V0cHV0UGFkZGluZy5sZW5ndGgpLmZpbGwoMCkpO1xuICB9XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbaXNDaGFubmVsTGFzdCA/IDMgOiAxXSAqIGdyb3VwO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGlucHV0U2hhcGUubGVuZ3RoIC0gc3BhdGlhbFJhbmsgLSAoaXNDaGFubmVsTGFzdCA/IDEgOiAwKTsgaSA8IHNwYXRpYWxSYW5rOyArK2ksICsraikge1xuICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XG4gICAgY29uc3Qgb3V0U2l6ZSA9IHVwZGF0ZU91dHB1dFNoYXBlID8gaW5TaXplICogc3RyaWRlc1tpXSA6IG91dHB1dFNoYXBlW2ldO1xuICAgIGNvbnN0IHRvdGFsUGFkID0gY29tcHV0ZVRvdGFsUGFkKGluU2l6ZSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbal0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgaWYgKHVwZGF0ZU91dHB1dFNoYXBlKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICBzdHJpZGVzW2ldICogKGluU2l6ZSAtIDEpICtcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nW2ldICtcbiAgICAgICAgICAoa2VybmVsU2hhcGVbal0gLSAxKSAqIGRpbGF0aW9uc1tpXSArXG4gICAgICAgICAgMSAtXG4gICAgICAgICAgcGFkc1tpXSAtXG4gICAgICAgICAgcGFkc1tpICsgc3BhdGlhbFJhbmtdLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBDb252QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihcbiAgYXR0cmlidXRlczogVCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoMCwgMCwgaW5wdXRzWzFdLmRpbXNbMF0pO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoaXNDaGFubmVsc0xhc3QgPyAzIDogMSwgMCwgaW5wdXRzWzFdLmRpbXNbMV0pO1xuXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcuc2xpY2UoKTtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBsZXQgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMuc2xpY2UoKTtcbiAgaWYgKGRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICBkaWxhdGlvbnMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgaWYgKHN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgfVxuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgaW5wdXRTaGFwZSxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBkaWxhdGlvbnMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICAgIGF0dHJpYnV0ZXMuZ3JvdXAsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSwgZGlsYXRpb25zLCBzdHJpZGVzIH0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVtcbiAgICB0eXBlb2YgYXR0cmlidXRlcy5hdXRvUGFkID09ICd1bmRlZmluZWQnID8gMCA6IChhdHRyaWJ1dGVzLmF1dG9QYWQgYXMgbnVtYmVyKVxuICBdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndJc0NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBvdXRwdXRQYWRkaW5nLFxuICAgIG91dHB1dFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICB3SXNDb25zdCxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YCxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252VHJhbnNwb3NlXG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIGNvbnN0IGRpbGF0aW9uc1NldCA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoZGlsYXRpb25zU2V0ICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICBjb25zdCBzdHJpZGVzU2V0ID0gYXR0cmlidXRlcy5zdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKHN0cmlkZXNTZXQgJiYgYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgY29uc3QgcGFkc1NldCA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIGlmIChwYWRzU2V0ICYmIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAmJiBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBjb25zdCBrZXJuZWxTaGFwZVNldCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICBpZiAoXG4gICAga2VybmVsU2hhcGVTZXQgJiZcbiAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJlxuICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxuXG4gIC8vIGFzIHdpdGgga2VybmVsU2hhcGUsIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzcGF0aWFsIGRpbXMgYXMgaW5wdXRcbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCBzaGFwZScpO1xuICB9XG59O1xuXG4vLyBmb3IgdHJhbnNwb3Npbmcgd2VpZ2h0IHRlbnNvciBmcm9tIFtDLCBNL2dyb3VwLCBLSCwgS1ddIHRvIFtLSCwgS1csIE0vZ3JvdXAsIENdXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VQZXJtID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCBjb252VHJhbnNwb3NlMmQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYWRqdXN0ZWRBdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCBpbnB1dENoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG4gIC8vIFN3aXRjaCB0byBuYWl2ZSBtZXRob2Qgd2hlbiBvdXRDaGFubmVscyBhbmQgaW5wdXRDaGFubmVscyBhcmUgdmVyeSBzbWFsbC4gSXQncyBiZWNhdXNlIHRoYXQgaW4gdGhpcyBjYXNlIGl0J3NcbiAgLy8gbm90IHN1aXRhYmxlIGZvciBtYXRtdWwgdmVyc2lvbiBzaW5jZSBtYXRtdWwgdXNlcyB0aWxlIHNpemUgMzJ4MzIgcmVzdWx0aW5nIHRoZSB1bmRlcmx5aW5nIGV4ZWN1dGlvbiB1bml0XG4gIC8vIHV0aWxpemF0aW9uIHJhdGUgaXMgdmVyeSBsb3cuXG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEgfHwgKG91dENoYW5uZWxzID09PSAxICYmIGlucHV0Q2hhbm5lbHMgPT09IDEpKSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbnZUcmFuc3Bvc2UyRFByb2dyYW1JbmZvKGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG91dEhlaWdodCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG5cbiAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxuICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VQZXJtKSwge1xuICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgIH0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udlRyYW5zcG9zZUlucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA9PT0gMztcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBpZiAoIWlzQ2hhbm5lbHNMYXN0ICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXS5yZXNoYXBlKFtpbnB1dHNbMl0uZGltc1swXSwgMSwgMV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlQ29udjJEVHJhbnNwb3NlTWF0TXVsUHJvZ3JhbUluZm8oXG4gICAgICBjb252VHJhbnNwb3NlSW5wdXRzLFxuICAgICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBkaW1BT3V0ZXIsXG4gICAgICBkaW1CT3V0ZXIsXG4gICAgICBkaW1Jbm5lcixcbiAgICAgIGhhc0JpYXMsXG4gICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICksXG4gICAgeyBpbnB1dHM6IGNvbnZUcmFuc3Bvc2VJbnB1dHMgfSxcbiAgKTtcbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG5cbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxuICAgICksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgbGV0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZTtcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBrZXJuZWxTaGFwZVswXSA9PT0gMCkge1xuICAgIGtlcm5lbFNoYXBlID0gW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dO1xuICB9XG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucztcbiAgaWYgKGRpbGF0aW9ucy5sZW5ndGggPT09IDAgfHwgZGlsYXRpb25zWzBdID09PSAwKSB7XG4gICAgZGlsYXRpb25zID0gWzFdO1xuICB9XG4gIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzO1xuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDAgfHwgc3RyaWRlc1swXSA9PT0gMCkge1xuICAgIHN0cmlkZXMgPSBbMV07XG4gIH1cbiAgbGV0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHM7XG4gIGlmIChwYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHBhZHMgPSBbMCwgMF07XG4gIH1cbiAgcGFkcyA9IFswLCBwYWRzWzBdLCAwLCBwYWRzWzFdXTtcbiAgc3RyaWRlcyA9IFsxXS5jb25jYXQoc3RyaWRlcyk7XG4gIGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoZGlsYXRpb25zKTtcbiAga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGtlcm5lbFNoYXBlKTtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhcbiAgICB7IC4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgKG91dHB1dFNoYXBlKSA9PlxuICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXVxuICAgICAgICA6IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzNdXSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgY29udlRyYW5zcG9zZTFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnZUcmFuc3Bvc2UyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEN1bVN1bUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBleGNsdXNpdmU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJldmVyc2U6IGJvb2xlYW47XG59XG5jb25zdCBjcmVhdGVDdW1zdW1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRUeXBlOiBudW1iZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBheGlzSW5wdXQ6IFRlbnNvclZpZXcsXG4gIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTsgLy8gb3V0cHV0U2hhcGUgaXMgc2FtZSBhcyBpbnB1dFNoYXBlLlxuICBjb25zdCByYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7IC8vIGlucHV0L291dHB1dCByYW5rXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFR5cGUsIHJhbmspO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgY29uc3QgYXhpc1ZhbHVlID1cbiAgICBheGlzSW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyID8gYXhpc0lucHV0LmdldEludDMyQXJyYXkoKVswXSA6IE51bWJlcihheGlzSW5wdXQuZ2V0QmlnSW50NjRBcnJheSgpWzBdKTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXNWYWx1ZSwgcmFuayk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYCBpMzIoJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfSkgYDtcbiAgICBjb25zdCBtYXggPSBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ3VuaWZvcm1zLmF4aXMnLCByYW5rKTtcbiAgICBjb25zdCBsb3dlckxpbWl0ID0gYXR0cmlidXRlcy5yZXZlcnNlID8gaW5kZXggKyAoYXR0cmlidXRlcy5leGNsdXNpdmUgPyAnICsgMScgOiAnJykgOiAnMCc7XG4gICAgY29uc3QgdXBwZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IG1heCA6IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJycgOiAnICsgMScpO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7bG93ZXJMaW1pdH07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7dXBwZXJMaW1pdH07XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaSknKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdzdW0nKX07XG4gICAgICAgICAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0N1bVN1bScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5wdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjdW1zdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gY29udGV4dC5pbnB1dHNbMV07XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDdW1zdW1Qcm9ncmFtSW5mbyhpbnB1dFR5cGUsIGlucHV0U2hhcGUsIGF4aXMsIGF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ3VtU3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEN1bVN1bUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBleGNsdXNpdmUgPSAoYXR0cmlidXRlcy5leGNsdXNpdmUgYXMgbnVtYmVyKSA9PT0gMTtcbiAgY29uc3QgcmV2ZXJzZSA9IChhdHRyaWJ1dGVzLnJldmVyc2UgYXMgbnVtYmVyKSA9PT0gMTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGV4Y2x1c2l2ZSwgcmV2ZXJzZSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGJsb2Nrc2l6ZTogbnVtYmVyO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC4nKTtcbiAgfVxufTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmV2ZXJzZUZ1bmMgPSBbXTtcbiAgcmV2ZXJzZUZ1bmMucHVzaChgZm4gcGVybShpOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdhJywgcGVybVtpXSwgYGlbJHtpfV1gKSk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgncmV0dXJuIGE7fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgbGV0IG46IG51bWJlciwgaDogbnVtYmVyLCB3OiBudW1iZXIsIGM6IG51bWJlcjtcbiAgbGV0IHNoYXBlOiBudW1iZXJbXTtcbiAgbGV0IHBlcm06IG51bWJlcltdO1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgYmxvY2tzaXplID0gYXR0cmlidXRlcy5ibG9ja3NpemU7XG4gIGNvbnN0IGlzRENSbW9kZSA9IGF0dHJpYnV0ZXMubW9kZSA9PT0gJ0RDUic7XG4gIGlmIChpc0NoYW5uZWxMYXN0KSB7XG4gICAgW24sIGgsIHcsIGNdID0gaW5wdXRUZW5zb3IuZGltcztcbiAgICBzaGFwZSA9IGlzRENSbW9kZVxuICAgICAgPyBbbiwgaCwgdywgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMl1cbiAgICAgIDogW24sIGgsIHcsIGMgLyBibG9ja3NpemUgKiogMiwgYmxvY2tzaXplLCBibG9ja3NpemVdO1xuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMSwgMywgMiwgNCwgNV0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gIH0gZWxzZSB7XG4gICAgW24sIGgsIHcsIGNdID0gW2lucHV0VGVuc29yLmRpbXNbMF0sIGlucHV0VGVuc29yLmRpbXNbMl0sIGlucHV0VGVuc29yLmRpbXNbM10sIGlucHV0VGVuc29yLmRpbXNbMV1dO1xuICAgIHNoYXBlID0gaXNEQ1Jtb2RlXG4gICAgICA/IFtuLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBoLCB3XVxuICAgICAgOiBbbiwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaCwgd107XG4gICAgcGVybSA9IGlzRENSbW9kZSA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgfVxuICBjb25zdCByZXNoYXBlZElucHV0VGVuc29yID0gaW5wdXRUZW5zb3IucmVzaGFwZShzaGFwZSk7XG4gIGNvbnN0IHJlc2hhcGVkSW5wdXRSYW5rID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zLmxlbmd0aDtcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xuXG4gIGNvbnN0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuICBjb25zdCBwZXJtZWRPdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMocmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgcmVzaGFwZWRJbnB1dFJhbmssIHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtwZXJtZWRPdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3Blcm1lZE91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHJlc2hhcGVkSW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVwdGhUb1NwYWNlJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7aW5wdXRUZW5zb3IuZGltc307JHthdHRyaWJ1dGVzLmJsb2Nrc2l6ZX07JHthdHRyaWJ1dGVzLm1vZGV9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaXNDaGFubmVsTGFzdFxuICAgICAgICA/IFtuLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDJdXG4gICAgICAgIDogW24sIGMgLyBibG9ja3NpemUgKiogMiwgaCAqIGJsb2Nrc2l6ZSwgdyAqIGJsb2Nrc2l6ZV07XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qgc2hhcGVCZWZvcmVQZXJtID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zO1xuICAgICAgY29uc3Qgc2hhcGVBZnRlclBlcm0gPSBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKHNoYXBlQmVmb3JlUGVybSwgcGVybSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHNoYXBlQmVmb3JlUGVybSwgc2hhcGVBZnRlclBlcm0pLFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXB0aFRvU3BhY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRGVwdGhUb1NwYWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYmxvY2tzaXplOiBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZSBhcyBudW1iZXIsXG4gICAgbW9kZTogYXR0cmlidXRlcy5tb2RlIGFzIHN0cmluZyxcbiAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJyxcbiAgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWluc3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmc7XG59XG4vLyBUaGUgZXF1YXRpb24gYXR0cmlidXRlIHZhbHVlIGlzIGEgc3RyaW5nIHdoaWNoIGNvbnNpc3RzIG9mIGxlZnQgaGFuZCBzaWRlIChMSFMpIGFuZCBvcHRpb25hbGx5IHJpZ2h0IGhhbmQgc2lkZSAoUkhTKVxuLy8gc2VwYXJhdGVkIGJ5ICctPicuIEV4LiBcImlqLGprIC0+IGlrXCIgZXhwcmVzc2VzIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuLy8gICAgIFwiaWotPmppXCIgZXhwcmVzc2VzIG1hdHJpeCB0cmFuc3Bvc2Vcbi8vICAgICAgXCJpaS0+aVwiIGRpYWdvbmFsIGVsZW1lbnRzIG9mIGEgc3F1YXJlIG1hdHJpeFxuLy8gTEhTIGNvbnNpc3RzIG9mIGEgc2VxdWVuY2Ugb2YgdGVybXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gRWFjaCB0ZXJtIGNvcnJlc3BvbmRzIHRvIGFuIGlucHV0IHZhcmlhYmxlLlxuLy8gRWFjaCBzeW1ib2wgY29ycmVzcG9uZHMgdG8gYSBkaW1lbnNpb24gaW4gdGhlIGlucHV0IHZhcmlhYmxlLiBUaGUgc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0ZXIsICdhJyB0byAneicgb3IgJ0EnIHRvXG4vLyAnWicgb3IgJy4uLicgdG8gcmVwcmVzZW50IGFyYml0cmFyeSBkaW1lbnNpb25zLlxuXG5jb25zdCBzeW1ib2xQYXR0ZXJuID0gJ1thLXpBLVpdfFxcXFwuXFxcXC5cXFxcLic7IC8vIFRoZSBwYXR0ZXJuIGVhY2ggc3ltYm9sIGluIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXG5jb25zdCB0ZXJtUGF0dGVybiA9ICcoJyArIHN5bWJvbFBhdHRlcm4gKyAnKSsnOyAvLyBUaGUgcGF0dGVybiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxuY29uc3QgdGVybVBhdHRlcm5Pbmx5ID0gJ14nICsgdGVybVBhdHRlcm4gKyAnJCc7IC8vIFRoZSBwYXR0ZXJucyBvbmx5IG1hdGNocyBhIHRlcm0gYmVnaW4gdG8gZW5kLlxuY29uc3QgbGhzUGF0dGVybiA9ICcoJyArIHRlcm1QYXR0ZXJuICsgJywpKicgKyB0ZXJtUGF0dGVybjsgLy8gVGhlIHBhdHRlcm4gdGhlIExIUyBzaG91bGQgbWF0Y2hcbmNvbnN0IGxoc1BhdHRlcm5Pbmx5ID0gJ14nICsgbGhzUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hzIGEgTEhTIGJlZ2luIHRvIGVuZC5cblxuaW50ZXJmYWNlIFN5bWJvbEluZm8ge1xuICBjb3VudDogbnVtYmVyOyAvLyBTeW1ib2wgY29ycmVzcG9uZGluZyB0byBhIGRpbW1lbnNpb24gb2YgYW4gaW5wdXRcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXTsgLy8gTnVtYmVyIG9mIGlucHV0IHZhcmlhYmxlcyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXG4gIGRpbVZhbHVlOiBudW1iZXI7IC8vIE51bWJlciBvZiBkaW1lbnNpb25zIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbn1cblxuY2xhc3MgRWluc3VtVGVybSB7XG4gIGNvbnN0cnVjdG9yKGlucHV0SW5kZXggPSAtMSkge1xuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcltdPigpO1xuICAgIHRoaXMuaW5wdXRJbmRleCA9IGlucHV0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIHRlcm1cbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUucHVzaChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5kaWNlczogTWFwPHN0cmluZywgbnVtYmVyW10+OyAvLyBNYXAgZnJvbSBzeW1ib2wgdG8gZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgY29ycmVzcG9uZGluZyB0byB0aGUgdGVybVxuICBpbnB1dEluZGV4OiBudW1iZXI7IC8vIC0xIGZvciBvdXRwdXQgYW5kIDAsIDEsIDIsIC4uLiBmb3IgaW5wdXRzXG59XG5cbmNsYXNzIEVpbnN1bUVxdWF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gICAgcHVibGljIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmcsXG4gICkge1xuICAgIHRoaXMuaGFzRWxsaXBzaXMgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbFRvSW5mbyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPigpO1xuICAgIHRoaXMubGhzID0gbmV3IEFycmF5PEVpbnN1bVRlcm0+KCk7XG4gICAgdGhpcy5vdXRwdXREaW1zID0gW107XG4gICAgLy8gQXMgcmhzIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYWxsb3cgdXNpbmcgbGV0IGluc3RlYWQgb2YgY29uc3QgZm9yIGJvdGggbGhzIGFuZCByaHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBbbGhzLCByaHNdID0gZXF1YXRpb24uaW5jbHVkZXMoJy0+JykgPyBlcXVhdGlvbi5zcGxpdCgnLT4nLCAyKSA6IFtlcXVhdGlvbiwgJyddO1xuICAgIGlmICghbGhzLm1hdGNoKFJlZ0V4cChsaHNQYXR0ZXJuT25seSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRUZXJtcyA9IGxocy5zcGxpdCgnLCcpO1xuICAgIGlucHV0VGVybXMuZm9yRWFjaCgoaW5wdXRUZXJtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGltcyA9IGlucHV0c1tpbmRleF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKCFpbnB1dFRlcm0ubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuT25seSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWluc3VtVGVybSA9IHRoaXMucHJvY2Vzc1Rlcm0oaW5wdXRUZXJtLCB0cnVlLCBkaW1zLCBpbmRleCk7XG4gICAgICB0aGlzLmxocy5wdXNoKGVpbnN1bVRlcm0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgUkhTIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAocmhzID09PSAnJykge1xuICAgICAgLy8gQ29uc3RydWN0IFJIUyBmcm9tIExIUyB0ZXJtcy9zeW1ib2xzXG4gICAgICByaHMgKz0gWy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV1cbiAgICAgICAgLmZpbHRlcigoW3N5bSwgaW5mb10pID0+IGluZm8uY291bnQgPT09IDEgfHwgc3ltID09PSAnLi4uJylcbiAgICAgICAgLm1hcCgoW3N5bV0pID0+IHN5bSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJocy5tYXRjaChSZWdFeHAodGVybVBhdHRlcm4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBvdXRwdXQgZGltc1xuICAgIGNvbnN0IHJoc1N5bWJvbHMgPSByaHMubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIHJoc1N5bWJvbHM/LmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXREaW1zID0gdGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTIHN5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGltcy5wdXNoKGluZm8uZGltVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmhzID0gdGhpcy5wcm9jZXNzVGVybShyaHMsIGZhbHNlLCB0aGlzLm91dHB1dERpbXMpO1xuICB9IC8vIEVuZCBvZiBFaW5zdW1FcWF0aW9uIGNvbnN0cnVjdG9yXG5cbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSBlcXVhdGlvblxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGRpbVZhbHVlOiBudW1iZXIsIGlucHV0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8uZGltVmFsdWUgIT09IGRpbVZhbHVlICYmIGluZm8uY291bnQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uY291bnQrKztcbiAgICAgICAgaW5mby5pbnB1dEluZGljZXMucHVzaChpbnB1dEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHsgY291bnQ6IDEsIGRpbVZhbHVlLCBpbnB1dEluZGljZXM6IFtpbnB1dEluZGV4XSB9O1xuICAgIH1cbiAgICB0aGlzLnN5bWJvbFRvSW5mby5zZXQoc3ltYm9sLCBpbmZvKTtcbiAgfVxuXG4gIC8vIFByb2Nlc3Mgb25lIGlucHV0L291dHB1dCB0ZXJtXG4gIHByb2Nlc3NUZXJtKHRlcm06IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbiwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGluZGV4ID0gLTEpOiBFaW5zdW1UZXJtIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IGVsbGlwc2lzID0gZmFsc2U7XG4gICAgbGV0IGVsbGlwc2lzRGltcyA9IFtdO1xuICAgIGxldCBuZXh0RGltID0gMDtcbiAgICAvLyBGb3Igb3V0cHV0IGVtcHR5IHN0cmluZyBpcyBhbGxvd2VkIGJlY2F1c2UgdGhlIG91dHB1dCBtYXkgYmUgcmVkdWNlZCB0byBhIHNjYWxhciB2YWx1ZVxuICAgIGlmICghdGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkgJiYgIWlzSW5wdXQgJiYgdGVybSAhPT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleFN5bWJvbHMgPSB0ZXJtLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcbiAgICBjb25zdCBlaW5zdW1UZXJtID0gbmV3IEVpbnN1bVRlcm0oaW5kZXgpO1xuICAgIC8vIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dHJlLCAnYScgdG8gJ3onIG9yICdBJyB0byAnWicsIG9yICcuLi4nXG4gICAgaW5kZXhTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2w6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsbGlwc2lzRGltTGVuZ3RoID0gcmFuayAtIGluZGV4U3ltYm9scy5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZWxsaXBzaXNEaW1MZW5ndGggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxsaXBzaXNEaW1zID0gZGltcy5zbGljZShuZXh0RGltLCBuZXh0RGltICsgZWxsaXBzaXNEaW1MZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5oYXNFbGxpcHNpcykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAhPT0gZWxsaXBzaXNEaW1zLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSAhPT0gZWxsaXBzaXNEaW1zLnRvU3RyaW5nKClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgdGhpcy5oYXNFbGxpcHNpcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMgPSBlbGxpcHNpc0RpbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICcwJywgJzEnLCAnMicsICczJywgJzQnLCBldGMgdG8gcmVwcmVzZW50IGVsbGlwc2lzIGRpbWVuc2lvbnMgdG8gYXZvaWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsbGlwc2lzRGltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBqKTtcbiAgICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyBqKTtcbiAgICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyAodGhpcy5oYXNFbGxpcHNpcyA/IHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAtIDEgOiAwKSk7XG4gICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVpbnN1bVRlcm07XG4gIH1cblxuICBzeW1ib2xUb0luZm86IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+OyAvLyBBbGwgc3ltYm9scyBpbiB0aGUgZXF1YXRpb25cbiAgaGFzRWxsaXBzaXM6IGJvb2xlYW47IC8vIFRoZSBlcXVhdGlvbiBoYXMgZWxsaXBzaXMgb3Igbm90XG4gIGVsbGlwc2lzRGltczogbnVtYmVyW107IC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvbiBlbGxpcHNpcyBjb3JyZXNwb25kcyB0by5cbiAgbGhzOiBFaW5zdW1UZXJtW107IC8vIFRlcm1zIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgcmhzOiBFaW5zdW1UZXJtOyAvLyBUZXJtIG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXG4gIG91dHB1dERpbXM6IG51bWJlcltdOyAvLyBPdXRwdXQgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb25cbn0gLy8gRW5kIG9mIGNsYXNzIEVpbnN1bUVxdWF0aW9uXG5cbmNvbnN0IGFwcGVuZE1heCA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4gbmFtZSArICdfbWF4JztcblxuY29uc3QgY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0U2hhcGVzOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4sXG4gIGRhdGFUeXBlOiBudW1iZXIsXG4gIGVpbnN1bUVxdWF0aW9uOiBFaW5zdW1FcXVhdGlvbixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCByYW5rcyA9IGlucHV0U2hhcGVzLm1hcCgoZGltcykgPT4gZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFZhcnMgPSByYW5rcy5tYXAoKHJhbmssIGluZGV4KSA9PiBpbnB1dFZhcmlhYmxlKGBpbnB1dCR7aW5kZXh9YCwgZGF0YVR5cGUsIHJhbmspKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCB1bmlmb3Jtc1N5bWJvbHMgPSBbLi4uZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKFxuICAgIChzeW1ib2wpID0+ICFlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGluaXRQcm9kID0gJ3ZhciBwcm9kID0gMS4wOyc7XG4gICAgY29uc3QgaW5pdFN1bSA9ICd2YXIgc3VtID0gMC4wOyc7XG4gICAgY29uc3QgdXBkYXRlU3VtID0gJ3N1bSArPSBwcm9kOyc7XG4gICAgY29uc3QgcmVkdWNlT3BzU2V0SW5kaWNlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wSGVhZGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wRm9vdGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcENvbXB1dGU6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaXNSZWR1Y2VPcHNXaXRob3V0TG9vcCA9IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5zaXplID09PSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7XG4gICAgZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmZvckVhY2goKGluZm8sIHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpPy5bMF07XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlkeENvcHkucHVzaChcbiAgICAgICAgICAgICAgICAgIGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KFxuICAgICAgICAgICAgICAgICAgICBgaW5wdXQke2l9SW5kaWNlc2AsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICByZWR1Y2VPcHNTZXRJbmRpY2VzLnB1c2goYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgYCR7c3ltYm9sfWApfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWR1Y2VPcENvbXB1dGUucHVzaChgcHJvZCAqPSAke2lucHV0VmFyc1tpXS5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKX07YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVkdWNlT3BzTG9vcEhlYWRlcnMucHVzaChcbiAgICAgICAgICBgZm9yKHZhciAke3N5bWJvbH06IHUzMiA9IDA7ICR7c3ltYm9sfSA8IHVuaWZvcm1zLiR7YXBwZW5kTWF4KHN5bWJvbCl9OyAke3N5bWJvbH0rKykge2AsXG4gICAgICAgICk7XG4gICAgICAgIHJlZHVjZU9wc0xvb3BGb290ZXJzLnB1c2goJ30nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZWR1Y2VPcHMgPSBpc1JlZHVjZU9wc1dpdGhvdXRMb29wXG4gICAgICA/IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGBsZXQgc3VtID0gJHtpbnB1dFZhcnMubWFwKChpbnB1dFZhciwgaSkgPT4gaW5wdXRWYXIuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCkpLmpvaW4oJyAqICcpfTtgLFxuICAgICAgICBdXG4gICAgICA6IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGluaXRTdW0sXG4gICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEhlYWRlcnMsXG4gICAgICAgICAgLi4ucmVkdWNlT3BzU2V0SW5kaWNlcyxcbiAgICAgICAgICBpbml0UHJvZCxcbiAgICAgICAgICAuLi5yZWR1Y2VPcENvbXB1dGUsXG4gICAgICAgICAgdXBkYXRlU3VtLFxuICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BGb290ZXJzLFxuICAgICAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc1N5bWJvbHMubWFwKChzeW1ib2wpID0+ICh7IG5hbWU6IGAke2FwcGVuZE1heChzeW1ib2wpfWAsIHR5cGU6ICd1MzInIH0pKSlcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAke2lucHV0VmFycy5tYXAoKF92YXIsIGkpID0+IGB2YXIgaW5wdXQke2l9SW5kaWNlczogJHtpbnB1dFZhcnNbaV0udHlwZS5pbmRpY2VzfTtgKS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAgICR7cmVkdWNlT3BzLmpvaW4oJ1xcbicpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRWluc3VtJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBlaW5zdW1FcXVhdGlvbi5lcXVhdGlvbiwgaW5wdXREZXBlbmRlbmNpZXM6IGlucHV0U2hhcGVzLm1hcCgoKSA9PiAncmFuaycpIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgLy8gVGhlIHN5bWJvbHMgZnJvbSB1bmlmb3JtU3ltYm9scyBhcnJheSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBlaW5zdW1FcXVhdGlvbnMuc3ltYm9sVG9JbmZvIG1hcC4gVGhlXG4gICAgICAvLyBmaWx0ZXIgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgZGltVmFsdWUgaXMgbmV2ZXIgMC5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3Jtc0luaXQ6IFByb2dyYW1Vbmlmb3JtW10gPSB1bmlmb3Jtc1N5bWJvbHNcbiAgICAgICAgLmZpbHRlcigoc3ltYm9sKSA9PiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uaGFzKHN5bWJvbCkpXG4gICAgICAgIC5tYXAoKHN5bWJvbCkgPT4gKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDAgfSkpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gaW5wdXRTaGFwZXNcbiAgICAgICAgLm1hcCgoZGltcywgXykgPT4gWy4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXMpXSlcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpbnB1dFByb2dyYW1Vbmlmb3JtcykgPT4gYWNjLmNvbmNhdChpbnB1dFByb2dyYW1Vbmlmb3JtcyksIHByb2dyYW1Vbmlmb3Jtc0luaXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGVpbnN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRWluc3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBlaW5zdW1FcXVhdGlvbiA9IG5ldyBFaW5zdW1FcXVhdGlvbihjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5lcXVhdGlvbik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvKGlucHV0U2hhcGVzLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZWluc3VtRXF1YXRpb24sIG91dHB1dFNoYXBlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRWluc3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGVxdWF0aW9uID0gKGF0dHJpYnV0ZXMuZXF1YXRpb24gYXMgc3RyaW5nKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGVxdWF0aW9uIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuICBsZXQgc2hhcGVJbmRleCA9IHNoYXBlLmxlbmd0aCA8IGlucHV0U2hhcGUubGVuZ3RoID8gMCA6IHNoYXBlLmxlbmd0aCAtIGlucHV0U2hhcGUubGVuZ3RoO1xuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XG4gICAgaWYgKFxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAmJlxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcbiAgICAgIGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAhPT0gMVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dCcpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRTaGFwZSA9IChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBkaWZmID0gc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGg7XG4gIGNvbnN0IHNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUxW2ldKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlMi5sZW5ndGg7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUyW2ldID09PSAxID8gc2hhcGUxW2kgKyBkaWZmXSA6IHNoYXBlMltpXSk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gIGlucHV0U2hhcGUubGVuZ3RoID4gc2hhcGUubGVuZ3RoID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcblxuY29uc3QgY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2lucHV0LmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdkYXRhJyl9XG4gICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeU9mZnNldCgnaW5wdXRPZmZzZXQnKSl9XG4gICAgICB9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAke2Fzc2lnbm1lbnR9YDtcbiAgfTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gIF07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0V4cGFuZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7b3V0cHV0U2hhcGUubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZXhwYW5kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUV4cGFuZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgV09SS0dST1VQX1NJWkUsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCAqIGFzIHVuYXJ5IGZyb20gJy4vdW5hcnktb3AnO1xuXG4vLyBHRUxVIGlzIGRlZmluZWQgYXMgWT0wLjUqWCooMSt0YW5oKDAuNzk3ODg1KlgrMC4wMzU2NzcqWCpYKlgpKSwgd2hlcmUgWCBtYXkgcHJlLWFkZCBhIGJpYXMuXG5cbmNvbnN0IGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRUZW5zb3JzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpO1xuICBjb25zdCBiaWFzTGVuZ3RoID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzFdLmRpbXMpO1xuICAvLyBjYW4gb25seSB1c2UgdmVjNCB3aGVuIGJpYXMgbGVuZ3RoIGlzIG11bHRpcGxlIG9mIDRcbiAgY29uc3QgdXNlVmVjNCA9IGJpYXNMZW5ndGggJSA0ID09PSAwO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgZGF0YVR5cGUsIFsxXSwgNCk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBkYXRhVHlwZSwgWzFdLCA0KTtcbiAgICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBkYXRhVHlwZSwgWzFdLCA0KTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF92ZWNfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdiaWFzX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG5cbiAgICBjb25zdCBzaW5nbGVFbGVtZW50QmlhcyA9IChpOiAwIHwgMSB8IDIgfCAzKSA9PiBgXG4gICAgICBsZXQgYmlhcyR7aX1fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke2l9KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtpfSA9ICR7Ymlhcy5nZXRCeU9mZnNldChgYmlhcyR7aX1fb2Zmc2V0IC8gNGApfVtiaWFzJHtpfV9vZmZzZXQgJSA0XTtgO1xuICAgIGNvbnN0IGJpYXNHZXRFeHByZXNzaW9uID0gdXNlVmVjNFxuICAgICAgPyBgXG4gICAgICBsZXQgYmlhcyA9ICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KScpfTtgXG4gICAgICA6IGAke3NpbmdsZUVsZW1lbnRCaWFzKDApfSR7c2luZ2xlRWxlbWVudEJpYXMoMSl9JHtzaW5nbGVFbGVtZW50QmlhcygyKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDMpfVxuICAgICAgbGV0IGJpYXMgPSAke3gudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7XG5cbiAgICByZXR1cm4gYCR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgYmlhcywgeSl9XG5cbiAgICAke3VuYXJ5LmZhc3RHZWx1SW1wbCh0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGRhdGFUeXBlKSl9XG5cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV09SS0dST1VQX1NJWkUpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3ZlY19zaXplJyl9XG5cbiAgICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgJHtiaWFzR2V0RXhwcmVzc2lvbn1cbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XG4gICAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCB1bmFyeS5mYXN0R2VsdUV4cHJlc3Npb24oJ3hfaW4nKSl9XG4gICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRmFzdEdlbHVXaXRoQmlhcycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7dXNlVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCkgfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNMZW5ndGggfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gV09SS0dST1VQX1NJWkUgLyA0KSB9LFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPCAyIHx8IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzFdLmRpbXMpID09PSAwKSB7XG4gICAgdW5hcnkuZmFzdEdlbHUoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG5cbiAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuXG4gICAgY29uc3QgY2FsY0RhdGFJbmRpY2VzID0gKHg6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXNTaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgaW5kaWNlc0luZGljZXMke3h9ICA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXNSYW5rOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgJHtpbmRpY2VzUmFuayA+IDEgPyBgaW5kaWNlc0luZGljZXMke3h9WyR7aX1dYCA6IGBpbmRpY2VzSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVt1bmlmb3Jtcy5heGlzICsgJHtpfV1gIDogYG91dHB1dEluZGljZXMke3h9YFxuICAgICAgICB9O2A7XG4gICAgICB9XG4gICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICB2YXIgaWR4JHt4fSA9ICR7aW5kaWNlcy5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHt4fWApfTtcbiAgICAgICAgICBpZiAoaWR4JHt4fSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7eH0gPSBpZHgke3h9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3h9IDogJHtkYXRhLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBpbnB1dFJhbms7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gdTMyKGlkeCR7eH0pO2A7XG4gICAgICAgICAgaiArPSBpbmRpY2VzUmFuaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9WyR7an1dYCA6IGBvdXRwdXRJbmRpY2VzJHt4fWBcbiAgICAgICAgICB9O2A7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICAke2NhbGNEYXRhSW5kaWNlcyh4KX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7eH0gPSAke2RhdGEuaW5kaWNlc1RvT2Zmc2V0KGBkYXRhSW5kaWNlcyR7eH1gKX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2RhdGEuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDAsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDMsICd1MzInKX1cbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKCcnKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2RhdGEuZ2V0QnlJbmRpY2VzKCdkYXRhSW5kaWNlcycpfTtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoZGF0YSwgaW5kaWNlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXInLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHYXRoZXJBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBnYXRoZXJBeGlzOiBudW1iZXI7XG4gIHF1YW50aXplQXhpczogbnVtYmVyO1xuICBibG9ja1NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLicpO1xuICB9XG4gIGNvbnN0IHF1YW50aXplQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMucXVhbnRpemVBeGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBibG9ja1NpemUgPSBhdHRyaWJ1dGVzLmJsb2NrU2l6ZTtcbiAgY29uc3QgZGF0YSA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xuICBjb25zdCB6ZXJvUG9pbnQgPSBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoXG4gICAgc2NhbGVzLmRpbXMubGVuZ3RoICE9PSBkYXRhLmRpbXMubGVuZ3RoIHx8XG4gICAgIWRhdGEuZGltc1xuICAgICAgLm1hcCgoZCwgaSkgPT4gKGkgPT09IHF1YW50aXplQXhpcyA/IE1hdGguY2VpbChkIC8gYmxvY2tTaXplKSA9PT0gc2NhbGVzLmRpbXNbaV0gOiBkID09PSBzY2FsZXMuZGltc1tpXSkpXG4gICAgICAucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdTY2FsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBnYXRoZXJBeGlzLicsXG4gICAgKTtcbiAgfVxuICAvLyBUT0RPIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGNoZWNrIG9uY2UgdGhlIHRlc3QgY2FzZSBjcmVhdGlvbiBjb2RlIGlzIGZpeGVkIHRvIGNyZWF0ZSBkYXRhIGNvcnJlY3RseSBhbGlnbmVkLlxuICAvLyBjb25zdCBpbmRpY2VzID0gaW5wdXRzWzFdO1xuICAvLyBjb25zdCB2YWxpZEluZGV4ID0gKGluZGV4OiBudW1iZXIpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCBkYXRhLmRpbXNbYXR0cmlidXRlcy5nYXRoZXJBeGlzXTtcbiAgLy8gaWYgKGluZGljZXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGluZGljZXMuZ2V0SW50MzJBcnJheSgpLnNvbWUoKHYpID0+ICF2YWxpZEluZGV4KHYpKSB8fFxuICAvLyAgICAgaW5kaWNlcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50NjQgJiYgaW5kaWNlcy5nZXRCaWdJbnQ2NEFycmF5KCkuc29tZSgodikgPT4gIXZhbGlkSW5kZXgoTnVtYmVyKHYpKSkpIHtcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ0luZGljZXMgbXVzdCBiZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgZ2F0aGVyQXhpcy4nKTtcbiAgLy8gfVxuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaWYgKHplcm9Qb2ludC5kYXRhVHlwZSAhPT0gZGF0YS5kYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgdGhlIGlucHV0IHRlbnNvci4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgemVyb1BvaW50LmRpbXMubGVuZ3RoICE9PSBzY2FsZXMuZGltcy5sZW5ndGggfHxcbiAgICAgICF6ZXJvUG9pbnQuZGltcy5tYXAoKGQsIGkpID0+IGQgPT09IHNjYWxlcy5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1plcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJCbG9ja1F1YW50aXplZFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZ2F0aGVyQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcywgaW5wdXRSYW5rKTtcbiAgY29uc3QgcXVhbnRpemVBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMsIGlucHV0UmFuayk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGdhdGhlckF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFR5cGUgPSBpbnB1dHNbMl0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaXNTaWduZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDQ7IC8vIGlucHV0IGRhdGEgdHlwZSBpcyBlaXRoZXIgaW50NCBvciB1aW50NC5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHF1YW50aXplQXhpcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnYXRoZXJBeGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGlucHV0LmRpbXMpLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgemVyb1BvaW50ID1cbiAgICAgIGlucHV0cy5sZW5ndGggPiAzID8gaW5wdXRWYXJpYWJsZSgnemVyb1BvaW50JywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXRUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2RhdGEsIGluZGljZXMsIHNjYWxlc107XG4gICAgaWYgKHplcm9Qb2ludCkge1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdxdWFudGl6ZV9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2dhdGhlcl9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGluZGljZXNfaW5kaWNlcyA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKGluZGljZXNTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2luZGljZXNTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzICsgaScpfTtcbiAgICAgICAgICAgICR7aW5kaWNlcy5pbmRpY2VzU2V0KCdpbmRpY2VzX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgICB9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBpbmRpY2VzX2luZGljZXMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5nYXRoZXJfYXhpcycpfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke2RhdGEudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcygnaW5kaWNlc19pbmRpY2VzJyl9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke2lucHV0U2hhcGVbZ2F0aGVyQXhpc119O1xuICAgICAgICB9XG4gICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMnLCAndTMyKGluZGV4X2Zyb21faW5kaWNlcyknKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgYGkgKyAke2luZGljZXNTaGFwZS5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtkYXRhLmluZGljZXNUb09mZnNldCgnZGF0YV9pbmRpY2VzJyl9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtkYXRhLmdldEJ5T2Zmc2V0KCdkYXRhX29mZnNldCAvIDgnKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgnIDogJ3VucGFjazR4VTgnfSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHtzY2FsZXMuaW5kaWNlc0dldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAke3NjYWxlcy5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnLCAncXVhbnRpemVfYXhpc19pbmRleCcpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtzY2FsZXMuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKCF6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAndmFyIHplcm9fcG9pbnQgPSAwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7emVyb1BvaW50LmluZGljZXNUb09mZnNldCgnemVyb19wb2ludF9pbmRpY2VzJyl9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfb2Zmc2V0IC8gOCcpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke3RlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUob3V0cHV0VHlwZSl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGVxdWFudGl6ZWRfZGF0YScpfTtcbiAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lucHV0c1xuICAgICAgICAuZmlsdGVyKChfLCBpKSA9PiBpICE9PSAxKVxuICAgICAgICAubWFwKChpbnB1dCkgPT4gaW5wdXQuZGltcy5qb2luKCdfJykpXG4gICAgICAgIC5qb2luKCc7Jyl9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpbnB1dHMubGVuZ3RoIH0sIChfdiwgX2kpID0+ICdyYW5rJyksXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXRUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJCbG9ja1F1YW50aXplZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbik6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyLFxuICAgIGdhdGhlckF4aXM6IGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcyBhcyBudW1iZXIsXG4gICAgcXVhbnRpemVBeGlzOiBhdHRyaWJ1dGVzLnF1YW50aXplQXhpcyBhcyBudW1iZXIsXG4gIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dE91dHB1dERhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5kaWNlc0RhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDApO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xuICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc0lucHV0JywgaW5kaWNlc0RhdGFUeXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0T3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5kaWNlc1NoYXBlLCBvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgLy8gaW50NjQgaW5kaWNlcyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdHRsZSBlbmRpYW4gaTMyIHdpdGggYXNzdW1wdGlvbiB0aGV5IGZhbGwgaW4gaTMyIGxpbWl0c1xuICAvLyBUaGF0IGFzc3VtcHRpb24gaXMgc2FmZSBhcyBpdCdzIG5vdCBwb3NzaWJsZSB0byBhbGxvY2F0ZSA+MmdiIGJ1ZmZlciBmb3IgaW5wdXQgdGVuc29yXG4gIC8vIElucHV0IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIHUzMiBvciB0d28gdTMyIGZvciA4LWJ5dGUgdGVuc29yc1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgIHZhciBpZHggPSAke2luZGljZXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG5cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXJFbGVtZW50cycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJFbGVtZW50cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgR2VtbVV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFpZCBpbnB1dCBudW1iZXIuJyk7XG4gIH1cblxuICAvLyAnQycgY2FuIGJlIG9mIGRpbWVuc2lvbmFsaXR5IDAsIDEgb3IgMiBvbmx5XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlIHx8IChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWQnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHRyYW5zQTogYm9vbGVhbjtcbiAgdHJhbnNCOiBib29sZWFuO1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG59XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IFtNLCBOLCBLXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGFTaGFwZSxcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcbiAgICBiU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0IsXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEgfSxcbiAgXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTsnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZUFscGhhID0gYXR0cmlidXRlcy5hbHBoYSA9PT0gMSA/ICcnIDogJ3ZhbHVlICo9IHVuaWZvcm1zLmFscGhhOyc7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gYS50eXBlLnZhbHVlO1xuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke2xpbmV9XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICBkYXRhVHlwZVxuICAgICAgICB9KHVuaWZvcm1zLmJldGEpICogJHtjLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSkoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2VtbScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgdHJhbnNBID0gYXR0cmlidXRlcy50cmFuc0EgYXMgYm9vbGVhbjtcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcbiAgY29uc3QgYmV0YSA9IGF0dHJpYnV0ZXMuYmV0YSBhcyBudW1iZXI7XG4gIHJldHVybiB7XG4gICAgdHJhbnNBLFxuICAgIHRyYW5zQixcbiAgICBhbHBoYSxcbiAgICBiZXRhLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLnRyYW5zQX07JHthdHRyaWJ1dGVzLnRyYW5zQn07JHthdHRyaWJ1dGVzLmFscGhhID09PSAxfWAsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2VtbSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2VtbVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBhcHBseUF0dGVudGlvbixcbiAgQXR0ZW50aW9uQXR0cnMsXG4gIEF0dGVudGlvbk1hc2tUeXBlLFxuICBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBBdHRlbnRpb25Ra3ZGb3JtYXQsXG59IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8sIFRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGdldElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpOiBudW1iZXIpID0+XG4gIGlucHV0cy5sZW5ndGggPiBpICYmIGlucHV0c1tpXS5kaW1zLmxlbmd0aCA+IDAgPyBpbnB1dHNbaV0gOiB1bmRlZmluZWQ7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCAxKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChpbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCAzKTtcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBnZXRJbnB1dChpbnB1dHMsIDQpO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCA1KTtcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGlucHV0cywgNik7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGdldElucHV0KGlucHV0cywgNyk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE5vdGF0aW9uczpcbiAgLy8gICAgQjogYmF0Y2hfc2l6ZVxuICAvLyAgICBOOiBudW1faGVhZHNcbiAgLy8gICAgSDogaGVhZF9zaXplIG9mIFEgYW5kIEtcbiAgLy8gICAgSF92OiBoZWFkX3NpemUgb2YgVlxuICAvLyAgICBEOiBoaWRkZW5fc2l6ZSBmb3IgUSBhbmQgSywgd2hlcmUgRCA9IE4gKiBIXG4gIC8vICAgIERfdjogaGlkZGVuX3NpemUgb2YgViwgd2hlcmUgRF92ID0gTiAqIEhfdlxuICAvLyAgICBTOiBxX3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgICBQOiBwYXN0X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZVxuICAvLyAgICBMOiBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICAgVDogdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gUCArIExcbiAgLy8gICAgTTogbWF4X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZSB3aGVuIHBhc3QgYW5kIHByZXNlbnQgc2hhcmUgYnVmZmVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBNdWx0aUhlYWRBdHRlbnRpb24gaW5wdXRzOlxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gIFFfS19WX0JTTkggLSBubyBwYWNraW5nOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpXG4gIC8vICBRX0tfVl9CU05IX0JOU0hfQk5TSCAtIGNyb3NzIGF0dGVudGlvbiAoa3YgY2FjaGUgaXMgbm90IHVzZWQsIEwgPT0gVCwgRCA9PSBEX3YpOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIE4sIEwsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBOLCBMLCBIX3YpXG4gIC8vICBRX0tWX0JTTkhfQlNOMkggLSBwYWNrZWQga3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YpOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEsvVikgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcbiAgLy8gIFFLVl9CU04zSCAtIHBhY2tlZCBxa3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBTID09IEwsIEQgPT0gRF92KTpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEvSy9WKSAgIDogKEIsIFMsIE4sIDMsIEgpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgICAgICAgICAgIDogTm9uZVxuICAvL1xuICAvLyAgT3RoZXIgaW5wdXRzOlxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiBOb25lIG9yIChEICsgRCArIERfdilcbiAgLy8gICAgIGtleV9wYWRkaW5nX21hc2sgKEsvVikgICAgIDogKEIpIG9yICgzICogQiArIDIpIG9yIChCLCBUKSBvciAoQiwgUywgVClcbiAgLy8gICAgIGF0dGVudGlvbl9iaWFzICAgICAgICAgICAgIDogTm9uZSBvciAoQiwgTiwgUywgVCksICgxLCBOLCBTLCBUKSwgKEIsIDEsIFMsIFQpIG9yICgxLCAxLCBTLCBUKVxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUCwgSCkgb3IgTm9uZS4gUGFzdCBzdGF0ZSBpcyBvbmx5IGFsbG93ZWQgZm9yIFFfS19WX0JTTkguXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBQLCBIKSBvciBOb25lLiBQYXN0IHN0YXRlIGlzIG9ubHkgYWxsb3dlZCBmb3IgUV9LX1ZfQlNOSC5cbiAgLy9cbiAgLy8gIE5vdCBTdXBwb3J0ZWQ6XG4gIC8vICAgICBrZXlfcGFkZGluZ19tYXNrLCBwYWNrZWQga3YsIHBhY2tlZCBxa3YsIGFuZCBicm9hZGNhc3QgZm9yIGF0dGVudGlvbl9iaWFzLlxuXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xuICBjb25zdCBoaWRkZW5TaXplID0gcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyBxdWVyeS5kaW1zWzJdIDogYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGxldCBtYXhTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGNvbnN0IGhlYWRTaXplID0gTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyk7XG4gIGlmIChwYXN0S2V5ICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSkge1xuICAgIGlmIChwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdEtleS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHwgcGFzdEtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHBhc3RLZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XG4gICAgICBwYXN0VmFsdWUuZGltc1szXSAhPT0gaGVhZFNpemVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtcbiAgICB9XG4gICAgaWYgKHBhc3RLZXkuZGltc1syXSAhPT0gcGFzdFZhbHVlLmRpbXNbMl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgICBpZiAocGFzdFZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcbiAgfSBlbHNlIGlmICgocGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpKSB8fCAocGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XG4gIGlmIChrZXkgJiYgU2hhcGVVdGlsLnNpemUoa2V5LmRpbXMpID4gMCkge1xuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA8IDMgfHwga2V5LmRpbXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSBrZXkuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO1xuICAgIH1cblxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gcXVlcnkuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xS3ZCU05IeEJTTjJIO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBrZXlfZGltcy5zaXplKCkgPT0gNCAoY3Jvc3MtYXR0ZW50aW9uIHdpdGggcGFzdF9rZXkpXG4gICAgICBpZiAoa2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1xuICAgICAgfVxuXG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQudW5rbm93bjsgLy8gUV9LX1ZfQlNOSF9CTlNIX0JOU0hcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgfVxuXG4gICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTjNIO1xuICB9XG5cbiAgaWYgKGJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA+IDApIHtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSAmJiBrZXkuZGltc1szXSA9PT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsga3ZTZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xuICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd247XG4gICAgY29uc3QgbWFza0RpbXMgPSBrZXlQYWRkaW5nTWFzay5kaW1zO1xuICAgIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFkS2V5U2VxTGVuO1xuICAgICAgfSBlbHNlIGlmIChtYXNrRGltc1swXSA9PT0gMyAqIGJhdGNoU2l6ZSArIDIpIHtcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMURLZXlTZXFMZW5TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMiAmJiBtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplICYmIG1hc2tEaW1zWzFdID09PSB0b3RhbFNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2syZEtleVBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChtYXNrVHlwZSA9PT0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XG4gIGlmICh2YWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZSh2YWx1ZS5kaW1zKSA+IDApIHtcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFFfS19WX0JTTkhfQk5TSF9CTlNIXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBicm9hZGNhc3RSZXNQb3NCaWFzID0gZmFsc2U7XG5cbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAoYXR0ZW50aW9uQmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShhdHRlbnRpb25CaWFzLmRpbXMpID4gMCkge1xuICAgIGlmIChhdHRlbnRpb25CaWFzLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHN1cHBvcnQgYnJvYWRjYXN0aW5nIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGRpbWVuc2lvbnMgb2YgYXR0ZW50aW9uX2JpYXMuXG4gICAgaWYgKFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemU6IDAsXG4gICAgaGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXG4gICAgcGFzc1Bhc3RJbkt2LFxuICAgIHFrdkZvcm1hdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyAuLi5hdHRyaWJ1dGVzIH0pO1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XG5cbmNvbnN0IGFkZEJpYXNUcmFuc3Bvc2UgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBxa3Y6IFRlbnNvclZpZXcsXG4gIGJpYXM6IFRlbnNvclZpZXcsXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBoaWRkZW5TaXplOiBudW1iZXIsXG4gIGJpYXNPZmZzZXQ6IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBoaWRkZW5TaXplXTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNPZmZzZXQgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaGlkZGVuU2l6ZSB9LFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdxa3Zfd2l0aF9iaWFzJywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgcWt2SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxa3YnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBiaWFzSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmlhc19vZmZzZXQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhxa3ZJbnB1dCwgYmlhc0lucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhcycsXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBxa3YuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtxa3YsIGJpYXNdLCBvdXRwdXRzOiBbLTFdIH0sXG4gIClbMF07XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgYmF0Y2hTaXplOiBudW1iZXIsXG4gIG51bUhlYWRzOiBudW1iZXIsXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIGhlYWRTaXplOiBudW1iZXIsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBiaWFzPzogVGVuc29yVmlldyxcbiAgYmlhc09mZnNldD86IG51bWJlcixcbikgPT4ge1xuICAvLyBjb25zdCBuZXdEaW1zID0gW107XG5cbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgaWYgKCEoYmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpID4gMCkpIHtcbiAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcbiAgICB9XG4gICAgaWYgKG51bUhlYWRzID09PSAxIHx8IHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksIHtcbiAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxuICAgICAgb3V0cHV0czogWy0xXSxcbiAgICB9KVswXTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBhZGRCaWFzVHJhbnNwb3NlKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgYmlhcyxcbiAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICAgICAgbnVtSGVhZHMgKiBoZWFkU2l6ZSxcbiAgICAgICAgYmlhc09mZnNldCEsXG4gICAgICApO1xuICAgICAgcmVzaGFwZWRJbnB1dCA9IHJlc2hhcGVkSW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XG4gICAgICBpZiAobnVtSGVhZHMgPT09IDEgfHwgc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc2hhcGVkSW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xuICAgICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcbiAgICAgICAgb3V0cHV0czogWy0xXSxcbiAgICAgIH0pWzBdO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG11bHRpSGVhZEF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBxdWVyeSA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDMpO1xuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA0KTtcbiAgY29uc3QgYXR0ZW50aW9uQmlhcyA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA1KTtcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA2KTtcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDcpO1xuICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBpZiAoa2V5Py5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLy8gYXBwbHlBdHRlbnRpb24gZXhwZWN0cyBCTlNIIGlucHV0c1xuICBjb25zdCBrdkJOU0ggPSBrZXkgJiYgdmFsdWUgJiYga2V5LmRpbXMubGVuZ3RoID09PSA0ICYmIHZhbHVlLmRpbXMubGVuZ3RoID09PSA0O1xuXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLmhlYWRTaXplLFxuICAgIHF1ZXJ5LFxuICAgIGJpYXMsXG4gICAgMCxcbiAgKTtcblxuICBpZiAoa3ZCTlNIKSB7XG4gICAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKGNvbnRleHQsIFEsIGtleSwgdmFsdWUsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgYXR0ZW50aW9uQmlhcywgcGFyYW1zKTtcbiAgfVxuICBpZiAoIWtleSB8fCAhdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IEsgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMuaGVhZFNpemUsXG4gICAga2V5LFxuICAgIGJpYXMsXG4gICAgcGFyYW1zLmhpZGRlblNpemUsXG4gICk7XG5cbiAgY29uc3QgViA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICBjb250ZXh0LFxuICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgcGFyYW1zLm51bUhlYWRzLFxuICAgIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhcmFtcy52SGVhZFNpemUsXG4gICAgdmFsdWUsXG4gICAgYmlhcyxcbiAgICAyICogcGFyYW1zLmhpZGRlblNpemUsXG4gICk7XG5cbiAgYXBwbHlBdHRlbnRpb24oY29udGV4dCwgUSwgSywgViwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCBhdHRlbnRpb25CaWFzLCBwYXJhbXMpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtLCBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0RWxlbWVudEF0LFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNwbGl0U2l6ZXM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHNwbGl0U2l6ZXM6IG51bWJlcltdID0gW107XG4gIGxldCBudW1PdXRwdXRzOiBudW1iZXIgPSBhdHRyaWJ1dGVzLm51bU91dHB1dHM7XG4gIGlmIChpbnB1dHNbMV0uZGltc1swXSA+IDApIHtcbiAgICBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IHNwbGl0U2l6ZXMucHVzaChOdW1iZXIodikpKTtcbiAgICBudW1PdXRwdXRzID0gc3BsaXRTaXplcy5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG51bU91dHB1dHMsIGF4aXM6IGF0dHJpYnV0ZXMuYXhpcywgc3BsaXRTaXplcyB9KTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU91dHB1dEluZGV4SW1wbCA9IChudW1iZXJPZlRlbnNvcnM6IG51bWJlcik6IHN0cmluZyA9PiBgXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtudW1iZXJPZlRlbnNvcnN9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ2knLCBudW1iZXJPZlRlbnNvcnMpfSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgfVxuICAgIHJldHVybiAke251bWJlck9mVGVuc29yc311O1xufWA7XG5jb25zdCB3cml0ZUJ1ZmZlckRhdGFJbXBsID0gKG91dHB1dHM6IHJlYWRvbmx5IEluZGljZXNIZWxwZXJbXSkgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBvdXRwdXRzLmxlbmd0aDtcbiAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVGVuc29yczsgKytpKSB7XG4gICAgY29uc3QgcmV0dXJuU25pcHBldCA9IG91dHB1dHNbaV0uc2V0QnlJbmRpY2VzKCdpbmRpY2VzJywgJ2lucHV0W2dsb2JhbF9pZHhdJyk7XG4gICAgaWYgKG51bWJlck9mVGVuc29ycyA9PT0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2gocmV0dXJuU25pcHBldCk7XG4gICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtpfXUpIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke2l9KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXI6IHUzMiwgaW5kaWNlczogJHtvdXRwdXRzWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke2NvZGVMaW5lcy5qb2luKCdcXG4nKX1cbiAgICAgIH1gO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0cyA9IG5ldyBBcnJheTxJbmRpY2VzSGVscGVyPihhdHRyaWJ1dGVzLm51bU91dHB1dHMpO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgc2l6ZUluU3BsaXRBeGlzID0gbmV3IEFycmF5PG51bWJlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3Qgb3V0cHV0c1RlbnNvckluZm86IFRlbnNvckluZm9bXSA9IFtdO1xuICBjb25zdCBvdXRwdXRTaGFwZXM6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dFNpemUgfV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5udW1PdXRwdXRzOyBpKyspIHtcbiAgICBwcmV2aW91c1N1bSArPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXNbaV07XG4gICAgc2l6ZUluU3BsaXRBeGlzW2ldID0gcHJldmlvdXNTdW07XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbYXhpc10gPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXNbaV07XG4gICAgb3V0cHV0U2hhcGVzLnB1c2gob3V0cHV0U2hhcGUpO1xuICAgIG91dHB1dHNbaV0gPSBvdXRwdXRWYXJpYWJsZShgb3V0cHV0JHtpfWAsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIG91dHB1dHNUZW5zb3JJbmZvLnB1c2goeyBkaW1zOiBvdXRwdXRTaGFwZXNbaV0sIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfSk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJblNwbGl0QXhpcyB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIC4uLm91dHB1dFNoYXBlcyksXG4gICk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm0oJ2lucHV0X3NpemUnLCAndTMyJylcbiAgICAucmVnaXN0ZXJVbmlmb3JtKCdzaXplX2luX3NwbGl0X2F4aXMnLCAndTMyJywgc2l6ZUluU3BsaXRBeGlzLmxlbmd0aClcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgLi4ub3V0cHV0cyl9XG4gICR7Y2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsKHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfVxuICAke3dyaXRlQnVmZmVyRGF0YUltcGwob3V0cHV0cyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMuaW5wdXRfc2l6ZScpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke2lucHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICB2YXIgaW5kZXggPSAke2lucHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBheGlzKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpcycsICdvdXRwdXRfbnVtYmVyIC0gMXUnLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2luZGljZXMnLCBheGlzLCAnaW5kZXgnKX07XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NwbGl0JyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IG91dHB1dHNUZW5zb3JJbmZvLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc3BsaXQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID1cbiAgICBjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTcGxpdFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHsgaW5wdXRzOiBbMF0gfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTcGxpdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBheGlzID0gYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcjtcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXMgYXMgbnVtYmVyW107XG4gIGNvbnN0IG51bU91dHB1dHMgPSAoYXR0cmlidXRlcy5udW1PdXRwdXRzIGFzIG51bWJlcikgPCAwID8gc3BsaXRTaXplcy5sZW5ndGggOiAoYXR0cmlidXRlcy5udW1PdXRwdXRzIGFzIG51bWJlcik7XG4gIGlmIChudW1PdXRwdXRzICE9PSBzcGxpdFNpemVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsJyk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXMsIG51bU91dHB1dHMsIHNwbGl0U2l6ZXMgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBhcHBseUF0dGVudGlvbiwgQXR0ZW50aW9uTWFza1R5cGUsIEF0dGVudGlvblBhcmFtZXRlcnMsIEF0dGVudGlvblFrdkZvcm1hdCB9IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyB9IGZyb20gJy4vbXVsdGloZWFkLWF0dGVudGlvbic7XG5pbXBvcnQgeyBjcmVhdGVTcGxpdFByb2dyYW1JbmZvLCBTcGxpdEF0dHJpYnV0ZXMgfSBmcm9tICcuL3NwbGl0JztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuZXhwb3J0IGludGVyZmFjZSBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGt2TnVtSGVhZHM6IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgc29mdGNhcDogbnVtYmVyO1xuICBkb1JvdGFyeTogbnVtYmVyO1xuICByb3RhcnlJbnRlcmxlYXZlZDogbnVtYmVyO1xuICBzbW9vdGhTb2Z0bWF4OiBib29sZWFuO1xuICBsb2NhbFdpbmRvd1NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMsXG4pOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuZG9Sb3RhcnkgJiYgaW5wdXRzLmxlbmd0aCA8PSA3KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbnB1dHMgYXJlIHJlcXVpcmVkIGlmIGRvX3JvdGFyeSBpcyBzcGVjaWZpZWQnKTtcbiAgfVxuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gaW5wdXRzWzFdO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcbiAgY29uc3QgcGFzdEtleSA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdFZhbHVlID0gaW5wdXRzWzRdO1xuICBpZiAoYXR0cmlidXRlcy5sb2NhbFdpbmRvd1NpemUgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBhdHRlbnRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnNvZnRjYXAgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRjYXAgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnJvdGFyeUludGVybGVhdmVkICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3RhcnkgaW50ZXJsZWF2ZWQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnNtb290aFNvZnRtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Ntb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICAvLyBBYmJyZXZpYXRpb24gYW5kIE1lYW5pbmdzOlxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcbiAgLy8gICBTOiAgICBzZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBxdWVyeSlcbiAgLy8gICBQOiAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCAocGFzdCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBNOiAgICBtYXhfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgVDogICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBOOiAgICBudW1faGVhZHNcbiAgLy8gICBIOiAgICBoZWFkIHNpemUgZm9yIFEgYW5kIEssIGFrYSBxX2hlYWRfc2l6ZSBvciBrX2hlYWRfc2l6ZSBvciBxa19oZWFkX3NpemVcbiAgLy8gICBIX3Y6ICB2X2hlYWRfc2l6ZVxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXG4gIC8vICAgRDogICAgaGlkZGVuIHNpemUgZm9yIFEgYW5kIEsgKEQgPSBOICogSCksIGFrYSBxX2hpZGRlbl9zaXplIG9yIGtfaGlkZGVuX3NpemUgb3IgcWtfaGlkZGVuX3NpemVcbiAgLy8gICBEX3Y6ICB2X2hpZGRlbl9zaXplID0gbnVtX2hlYWRzICogdl9oZWFkX3NpemVcblxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gV2hlbiBubyBwYWNraW5nIGZvciBxL2svdjpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKSBvciAoQiwgTiwgUyosIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gV2hlbiBwYWNrZWQga3YgaXMgdXNlZDpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBOLCAyLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG4gIC8vIFdoZW4gcGFja2VkIHFrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgTCwgTiwgMywgSCkgb3IgKEIsIFMsIDMqRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogTm9uZVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG5cbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBkbW1oYVBhY2tpbmcgPSBmYWxzZTtcbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xuICBsZXQgaGlkZGVuU2l6ZSA9XG4gICAgcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyAoZG1taGFQYWNraW5nID8gcXVlcnkuZGltc1syXSAvIDMgOiBxdWVyeS5kaW1zWzJdKSA6IGF0dHJpYnV0ZXMubnVtSGVhZHMgKiBxdWVyeS5kaW1zWzRdO1xuICBsZXQga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBjb25zdCBwYWNrZWRRS1YgPSAha2V5IHx8IGtleS5kaW1zLmxlbmd0aCA9PT0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSAhcGFja2VkUUtWXG4gICAgPyBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKVxuICAgIDogTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gKGF0dHJpYnV0ZXMubnVtSGVhZHMgKyAyICogYXR0cmlidXRlcy5rdk51bUhlYWRzKSk7XG4gIGlmIChwYWNrZWRRS1YpIHtcbiAgICBoaWRkZW5TaXplID0gaGVhZFNpemUgKiBhdHRyaWJ1dGVzLm51bUhlYWRzO1xuICB9XG4gIGNvbnN0IGhhc1Bhc3RLZXkgPSBwYXN0S2V5ICYmIHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDA7XG4gIGNvbnN0IGhhc1Bhc3RWYWx1ZSA9IHBhc3RWYWx1ZSAmJiBwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDA7XG4gIC8vIEN1cnJlbmx5IHRoZSBvbm54cnVudGltZSBHUUEgc3BlY2lmaWNhdGlvbiBvbmx5IHN1cHBvcnQga2V5L3ZhbHVlIEJOU0ggZm9ybWF0LlxuICBjb25zdCBpc1Bhc3RrdkJTTkggPVxuICAgIGhhc1Bhc3RLZXkgJiZcbiAgICBwYXN0S2V5LmRpbXMubGVuZ3RoID09PSA0ICYmXG4gICAgcGFzdEtleS5kaW1zWzBdID09PSBiYXRjaFNpemUgJiZcbiAgICBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyAmJlxuICAgIHBhc3RLZXkuZGltc1syXSA9PT0gYXR0cmlidXRlcy5rdk51bUhlYWRzICYmXG4gICAgcGFzdEtleS5kaW1zWzNdID09PSBoZWFkU2l6ZTtcblxuICBpZiAoaXNQYXN0a3ZCU05IKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCU05IIHBhc3RLZXkvcGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBpZiAoaGFzUGFzdEtleSAmJiBoYXNQYXN0VmFsdWUpIHtcbiAgICBpZiAocGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gIH0gZWxzZSBpZiAoaGFzUGFzdEtleSB8fCBoYXNQYXN0VmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSDtcbiAgaWYgKGtleSAmJiBrZXkuZGltcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXNbMl0gJSBrZXkuZGltc1syXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7XG4gICAgICB9XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcbiAgICAgIH1cbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUgJiYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgIH1cblxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcbiAgfVxuXG4gIGNvbnN0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGxldCBwYXNzUGFzdEluS3YgPSBmYWxzZTtcbiAgbGV0IHZIaWRkZW5TaXplID0gYXR0cmlidXRlcy5rdk51bUhlYWRzID8gaGVhZFNpemUgKiBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgOiBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUgJiYgdmFsdWUuZGltcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoICE9PSAzICYmIHZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IHZhbHVlLmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzFdICogdmFsdWUuZGltc1szXTtcbiAgICAgIHBhc3NQYXN0SW5LdiA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlcWxMZW5zID0gaW5wdXRzLmxlbmd0aCA+IDQgPyBpbnB1dHNbNV0gOiB1bmRlZmluZWQ7XG4gIGlmIChzZXFsTGVucyAmJiBzZXFsTGVucy5kaW1zLmxlbmd0aCAhPT0gMSAmJiBzZXFsTGVucy5kaW1zWzBdICE9PSBiYXRjaFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwic2VxbGVuc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24gYW5kIHRoZSBzYW1lIGRpbSAwIGFzIGJhdGNoX3NpemUnKTtcbiAgfVxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gLTE7XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gLTE7XG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAga3ZOdW1IZWFkczogYXR0cmlidXRlcy5rdk51bUhlYWRzLFxuICAgIG5SZXBzOiBhdHRyaWJ1dGVzLm51bUhlYWRzIC8gYXR0cmlidXRlcy5rdk51bUhlYWRzLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXG4gICAgcGFzc1Bhc3RJbkt2LFxuICAgIHFrdkZvcm1hdCxcbiAgfTtcbn07XG5cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IFswLCAyLCAxLCAzXSB9KTtcblxuY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0ggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0OiBUZW5zb3JWaWV3LCBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMpID0+IHtcbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgY29uc3QgbnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyE7XG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMyAmJiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCAhPT0gMCkge1xuICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIHBhcmFtcy5oZWFkU2l6ZV0pO1xuICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XG4gICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gIH1cblxuICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcbn07XG5cbmV4cG9ydCBjb25zdCBncm91cFF1ZXJ5QXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmlucHV0c1sxXT8uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IHEgPSBjb250ZXh0LmlucHV0c1swXTtcbiAgY29uc3QgayA9IGNvbnRleHQuaW5wdXRzWzFdICYmIGNvbnRleHQuaW5wdXRzWzFdLmRpbXMubGVuZ3RoID4gMCA/IGNvbnRleHQuaW5wdXRzWzFdIDogdW5kZWZpbmVkO1xuICBjb25zdCB2ID0gY29udGV4dC5pbnB1dHNbMl0gJiYgY29udGV4dC5pbnB1dHNbMl0uZGltcy5sZW5ndGggPiAwID8gY29udGV4dC5pbnB1dHNbMl0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHBhc3RLZXkgPSBjb250ZXh0LmlucHV0c1szXSAmJiBjb250ZXh0LmlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBjb25zdCBwYXN0VmFsdWUgPSBjb250ZXh0LmlucHV0c1s0XSAmJiBjb250ZXh0LmlucHV0c1s0XS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBzZXFMZW5zID0gY29udGV4dC5pbnB1dHMubGVuZ3RoID4gNCA/IGNvbnRleHQuaW5wdXRzWzVdIDogdW5kZWZpbmVkO1xuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgPSBjb250ZXh0LmlucHV0cy5sZW5ndGggPiA1ID8gY29udGV4dC5pbnB1dHNbNl0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyA/IHBhcmFtcy5rdk51bUhlYWRzIDogcGFyYW1zLm51bUhlYWRzO1xuXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cGxpY2l0IHNwbGl0IG9wZXJhdGlvbiBhbmQgdXNlIGluZGV4aW5nIGluIEF0dGVudGlvbiBpbXBsZW1lbnRhdGlvbiB0byBhdm9pZCBvdmVyaGVhZC5cblxuICBjb25zdCBzcGxpdEF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYXhpczogMixcbiAgICBudW1PdXRwdXRzOiAzLFxuICAgIHNwbGl0U2l6ZXM6IFtwYXJhbXMubnVtSGVhZHMgKiBwYXJhbXMuaGVhZFNpemUsIGt2TnVtSGVhZHMgKiBwYXJhbXMuaGVhZFNpemUsIGt2TnVtSGVhZHMgKiBwYXJhbXMuaGVhZFNpemVdLFxuICB9KTtcbiAgY29uc3QgW3F1ZXJ5LCBrZXksIHZhbHVlXSA9XG4gICAgIWsgJiYgIXZcbiAgICAgID8gY29udGV4dC5jb21wdXRlKGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8oW3FdLCBzcGxpdEF0dHJpYnV0ZXMpLCB7IGlucHV0czogW3FdLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV0gfSlcbiAgICAgIDogW3EsIGshLCB2IV07XG5cbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICBjb250ZXh0LFxuICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgcGFyYW1zLm51bUhlYWRzLFxuICAgIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMuaGVhZFNpemUsXG4gICAgcXVlcnksXG4gICAgdW5kZWZpbmVkLFxuICAgIDAsXG4gICk7XG4gIGFwcGx5QXR0ZW50aW9uKFxuICAgIGNvbnRleHQsXG4gICAgUSxcbiAgICBtYXliZVRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCBrZXksIHBhcmFtcyksXG4gICAgbWF5YmVUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgdmFsdWUsIHBhcmFtcyksXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBwYXN0S2V5LFxuICAgIHBhc3RWYWx1ZSxcbiAgICB1bmRlZmluZWQsXG4gICAgcGFyYW1zLFxuICAgIHNlcUxlbnMsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LFxuICApO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBzdW1WZWN0b3IsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMge1xuICBlcHNpbG9uOiBudW1iZXI7XG4gIGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xufVxuXG5jb25zdCBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgc2NhbGU6IFRlbnNvclZpZXcsXG4gIGJpYXM6IFRlbnNvclZpZXcsXG4gIG46IG51bWJlcixcbiAgaDogbnVtYmVyLFxuICBjOiBudW1iZXIsXG4gIGVwc2lsb246IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoKTtcbiAgY29uc3QgZjMyVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XG4gIGNvbnN0IHdnVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAndmVjMmYnIDogYG1hdDJ4JHtjb21wb25lbnRzfWZgO1xuICBjb25zdCB1bml0c09mV29yayA9IG4gKiBjO1xuXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBbbiwgYywgaCAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtuLCBjLCAyXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAndHlwZScsICd0eXBlJ107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIDMsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCAzLCAyKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgcywgYiwgb3V0cHV0XTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplID0gNjQ7XG4gICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZCA6IGFycmF5PCR7d2dUeXBlfSwgJHt3b3JrZ3JvdXBTaXplfT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHt3b3JrZ3JvdXBTaXplfXU7XG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZjMyVHlwZX0oJHt4LmdldCgnYmF0Y2gnLCAnY2hhbm5lbCcsICdoJyl9KTtcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIHNxdWFyZWRfc3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9ICR7d2dUeXBlfShzdW0sIHNxdWFyZWRfc3VtKTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cF9zaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9IHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSArIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfaWR4ID09IDApIHtcbiAgICAgIGxldCBzdW1fZmluYWwgPSAke3N1bVZlY3Rvcignd29ya2dyb3VwX3NoYXJlZFswXVswXScsIGNvbXBvbmVudHMpfSAvIGYzMihoaWdodCAqICR7Y29tcG9uZW50c30pO1xuICAgICAgbGV0IHNxdWFyZWRfc3VtX2ZpbmFsID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cF9zaGFyZWRbMF1bMV0nLCBjb21wb25lbnRzKX0gLyBmMzIoaGlnaHQgKiAke2NvbXBvbmVudHN9KTtcblxuICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZF9zdW1fZmluYWwgLSBzdW1fZmluYWwgKiBzdW1fZmluYWwgKyBmMzIoJHtlcHNpbG9ufSkpO1xuICAgICAgbGV0IGNoYW5uZWxfc2NhbGUgPSBpbnZfc3RkX2RldiAqIGYzMihzY2FsZVtjaGFubmVsXSk7XG4gICAgICBsZXQgY2hhbm5lbF9zaGlmdCA9IGYzMihiaWFzW2NoYW5uZWxdKSAtIHN1bV9maW5hbCAqIGNoYW5uZWxfc2NhbGU7XG4gICAgICBvdXRwdXRbd29ya2dyb3VwX2luZGV4XSA9IHZlYzJmKGNoYW5uZWxfc2NhbGUsIGNoYW5uZWxfc2hpZnQpO1xuICAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0JyxcbiAgICAgIC8vIFRPRE86IHVzZSBlcHNpbG9uIGFzIHVuaWZvcm0uIEN1cnJlbnRseSBlcHNpbG9uIGFzIHVuaWZvcm0gZmFpbHMgdGVzdF9pbnN0YW5jZW5vcm1fZXBzaWxvbi5cbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7ZXBzaWxvbn1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiB1bml0c09mV29yayB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXQsIHNjYWxlLCBiaWFzXSwgb3V0cHV0czogWy0xXSB9LFxuICApWzBdO1xufTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8gPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyxcbikgPT4ge1xuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gIGNvbnN0IGF4aXMgPSAyO1xuICBjb25zdCBOID0geFNoYXBlWzBdO1xuICBjb25zdCBDID0geFNoYXBlWzFdO1xuICBjb25zdCBIID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEgpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcbiAgLy8gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxuICBjb25zdCBjaGFubmVsU2NhbGVTaGlmdCA9IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdChcbiAgICBjb250ZXh0LFxuICAgIGlucHV0c1swXSxcbiAgICBpbnB1dHNbMV0sXG4gICAgaW5wdXRzWzJdLFxuICAgIE4sXG4gICAgSCxcbiAgICBDLFxuICAgIGF0dHJpYnV0ZXMuZXBzaWxvbixcbiAgKTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gW04sIEMsIEggLyBjb21wb25lbnRzXTtcbiAgY29uc3Qgc2NhbGVTaGFwZSA9IFtOLCBDXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAnbm9uZSddO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZV9zaGlmdCcsIERhdGFUeXBlLmZsb2F0LCBzY2FsZVNoYXBlLmxlbmd0aCwgMik7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzY2FsZSwgb3V0cHV0XTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3NjYWxlLmdldEJ5SW5kaWNlcygndmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfSAqICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtvdXRwdXQudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueSk7XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgfWA7XG4gIH07XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb24nLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBzY2FsZVNoYXBlLCBpbnB1dFNoYXBlKSxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGNoYW5uZWxTY2FsZVNoaWZ0XSB9LFxuICApO1xufTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMsXG4pID0+IHtcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICBjb25zdCBOID0geFNoYXBlWzBdO1xuICBjb25zdCBDID0geFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSCA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIDEpIC8gQztcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoQyk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihDIC8gY29tcG9uZW50cykgfSxcbiAgXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuXG4gIC8vIDEuIHRyYW5zcG9zZSB4IGZyb20gTkhXQyB0byBOQ0hXXG4gIGNvbnN0IHRyYW5zcG9zZWRYUGVybSA9IFswLCB4U2hhcGUubGVuZ3RoIC0gMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeFNoYXBlLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIHRyYW5zcG9zZWRYUGVybS5wdXNoKGkgKyAxKTtcbiAgfVxuICBjb25zdCB0cmFuc3Bvc2VkWCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgdHJhbnNwb3NlZFhQZXJtKSwge1xuICAgIGlucHV0czogW2NvbnRleHQuaW5wdXRzWzBdXSxcbiAgICBvdXRwdXRzOiBbLTFdLFxuICB9KVswXTtcbiAgLy8gMi4gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxuICBjb25zdCBjaGFubmVsU2NhbGVTaGlmdCA9IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdChcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zcG9zZWRYLFxuICAgIGlucHV0c1sxXSxcbiAgICBpbnB1dHNbMl0sXG4gICAgTixcbiAgICBILFxuICAgIEMsXG4gICAgYXR0cmlidXRlcy5lcHNpbG9uLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHNjYWxlVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAndmVjMmYnIDogYG1hdCR7Y29tcG9uZW50c314MmZgO1xuICAgIGNvbnN0IHNjYWxlRGF0YSA9IChudW06IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBudW0gPT09IDAgPyAneCcgOiAneSc7XG4gICAgICBjb25zdCBmMzJUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGAke2RhdGFUeXBlfSgke2YzMlR5cGV9KHNjYWxlLiR7aW5kZXh9KSlgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9Pigke2YzMlR5cGV9KHNjYWxlWzBdLiR7aW5kZXh9LCBzY2FsZVsxXS4ke2luZGV4fSkpYDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBgdmVjNDwke2RhdGFUeXBlfT4oJHtmMzJUeXBlfShzY2FsZVswXS4ke2luZGV4fSwgc2NhbGVbMV0uJHtpbmRleH0sIHNjYWxlWzJdLiR7aW5kZXh9LCBzY2FsZVszXS4ke2luZGV4fSkpYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7Y29tcG9uZW50c31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cyk7XG5cbiAgICByZXR1cm4gYFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtpbnB1dEhlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7c2NhbGVUeXBlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtvdXRwdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke3NjYWxlRGF0YSgwKX0sICR7c2NhbGVEYXRhKDEpfSk7XG4gIH1gO1xuICB9O1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbk5IV0MnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7IGlucHV0czogW2lucHV0c1swXSwgY2hhbm5lbFNjYWxlU2hpZnRdIH0sXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBjcmVhdGVJbnN0YW5jZU5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNhc3RUb0YzMixcbiAgZmlsbFZlY3RvcixcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogTGF5ZXJOb3JtQXR0cmlidXRlcyxcbiAgb3V0cHV0Q291bnQ6IG51bWJlcixcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgc2ltcGxpZmllZCA9IGF0dHJpYnV0ZXMuc2ltcGxpZmllZDtcblxuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGJpYXMgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHNbMl07XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIHhTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gIGNvbnN0IG5vcm1TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG5cbiAgY29uc3Qgc2NhbGVTaXplID0gU2hhcGVVdGlsLnNpemUoc2NhbGUuZGltcyk7XG4gIGNvbnN0IGJpYXNTaXplID0gYmlhcyA/IFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgOiAwO1xuICBpZiAoc2NhbGVTaXplICE9PSBub3JtU2l6ZSB8fCAoYmlhcyAmJiBiaWFzU2l6ZSAhPT0gbm9ybVNpemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtub3JtU2l6ZX0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke3NjYWxlU2l6ZX0gYW5kIGJpYXMgc2l6ZSBvZiAke2JpYXNTaXplfWApO1xuICB9XG5cbiAgY29uc3QgbWVhbkludlN0ZERldkRpbTogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IGF4aXMpIHtcbiAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCh4U2hhcGVbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goMSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG5vcm1TaXplKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5vcm1Db3VudCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IG5vcm1TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3Iobm9ybVNpemUgLyBjb21wb25lbnRzKSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuZXBzaWxvbiB9LFxuICBdO1xuICBpZiAoYmlhcykge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBjb25zdCBoYXNNZWFuRGF0YU91dHB1dCA9IG91dHB1dENvdW50ID4gMTtcbiAgY29uc3QgaGFzSW52U3RkT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAyO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBzY2FsZS5kYXRhVHlwZSwgc2NhbGUuZGltcywgY29tcG9uZW50cyksXG4gICAgXTtcbiAgICBpZiAoYmlhcykge1xuICAgICAgdmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgIGlmIChoYXNNZWFuRGF0YU91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fZGF0YV9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW52U3RkT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ25vcm1fY291bnQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbm9ybV9zaXplJywgdHlwZTogJ2YzMicgfSxcbiAgICAgIHsgbmFtZTogJ25vcm1fc2l6ZV92ZWN0b3JpemVkJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5ub3JtX2NvdW50Jyl9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhbl92ZWN0b3IgPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtoICsgb2Zmc2V0XScpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ21lYW5fdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdtZWFuX3NxdWFyZV92ZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtcbiAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ1xuICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaiArIG9mZnNldF0nKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3NjYWxlW2pdJyl9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt2YXJpYWJsZXNbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7c2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbid9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHtiaWFzID8gYCsgJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdiaWFzW2pdJyl9YCA6ICcnfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAke2hhc01lYW5EYXRhT3V0cHV0ID8gJ21lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuJyA6ICcnfTtcbiAgICAke2hhc0ludlN0ZE91dHB1dCA/ICdpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2JyA6ICcnfTtcbiAgfWA7XG4gIH07XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XTtcbiAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xuICB9XG4gIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdMYXllck5vcm1hbGl6YXRpb24nLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7b3V0cHV0Q291bnR9OyR7c2ltcGxpZmllZH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobm9ybUNvdW50IC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGxheWVyTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTGF5ZXJOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgY29udGV4dC5vdXRwdXRDb3VudCkpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbi8vICBUT0RPIHN1cHBvcnQgcXVhbnRpemF0aW9uIGJpdHMgbm90IGVxdWFsIHRvIDRcbmV4cG9ydCBpbnRlcmZhY2UgTWF0TXVsTkJpdHNBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgazogbnVtYmVyO1xuICBuOiBudW1iZXI7XG4gIGFjY3VyYWN5TGV2ZWw6IG51bWJlcjtcbiAgYml0czogbnVtYmVyO1xuICBibG9ja1NpemU6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDMgfHwgaW5wdXRzLmxlbmd0aCA+IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMnKTtcbiAgfVxuICBjb25zdCBhID0gaW5wdXRzWzBdO1xuICBjb25zdCBhUmFuayA9IGEuZGltcy5sZW5ndGg7XG4gIGlmIChhLmRpbXNbYVJhbmsgLSAxXSAhPT0gYXR0cmlidXRlcy5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWUnKTtcbiAgfVxuICBjb25zdCBuQmxvY2tzUGVyQ29sID0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5rICsgYXR0cmlidXRlcy5ibG9ja1NpemUgLSAxKSAvIGF0dHJpYnV0ZXMuYmxvY2tTaXplKTtcbiAgY29uc3QgYmxvYlNpemUgPSAoYXR0cmlidXRlcy5ibG9ja1NpemUgLyA4KSAqIGF0dHJpYnV0ZXMuYml0cztcbiAgY29uc3QgYiA9IGlucHV0c1sxXTtcbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoYi5kaW1zLCBbYXR0cmlidXRlcy5uLCBuQmxvY2tzUGVyQ29sLCBibG9iU2l6ZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemUnKTtcbiAgfVxuICBjb25zdCBzY2FsZXMgPSBpbnB1dHNbMl07XG4gIGNvbnN0IHNjYWxlc1NoYXBlID0gc2NhbGVzLmRpbXM7XG4gIGlmIChTaGFwZVV0aWwuc2l6ZShzY2FsZXNTaGFwZSkgIT09IGF0dHJpYnV0ZXMubiAqIG5CbG9ja3NQZXJDb2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlcyBpbnB1dCBzaXplIGVycm9yLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgY29uc3QgemVyb1BvaW50cyA9IGlucHV0c1szXTtcbiAgICBjb25zdCB6ZXJvUG9pbnRzU2hhcGUgPSB6ZXJvUG9pbnRzLmRpbXM7XG4gICAgY29uc3QgZXhwZWN0ZWRaZXJvUG9pbnRzU2l6ZSA9XG4gICAgICBhdHRyaWJ1dGVzLmJpdHMgPiA0ID8gYXR0cmlidXRlcy5uICogbkJsb2Nrc1BlckNvbCA6IGF0dHJpYnV0ZXMubiAqIE1hdGguZmxvb3IoKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDIpO1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRzU2hhcGUpICE9PSBleHBlY3RlZFplcm9Qb2ludHNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3plcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGFSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGRpbUFPdXRlciA9IGlucHV0U2hhcGVbYVJhbmsgLSAyXTtcbiAgY29uc3QgZGltSW5uZXIgPSBhdHRyaWJ1dGVzLms7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGF0dHJpYnV0ZXMubjtcbiAgY29uc3QgYmF0Y2hEaW1zID0gaW5wdXRTaGFwZS5zbGljZSgwLCBhUmFuayAtIDIpO1xuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShiYXRjaERpbXMpO1xuICBjb25zdCBibG9iU2l6ZSA9IGlucHV0c1sxXS5kaW1zWzJdO1xuICBjb25zdCBibG9iU2l6ZUluV29yZHMgPSBibG9iU2l6ZSAvIDQ7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYXR0cmlidXRlcy5rKTtcbiAgY29uc3QgYkNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGJsb2JTaXplSW5Xb3Jkcyk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGRpbUJPdXRlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYmF0Y2hEaW1zLmNvbmNhdChbZGltQU91dGVyLCBkaW1CT3V0ZXJdKTtcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZGltQU91dGVyID4gMSAmJiAoZGltQk91dGVyIC8gY29tcG9uZW50cykgJSAyID09PSAwID8gMiA6IDE7XG4gIGNvbnN0IGRpc3BhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG5cbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xuICBjb25zdCBpbnB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBhQ29tcG9uZW50c107XG4gIGNvbnN0IGJTaGFwZSA9IFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzFdLmRpbXMpLnNsaWNlKCk7XG4gIGJTaGFwZS5zcGxpY2UoLTEsIDEsIGJsb2JTaXplSW5Xb3JkcyAvIGJDb21wb25lbnRzKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZVRlbXApKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYlNoYXBlKSk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbM10uZGltcykpKTtcbiAgfVxuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZVRlbXApKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlVGVtcC5sZW5ndGg7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuaywgYUNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgRGF0YVR5cGUudWludDMyLCBiU2hhcGUubGVuZ3RoLCBiQ29tcG9uZW50cyk7XG4gICAgY29uc3Qgc2NhbGVzID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGIsIHNjYWxlc107XG4gICAgY29uc3QgemVyb1BvaW50cyA9XG4gICAgICBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRWYXJpYWJsZSgnemVyb19wb2ludHMnLCBEYXRhVHlwZS51aW50MzIsIGlucHV0c1szXS5kaW1zLmxlbmd0aCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHplcm9Qb2ludHMpIHtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFJhbmssIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgICBjb25zdCBxRHFEYXRhVHlwZSA9ICgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFDb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gYGFycmF5PCR7ZGF0YVR5cGV9LCA4PmA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gYG1hdDR4Mjwke2RhdGFUeXBlfT5gO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGBtYXQyeDQ8JHtkYXRhVHlwZX0+YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICBjb25zdCBwcm9jZXNzT25lV29yZCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldChgJHthLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCl9O1xuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtxRHFEYXRhVHlwZX07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4IC8gYUNvbXBvbmVudHN9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHthLmdldEJ5T2Zmc2V0KCdpbnB1dF9vZmZzZXQnKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbXBvbmVudHMgKiBvdXRwdXROdW1iZXI7IGMrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke2JDb21wb25lbnRzID09PSAxID8gYGIke2N9X2RhdGFgIDogYGIke2N9X2RhdGFbaV1gfTtcbiAgICAgICAgICAgIGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiBiX21hc2spO1xuICAgICAgICAgICAgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiBiX21hc2spO1xuICAgICAgICAgICAgYl9xdWFudGl6ZWRfdmFsdWVzID0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICB7IGxlbmd0aDogNCB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7ZGF0YVR5cGV9KGJfdmFsdWVfbG93ZXJbJHtpfV0pLCAke2RhdGFUeXBlfShiX3ZhbHVlX3VwcGVyWyR7aX1dKWAsXG4gICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cURxRGF0YVR5cGV9KCR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA4IH0sXG4gICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYChiX3F1YW50aXplZF92YWx1ZXNbJHtpfV0gLSAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfSkgKiBzY2FsZSR7Y31gLFxuICAgICAgICAgICAgICAgICkuam9pbignLCAnKX0pO2A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheSg4KVxuICAgICAgICAgICAgICAgICAgLmZpbGwoYCR7emVyb1BvaW50cyA/IGB6ZXJvX3BvaW50JHtjfWAgOiAnemVyb19wb2ludCd9YClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9KSkgKiBzY2FsZSR7Y307YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke291dHB1dE51bWJlcn0gKyAke01hdGguZmxvb3IoYyAvIGNvbXBvbmVudHMpfV0ke2NvbXBvbmVudHMgPiAxID8gYFske2MgJSBjb21wb25lbnRzfV1gIDogJyd9ICs9ICR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDggLyBhQ29tcG9uZW50cyB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT5cbiAgICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgIGFDb21wb25lbnRzID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gYGFfZGF0YVske2l9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7aX1dYFxuICAgICAgICAgICAgICAgICAgICA6IGBkb3QoYV9kYXRhWyR7aX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XSlgXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICApLmpvaW4oJyArICcpfTtcbiAgICAgICAgICBgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gYFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXG4gICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgXG4gICAgICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBsZXQgc2NhbGUke2N9ID0gJHtzY2FsZXMuZ2V0QnlPZmZzZXQoYGNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja2ApfTtcbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgIHplcm9Qb2ludHNcbiAgICAgICAgICAgICAgICA/IGBcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtjfSA9ICR7ZGF0YVR5cGV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YFxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVCRGF0YSA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgY29sX2luZGV4ID0gY29sICogJHtjb21wb25lbnRzfTtgO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBsZXQgYiR7Y31fZGF0YSA9ICR7Yi5nZXRCeUluZGljZXMoYCR7Yi50eXBlLmluZGljZXN9KGNvbF9pbmRleCwgYmxvY2ssIHdvcmQpYCl9O1xuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtcbiAgICAgIH1cbiAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke3FEcURhdGFUeXBlfTtcbiAgICAgICAgICAgIHZhciBiX2RlcXVhbnRpemVkX3ZhbHVlczogJHtxRHFEYXRhVHlwZX07YDtcbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyICogd29ya2dyb3VwU2l6ZX0+O1xuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3dvcmtncm91cFNpemUsIDEsIDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt3b3JrZ3JvdXBTaXplfSkgKiAke291dHB1dE51bWJlcn1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7YXR0cmlidXRlcy5ibG9ja1NpemUgLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgICAke3ByZXBhcmVTY2FsZUFuZFplcm9Qb2ludCgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7YmxvYlNpemVJbldvcmRzfTsgd29yZCArPSAke2JDb21wb25lbnRzfSkge1xuICAgICAgICAgICAgICAke3ByZXBhcmVCRGF0YSgpfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtiQ29tcG9uZW50c307IGkrKykge1xuICAgICAgICAgICAgICAgICR7cHJvY2Vzc09uZVdvcmQoKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezggLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke291dHB1dE51bWJlcn0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7d29ya2dyb3VwU2l6ZX11OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke291dHB1dE51bWJlcn07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLCAnb3V0cHV0X3ZhbHVlJyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bE5CaXRzJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YXR0cmlidXRlcy5iaXRzfTske2FDb21wb25lbnRzfTske2JDb21wb25lbnRzfTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3dvcmtncm91cFNpemV9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheShpbnB1dHMubGVuZ3RoKS5maWxsKCdyYW5rJyksXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFNpemUgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG4vLyBDdXJyZW50bHksIG9ubHkgc3VwcG9ydCBibG9ja1NpemUgPSAzMi5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c0Jsb2NrU2l6ZTMyUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYVJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGltQU91dGVyID0gaW5wdXRTaGFwZVthUmFuayAtIDJdO1xuICBjb25zdCBkaW1Jbm5lciA9IGF0dHJpYnV0ZXMuaztcbiAgY29uc3QgZGltQk91dGVyID0gYXR0cmlidXRlcy5uO1xuICBjb25zdCBiYXRjaERpbXMgPSBpbnB1dFNoYXBlLnNsaWNlKDAsIGFSYW5rIC0gMik7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGJhdGNoRGltcyk7XG4gIGNvbnN0IGJsb2JTaXplID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gIGNvbnN0IGJsb2JTaXplSW5Xb3JkcyA9IGJsb2JTaXplIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhhdHRyaWJ1dGVzLmspO1xuICBjb25zdCBiQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYmxvYlNpemVJbldvcmRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYXRjaERpbXMuY29uY2F0KFtkaW1BT3V0ZXIsIGRpbUJPdXRlcl0pO1xuXG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSAxMjg7XG4gIGNvbnN0IHdvcmtncm91cFkgPSBkaW1CT3V0ZXIgJSA4ID09PSAwID8gOCA6IGRpbUJPdXRlciAlIDQgPT09IDAgPyA0IDogMTtcbiAgY29uc3Qgd29ya2dyb3VwWCA9IHdvcmtncm91cFNpemUgLyB3b3JrZ3JvdXBZO1xuICBjb25zdCB0aWxlU2l6ZSA9IHdvcmtncm91cFggKiBiQ29tcG9uZW50cyAqIDg7IC8vIGVhY2ggdWludDMyIGhhcyA4IGRhdGEuXG4gIGNvbnN0IGFMZW5ndGhQZXJUaWxlID0gdGlsZVNpemUgLyBhQ29tcG9uZW50cztcbiAgY29uc3QgYmxvY2tzUGVyVGlsZSA9IHRpbGVTaXplIC8gYXR0cmlidXRlcy5ibG9ja1NpemU7XG4gIGNvbnN0IGRpc3BhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIHdvcmtncm91cFk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGFDb21wb25lbnRzXTtcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcbiAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlVGVtcCkpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIERhdGFUeXBlLnVpbnQzMiwgYlNoYXBlLmxlbmd0aCwgYkNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPVxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGlmICh6ZXJvUG9pbnRzKSB7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHJlYWRBID0gKCkgPT4ge1xuICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHthLnR5cGUudmFsdWV9LCAke2FMZW5ndGhQZXJUaWxlfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3dvcmtncm91cFh9PiwgJHt3b3JrZ3JvdXBZfT47XG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwWCwgd29ya2dyb3VwWSwgMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBZfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke2Jsb2Nrc1BlclRpbGV9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7YUxlbmd0aFBlclRpbGV9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHthTGVuZ3RoUGVyVGlsZX07IGFfb2Zmc2V0ICs9ICR7d29ya2dyb3VwU2l6ZX0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBhX2NvbCA9IGFfY29sX3N0YXJ0ICsgYV9vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke2EuZ2V0QnlJbmRpY2VzKGAke2EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBhX2NvbClgKX07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGlsZSAqICR7YmxvY2tzUGVyVGlsZX0gKyBsb2NhbF9pZC54O1xuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xuICAgICAgICAgICAgICAgID8gYFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgXG4gICAgICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3NjYWxlcy5nZXRCeU9mZnNldChgYl9yb3cgKiBuX2Jsb2Nrc19wZXJfY29sICsgYmxvY2tgKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcyhgJHtiLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke2F0dHJpYnV0ZXMuYmxvY2tTaXplIC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcbiAgICAgICAgICAgICAgJHtyZWFkQSgpfVxuICAgICAgICAgICAgICBsZXQgYl92YWx1ZSA9ICR7YkNvbXBvbmVudHMgPT09IDEgPyBgYl9kYXRhYCA6IGBiX2RhdGFbaV1gfTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfcXVhbnRpemVkX3ZhbHVlcyA9IG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA0IH0sXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2RhdGFUeXBlfShiX3ZhbHVlX2xvd2VyWyR7aX1dKSwgJHtkYXRhVHlwZX0oYl92YWx1ZV91cHBlclske2l9XSlgLFxuICAgICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheSg4KS5maWxsKCd6ZXJvX3BvaW50Jykuam9pbignLCcpfSkpICogc2NhbGU7XG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiAyIH0sXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2Bkb3QoYV9kYXRhJHtpfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYH1gLFxuICAgICAgICAgICAgICApLmpvaW4oJyArICcpfTtcbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4IC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke3dvcmtncm91cFl9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBYfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWR4KWAsICdvdXRwdXRfdmFsdWUnKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCbG9ja3dpc2VNYXRNdWxOQml0czMyJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7d29ya2dyb3VwWH07JHt3b3JrZ3JvdXBZfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bE5CaXRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoXG4gICAgYXR0cmlidXRlcy5ibG9ja1NpemUgPT09IDMyICYmXG4gICAgY29udGV4dC5hZGFwdGVySW5mby5pc1ZlbmRvcignaW50ZWwnKSAmJlxuICAgIGNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2dlbi0xMmxwJylcbiAgKSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdE11bE5CaXRzQmxvY2tTaXplMzJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1hdE11bE5CaXRzQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PE1hdE11bE5CaXRzQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBQYWRBdHRyaWJ1dGVzIHtcbiAgLy8gMC1jb25zdGFudCwgMS1yZWZsZWN0LCAyLWVkZ2UsIDMtd3JhcFxuICByZWFkb25seSBtb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHBhZHM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMikge1xuICAgIGxldCB2YWxpZFBhZHMgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFsaWRQYWRzID0gaW5wdXRzWzNdLmRpbXNbMF0gKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZFBhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRQYWRDb25zdGFudCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRSZWZsZWN0ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDEpO1xuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZEVkZ2UgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkV3JhcCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFNuaXBwZXQgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHN0cmluZyA9PiB7XG4gIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdldFBhZENvbnN0YW50KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0UGFkUmVmbGVjdChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldFBhZEVkZ2Uob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBnZXRQYWRXcmFwKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUGFkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0c1swXS5kaW1zLnNsaWNlKCksIGF0dHJpYnV0ZXMucGFkcyk7XG4gIGNvbnN0IGlucHV0RGltcyA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcbiAgXTtcblxuICBjb25zdCBpc1ZhbHVlRnJvbUlucHV0ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhO1xuICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAwKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBpc1ZhbHVlRnJvbUlucHV0ID8gaW5wdXRzWzJdLmRhdGFUeXBlIDogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMudmFsdWUgfSk7XG4gIH1cblxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXREaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgIGNvbnN0IHBhZFNuaXBwZXQgPSBnZXRQYWRTbmlwcGV0KG91dHB1dCwgaW5wdXREaW1zLmxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnY29uc3RhbnRfdmFsdWUnLCB0eXBlOiAoaXNWYWx1ZUZyb21JbnB1dCA/IGRhdGFUeXBlIDogJ2YzMicpIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgwKTtcbiAgICAgICAgICAgICR7cGFkU25pcHBldH1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQYWQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMubW9kZX0ke2lzVmFsdWVGcm9tSW5wdXR9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YVxuICAgICAgICA/IGlucHV0c1syXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNlxuICAgICAgICAgID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF1cbiAgICAgICAgICA6IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXVxuICAgICAgICA6IDAuMDtcblxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVQYWRzID0gbmV3IEludDMyQXJyYXkoMiAqIGlucHV0UmFuaykuZmlsbCgwKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQYWRzW051bWJlcihheGVzW2ldKV0gPSBOdW1iZXIoYmlnSW50NjRQYWRzW2ldKTtcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSkgKyBpbnB1dFJhbmtdID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpICsgYXhlcy5sZW5ndGhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmlnSW50NjRQYWRzLmZvckVhY2goKHYsIGkpID0+ICh1cGRhdGVQYWRzW051bWJlcihpKV0gPSBOdW1iZXIodikpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRzOiBudW1iZXJbXSA9IFtdO1xuICAgIHVwZGF0ZVBhZHMuZm9yRWFjaCgodikgPT4gcGFkcy5wdXNoKHYpKTtcblxuICAgIHJldHVybiB7IG1vZGU6IGF0dHJpYnV0ZXMubW9kZSwgdmFsdWUsIHBhZHMgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIFRPRE86IHN1cHBvcnQ6XG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXG4vLyAtIFtNYXhQb29sXSBkaWxhdGlvbnMgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfZGlsYXRpb25zXCJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIHwgTWF4UG9vbEF0dHJpYnV0ZXM+KFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IGlucHV0LmRpbXMuc2xpY2UoKTtcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgLy8gTW92ZSBjaGFubmVsIHRvIHRoZSBzZWNvbmQgcG9zaXRpb24uXG4gIH1cbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCwga2VybmVsU2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkcyk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IFBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LFxuICAgIHN0cmlkZXMsXG4gICAgZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA9IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbik6IFtQcm9ncmFtVW5pZm9ybVtdLCBVbmlmb3Jtc0FycmF5VHlwZSwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtlcm5lbFNpemUgfSxcbiAgXTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIHsgbmFtZTogJ2tlcm5lbFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICBdO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnRFbmROb3RaZXJvID0gISEocHdTdGFydCArIHB3RW5kKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrdyB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN3IH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdTdGFydCB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHB3RW5kIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncHdTdGFydCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwd0VuZCcsIHR5cGU6ICd1MzInIH0sXG4gICAgKTtcblxuICAgIGxldCBwaFN0YXJ0RW5kTm90WmVybyA9IGZhbHNlO1xuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qga2ggPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBwaFN0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMl07XG4gICAgICBjb25zdCBwaEVuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMl07XG4gICAgICBwaFN0YXJ0RW5kTm90WmVybyA9ICEhKHBoU3RhcnQgKyBwaEVuZCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtoIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhTdGFydCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhFbmQgfSxcbiAgICAgICk7XG5cbiAgICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHsgbmFtZTogJ2toJywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAnc2gnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaFN0YXJ0JywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAncGhFbmQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCB0cnVlLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTdHJpZGVzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna2VybmVsU3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGtlcm5lbFN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggfSxcbiAgICApO1xuXG4gICAgY29uc3QgaGFzUGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xuICAgIHJldHVybiBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgISFoYXNQYWRzLCBmYWxzZSwgZmFsc2VdO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICB4OiBJbmRpY2VzSGVscGVyLFxuICByYW5rOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlUmFuazogbnVtYmVyLFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuICBvcDE6IHN0cmluZyxcbiAgb3AyOiBzdHJpbmcsXG4gIHN0YXJ0OiBudW1iZXIsXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgaGFzUGFkczogYm9vbGVhbixcbiAgcHdTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4gIHBoU3RhcnRFbmROb3RaZXJvOiBib29sZWFuLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHgudHlwZS50ZW5zb3IsIG91dHB1dFNoYXBlUmFuayk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIDw9IDIpIHtcbiAgICBsZXQgY29kZVcgPSAnJztcbiAgICBsZXQgY29kZUggPSAnJztcbiAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICBjb25zdCBkaW1JZHhXID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDIgOiAxKTtcbiAgICBpZiAocHdTdGFydEVuZE5vdFplcm8pIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeFd9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhXfV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4V31dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBkaW1JZHhIID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDMgOiAyKTtcbiAgICAgIGlmIChwaFN0YXJ0RW5kTm90WmVybykge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtkaW1JZHhIfV0gPCAwIHx8IHhJbmRpY2VzWyR7ZGltSWR4SH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhIfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeEh9XSA9IGluZGljZXNbJHtkaW1JZHhIfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICB9XG5cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KCR7c3RhcnR9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7Y29kZUh9XG4gICAgICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgICAgICR7Y29kZUhFbmR9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlc1JhbmsgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBwYWRzUmFuayA9IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGg7XG4gICAgbGV0IHBhZENvZGUgPSAnJztcbiAgICBpZiAoaGFzUGFkcykge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3N0cmlkZXNSYW5rfT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3N0cmlkZXNSYW5rIC0gMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtzdHJpZGVzUmFuayAtIDF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7cmFuayAtIHN0cmlkZXNSYW5rfXU7IGogPCAke3Jhbmt9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke2dldEVsZW1lbnRBdChcbiAgICAgICAgICAgICAgICAgICAgJ3VuaWZvcm1zLnN0cmlkZXMnLFxuICAgICAgICAgICAgICAgICAgICBgaiAtICR7cmFuayAtIHN0cmlkZXNSYW5rfXVgLFxuICAgICAgICAgICAgICAgICAgICBzdHJpZGVzUmFuayxcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dV0gLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsICdqIC0gMnUnLCBwYWRzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgJHtwYWRDb2RlfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29tbW9uQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthdHRyaWJ1dGVzLmNlaWxNb2RlfTske2F0dHJpYnV0ZXMuYXV0b1BhZH07JHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aH1gO1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZH1gO1xuXG5jb25zdCBjcmVhdGVNYXhQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5zdG9yYWdlT3JkZXJ9OyR7YXR0cmlidXRlcy5kaWxhdGlvbnN9YDtcblxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XG4gIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J10sXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcbiAga2VybmVsU2hhcGU6IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xufVxuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcbiAgICBpbnB1dCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICk7XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG5cbiAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XG4gIGxldCBvcDIgPSAnJztcbiAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWQpIHtcbiAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XG4gIH0gZWxzZSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSAke2RhdGFUeXBlfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7XG4gIH1cbiAgY29uc3QgW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb10gPSBnZXRVbmlmb3JtQW5kUGFkSW5mbyhcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtoYXNQYWRzfTske3B3U3RhcnRFbmROb3RaZXJvfTske3BoU3RhcnRFbmROb3RaZXJvfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxuICAgICAgZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICB4LFxuICAgICAgICBpbnB1dC5kaW1zLmxlbmd0aCxcbiAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoLFxuICAgICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICAgIG9wMSxcbiAgICAgICAgb3AyLFxuICAgICAgICAwLjAsXG4gICAgICAgIHVuaWZvcm1zLFxuICAgICAgICBoYXNQYWRzLFxuICAgICAgICBwd1N0YXJ0RW5kTm90WmVybyxcbiAgICAgICAgcGhTdGFydEVuZE5vdFplcm8sXG4gICAgICApLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuY291bnRfaW5jbHVkZV9wYWQgYXMgbnVtYmVyKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgfVxuICBjb25zdCBhdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSB7IGNvdW50SW5jbHVkZVBhZCwgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XG4gIHJldHVybiB7IC4uLmF2ZXJhZ2VQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXZlcmFnZVBvb2xBdHRyaWJ1dGVzKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmNvbnN0IGdsb2JhbFBvb2xBdHRyaWJ1dGVzID0ge1xuICBhdXRvUGFkOiAnJyxcbiAgY2VpbE1vZGU6IDAsXG4gIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsXG4gIGtlcm5lbFNoYXBlOiBbXSxcbiAgc3RyaWRlczogW10sXG4gIHBhZHM6IFtdLFxuICBzdG9yYWdlT3JkZXI6IDAsXG4gIGRpbGF0aW9uczogW10sXG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnR2xvYmFsQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuY29uc3QgY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID0gZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKFxuICAgIGlucHV0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3Qgb3AxID0gYFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgO1xuICBjb25zdCBvcDIgPSAnJztcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxuICAgIG91dHB1dFNoYXBlLFxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgICAgICBzaGFkZXJIZWxwZXIsXG4gICAgICAgIHgsXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxuICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGgsXG4gICAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgICAgb3AxLFxuICAgICAgICBvcDIsXG4gICAgICAgIGlucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gLTY1NTA0IDogLTFlNSxcbiAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgIGhhc1BhZHMsXG4gICAgICAgIHB3U3RhcnRFbmROb3RaZXJvLFxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcbiAgICAgICksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5zdG9yYWdlX29yZGVyIGFzIG51bWJlcjtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHsgc3RvcmFnZU9yZGVyLCBkaWxhdGlvbnMsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJyB9O1xuICByZXR1cm4geyAuLi5tYXhQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhtYXhQb29sQXR0cmlidXRlcykgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMV0uZGltcyA9PT0gaW5wdXRzWzJdLmRpbXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3gtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLicpO1xuICB9XG4gIC8vIHZhbGlkYXRlIHNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0IHNoYXBlc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyB6ZXJvLXBvaW50IGlucHV0IHR5cGUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGlucHV0IGRhdGEgdHlwZS5cbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuJyk7XG4gICAgfVxuICAgIC8vIFNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcbiAgICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMl0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xuICAgIH1cbiAgICBpZiAoIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gZCA9PT0gaW5wdXRzWzJdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLicpO1xuICAgIH1cbiAgfVxuICAvLyBWYWxpZGF0ZSBibG9ja1NpemVcbiAgaWYgKGF0dHJpYnV0ZXMuYmxvY2tTaXplID4gMCkge1xuICAgIC8vIEJsb2NrIHF1bmF0aXphdGlvblxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggPT09IDAgfHwgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMV0uZGltc1swXSA9PT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tTaXplIG11c3QgYmUgc2V0IG9ubHkgZm9yIGJsb2NrIHF1YW50aXphdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gaSA9PT0gYXR0cmlidXRlcy5heGlzIHx8IGQgPT09IGlucHV0c1swXS5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXMnKTtcbiAgICB9XG4gICAgLy8gU2NhbGUgaW5wdXQgcmFuayBzaG91bGQgYmUgc2FtZSBhcyB0aGUgaW5wdXQgcmFua1xuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay4nKTtcbiAgICB9XG4gICAgY29uc3QgZEkgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xuICAgIGNvbnN0IHNpID0gaW5wdXRzWzFdLmRpbXNbYXR0cmlidXRlcy5heGlzXTtcbiAgICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPCBNYXRoLmNlaWwoZEkgLyBzaSkgfHwgYXR0cmlidXRlcy5ibG9ja1NpemUgPiBNYXRoLmNlaWwoZEkgLyAoc2kgLSAxKSAtIDEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVEZXF1YW50aXplTGluZWFyUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4O1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zOyAvLyBvdXRwdXQgc2hhcGUgaXMgc2FtZSBhcyB0aGUgaW5wdXQgc2hhcGVcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7IC8vIG91dHB1dCB0eXBlIGlzIHNhbWUgYXMgdGhlIHRoZSBzY2FsZSBpbnB1dCB0eXBlXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGlzUGFja2VkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4IHx8IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUudWludDg7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpc1BhY2tlZCA/IFtNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRzWzBdLmRpbXMpIC8gNCldIDogaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgemVyb1BvaW50SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMiA/IGlucHV0c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgemVyb1BvaW50U2hhcGUgPSB6ZXJvUG9pbnRJbnB1dFxuICAgID8gaXNQYWNrZWRcbiAgICAgID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRJbnB1dC5kaW1zKSAvIDQpXVxuICAgICAgOiB6ZXJvUG9pbnRJbnB1dC5kaW1zXG4gICAgOiB1bmRlZmluZWQ7XG4gIC8vIFNjYWxlcyBpbnB1dCBpcyBhIHNjYWxlciBmb3IgcGVyLXRlbnNvci9wZXItbGF5ZXIgcXVhbnRpemF0aW9uLCAxLUQgdGVuc29yIGZvciBwZXItYXhpcyBxdWFudGl6YXRpb25cbiAgLy8gb3IgdGVuc29yIHdpdGggc2FtZSByYW5rIGFzIGlucHV0IGZvciBibG9ja2VkIHF1YW50aXphdGlvbi5cbiAgY29uc3QgcGVyTGF5ZXJRdWFudGl6YXRpb24gPSBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMCB8fCAoc2NhbGVTaGFwZS5sZW5ndGggPT09IDEgJiYgc2NhbGVTaGFwZVswXSA9PT0gMSk7XG4gIGNvbnN0IHBlckF4aXNRdWFudGl6YXRpb24gPSBwZXJMYXllclF1YW50aXphdGlvbiA9PT0gZmFsc2UgJiYgc2NhbGVTaGFwZS5sZW5ndGggPT09IDE7XG4gIC8vIExlZnQgdW5uZWNlc3NhcnkgY29tbWVudGVkLW91dCBhc3NpZ25tZW50IGZvciBkb2N1bWVudGF0aW9uXG4gIC8vIGNvbnN0IGJsb2NrUXVhbnRpemF0aW9uID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gPT09IGZhbHNlICYmIHBlckF4aXNRdWFudGl6YXRpb24gPT09IGZhbHNlO1xuICBjb25zdCBtYXhDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaXplKTtcbiAgY29uc3QgdXNlQ29tcG9uZW50cyA9IHBlckxheWVyUXVhbnRpemF0aW9uICYmICghaXNQYWNrZWQgfHwgbWF4Q29tcG9uZW50cyA9PT0gNCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VDb21wb25lbnRzID8gbWF4Q29tcG9uZW50cyA6IDE7XG4gIGNvbnN0IGlucHV0Q29tcG9uZW50ID0gdXNlQ29tcG9uZW50cyAmJiAhaXNQYWNrZWQgPyBtYXhDb21wb25lbnRzIDogMTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlzUGFja2VkID8gRGF0YVR5cGUudWludDMyIDogaW5wdXRUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgaW5wdXRDb21wb25lbnQpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgZGF0YVR5cGUsIHNjYWxlU2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgemVyb1BvaW50ID0gemVyb1BvaW50SW5wdXRcbiAgICA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnQnLCBpc1BhY2tlZCA/IERhdGFUeXBlLnVpbnQzMiA6IGlucHV0VHlwZSwgemVyb1BvaW50U2hhcGUhLmxlbmd0aClcbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtpbnB1dCwgc2NhbGVdO1xuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICB9XG4gIGNvbnN0IGlucHV0U2hhcGVzID0gW2lucHV0U2hhcGUsIHNjYWxlU2hhcGVdO1xuICBpZiAoemVyb1BvaW50SW5wdXQpIHtcbiAgICBpbnB1dFNoYXBlcy5wdXNoKHplcm9Qb2ludFNoYXBlISk7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIC8gY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRTaGFwZXMsIG91dHB1dFNoYXBlKSxcbiAgXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYXhpcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAvIDQnKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoaW5wdXQpJyA6ICd1bnBhY2s0eFU4KGlucHV0KSd9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAke2NvbXBvbmVudHMgPT09IDEgPyAneF92ZWNbZ2xvYmFsX2lkeCAlIDRdJyA6ICd4X3ZlYyd9O2A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB4X3ZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgc2NhbGFyICgpXG4gICAgICAgICAgICAgIHJldHVybiBgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCcwJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyQXhpc1F1YW50aXphdGlvbikge1xuICAgICAgICAgICAgICAvLyBzY2FsZSBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeU9mZnNldCgnc2NhbGVfaW5kZXgnKX07YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJsb2NrIHF1YW50aXphdGlvbi4gU2NhbGUgaW5wdXQgcmFuayBpcyBzYW1lIGFzIGlucHV0L291dHB1dCByYW5rLlxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7c2NhbGUudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtzY2FsZS5pbmRpY2VzR2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAgICAgJHtzY2FsZS5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAnaW5kZXgnKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7c2NhbGUuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIHNjYWxhclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCcwJyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoemVyb19wb2ludF9pbnB1dCknIDogJ3VucGFjazR4VTgoemVyb19wb2ludF9pbnB1dCknfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJzAnKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJBeGlzUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCAvIDQnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9ja2VkUXVhbnRpemF0aW9uLiBUaGUgemVyby1wb2ludCBpbnB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgYWxvbmcgYXhpcy5cbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ3NjYWxlX2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9vZmZzZXQgLyA0Jyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtpc1BhY2tlZCA/IChpc1NpZ25lZCA/ICdpMzInIDogJ3UzMicpIDogaW5wdXQudHlwZS52YWx1ZX0oMCk7YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpfTtcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBgJHtvdXRwdXQudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVxdWFudGl6ZUxpbmVhcicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogemVyb1BvaW50ID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGNvbXBvbmVudHMgLyA2NCksIHk6IDEsIHo6IDEgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXF1YW50aXplTGluZWFyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcXVhbnRpemVMaW5lYXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIsIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c0NvbnRlbnQgPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBzYW1lU3RhcnRMaW1pdCA9IHN0YXJ0ID09PSBsaW1pdDtcbiAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBsaW1pdCAmJiBkZWx0YSA8IDA7XG4gIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0YXJ0ID4gbGltaXQgJiYgZGVsdGEgPiAwO1xuXG4gIGlmIChzYW1lU3RhcnRMaW1pdCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHwgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIik7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8gPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlciwgZGF0YVR5cGU6IERhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgobGltaXQgLSBzdGFydCkgLyBkZWx0YSkpO1xuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbbnVtRWxlbWVudHNdO1xuICBjb25zdCBvdXRwdXRTaXplID0gbnVtRWxlbWVudHM7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogZGF0YVR5cGUsIGRhdGE6IHN0YXJ0IH0sXG4gICAgeyB0eXBlOiBkYXRhVHlwZSwgZGF0YTogZGVsdGEgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IHdnc2xUeXBlID0gb3V0cHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzdGFydCcsIHR5cGU6IHdnc2xUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgIHsgbmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d2dzbFR5cGV9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7ZGF0YVR5cGV9YCB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJhbmdlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBsaW1pdCA9IDA7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgfVxuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCkge1xuICAgIHZhbGlkYXRlSW5wdXRzQ29udGVudChzdGFydCwgbGltaXQsIGRlbHRhKTtcbiAgfVxuXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSYW5nZVByb2dyYW1JbmZvKHN0YXJ0LCBsaW1pdCwgZGVsdGEsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKSwgeyBpbnB1dHM6IFtdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XG4gIHwgJ2hhbGZfcGl4ZWwnXG4gIHwgJ2FzeW1tZXRyaWMnXG4gIHwgJ3B5dG9yY2hfaGFsZl9waXhlbCdcbiAgfCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nXG4gIHwgJ2FsaWduX2Nvcm5lcnMnXG4gIHwgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSdcbiAgfCAnaGFsZl9waXhlbF9zeW1tZXRyaWMnO1xuXG50eXBlIEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9ICdzdHJldGNoJyB8ICdub3Rfc21hbGxlcicgfCAnbm90X2xhcmdlcic7XG5cbnR5cGUgTW9kZSA9ICduZWFyZXN0JyB8ICdsaW5lYXInIHwgJ2N1YmljJztcblxudHlwZSBOZWFyZXN0TW9kZSA9ICdyb3VuZF9wcmVmZXJfZmxvb3InIHwgJ3JvdW5kX3ByZWZlcl9jZWlsJyB8ICdmbG9vcicgfCAnY2VpbCcgfCAnc2ltcGxlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYW50aWFsaWFzOiBudW1iZXI7XG4gIGF4ZXM6IG51bWJlcltdO1xuICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIG1vZGU6IE1vZGU7XG4gIG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZTtcbn1cblxuY29uc3QgdmFsaWRhdGVTY2FsZXMgPSAoc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBzY2FsZXMuZXZlcnkoXG4gICAgKHZhbHVlKSA9PlxuICAgICAgdmFsdWUgPiAwIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICB9KSxcbiAgKTtcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xuICBpZiAoc2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xuICAgICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDIgfHxcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAzIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA1ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvciBsaW5lYXIgbW9kZSwgUmVzaXplIHJlcXVpcmVzIHNjYWxlcyB0byBiZSAyRCwgM0QsIDREIHdpdGggZWl0aGVyIHR3byBvdXRlcm1vc3Qgb3Igb25lIGlubmVybW9zdCBhbmRcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdjdWJpYycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAyIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB1cGRhdGVTY2FsZXMgPSAoc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgYXhlcy5ldmVyeShcbiAgICAodmFsdWUpID0+XG4gICAgICAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IHJhbmspIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcbiAgICAgIH0pLFxuICApO1xuICBjb25zdCBuZXdTY2FsZXMgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgxLjApO1xuICBheGVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gKG5ld1NjYWxlc1t2YWx1ZV0gPSBzY2FsZXNbaW5kZXhdKSk7XG4gIHJldHVybiBuZXdTY2FsZXM7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxuICBzY2FsZXM6IG51bWJlcltdLFxuICBzaXplczogbnVtYmVyW10sXG4gIHJvaTogbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgW3JvaUlucHV0SW5kZXgsIHNjYWxlc0lucHV0SW5kZXgsIHNpemVzSW5wdXRJbmRleF0gPVxuICAgIG9wc2V0VmVyc2lvbiA+IDEwID8gWzEsIDIsIDNdIDogWy0xLCBpbnB1dHMubGVuZ3RoID4gMSA/IDEgOiAtMSwgLTFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAocm9pSW5wdXRJbmRleCA+IDAgJiYgaW5wdXRzLmxlbmd0aCA+IHJvaUlucHV0SW5kZXggJiYgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmRpbXMubGVuZ3RoID4gMCkge1xuICAgIGlucHV0c1tyb2lJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gcm9pLnB1c2godmFsdWUpKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemUnKTtcbiAgfVxuXG4gIGlmIChcbiAgICBzY2FsZXNJbnB1dEluZGV4ID4gMCAmJlxuICAgIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXMubGVuZ3RoID09PSAxICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXNbMF0gPiAwXG4gICkge1xuICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2NhbGVzLnB1c2godmFsdWUpKTtcbiAgICBpZiAoXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSAwICYmXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSByYW5rICYmXG4gICAgICBvcHNldFZlcnNpb24gPj0gMTggJiZcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcy5heGVzLCByYW5rKS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChzY2FsZXNbaW5kZXhdID0gdmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaWYgKFxuICAgIHNpemVzSW5wdXRJbmRleCA+IDAgJiZcbiAgICBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPT09IDEgJiZcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5kaW1zWzBdID4gMFxuICApIHtcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNpemVzLnB1c2goTnVtYmVyKHZhbHVlKSkpO1xuICAgIGlmIChzaXplcy5sZW5ndGggIT09IDAgJiYgc2l6ZXMubGVuZ3RoICE9PSByYW5rICYmIG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDAgJiYgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gMCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjYWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNpemVzICE9PSAndW5kZWZpbmVkJyAmJiBzY2FsZXMubGVuZ3RoID4gMCAmJiBzaXplcy5sZW5ndGggPiByYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSA9IChcbiAgY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXG4gIGRUeXBlOiBzdHJpbmcsXG4pOiBzdHJpbmcgPT5cbiAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHtkVHlwZX0geyBgICtcbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKGNvb3JkaW5hdGVUcmFuc2Zlck1vZGUpIHtcbiAgICAgIGNhc2UgJ2FzeW1tZXRyaWMnOlxuICAgICAgICByZXR1cm4gYHJldHVybiAke2RUeXBlfSh4UmVzaXplZCkgLyAke2RUeXBlfSh4U2NhbGUpO2A7XG4gICAgICBjYXNlICdweXRvcmNoX2hhbGZfcGl4ZWwnOlxuICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpIC0gMC41O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgY2FzZSAndGZfaGFsZl9waXhlbF9mb3Jfbm4nOlxuICAgICAgICByZXR1cm4gYHJldHVybiAoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSk7YDtcbiAgICAgIGNhc2UgJ2FsaWduX2Nvcm5lcnMnOlxuICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlID0gJHtkVHlwZX0oeFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAvIChsZW5ndGhSZXNpemVkIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJHtkVHlwZX0oeFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAlIChsZW5ndGhSZXNpemVkIC0gMSkpIC8gJHtkVHlwZX0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgY2FzZSAndGZfY3JvcF9hbmRfcmVzaXplJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7ZFR5cGV9KHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7ZFR5cGV9KHhSZXNpemVkKSAqICR7ZFR5cGV9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke2RUeXBlfShyb2lTdGFydCArIHJvaUVuZCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICBjYXNlICdoYWxmX3BpeGVsX3N5bW1ldHJpYyc6XG4gICAgICAgIHJldHVybiBgY29uc3Qgb3V0cHV0V2lkdGggPSAke2RUeXBlfXhTY2FsZSAqICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xuICAgICAgY2FzZSAnaGFsZl9waXhlbCc6XG4gICAgICAgIHJldHVybiBgcmV0dXJuICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtjb29yZGluYXRlVHJhbnNmZXJNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwgPSAobmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb246IG51bWJlciwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBgZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtkVHlwZX0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtkVHlwZX0ge2AgK1xuICAoKCkgPT4ge1xuICAgIHN3aXRjaCAobmVhcmVzdE1vZGUpIHtcbiAgICAgIGNhc2UgJ3JvdW5kX3ByZWZlcl9jZWlsJzpcbiAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0nO1xuICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICByZXR1cm4gJ3JldHVybiBmbG9vcih4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfZmxvb3InOlxuICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICBjYXNlICdzaW1wbGUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG9wc2V0VmVyc2lvbiA8IDExKSB7XG4gICAgICAgICAgcmV0dXJuICdpZiAoaXNEb3duU2FtcGxlKSBcXFxuICAgICAgICAgICAgICAgICAgICB7IFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyBcXFxuICAgICAgICAgICAgICAgICAgICB9JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcbiAgY29uc3Qgcm9pTG9jYWwgPSByb2kubGVuZ3RoID09PSAwID8gcm9pVG1wIDogcm9pLnNsaWNlKCk7XG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHJvaVRtcFt2XSA9IHJvaUxvY2FsW2ldO1xuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvaVRtcDtcbiAgfVxuICByZXR1cm4gcm9pTG9jYWw7XG59O1xuXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogbnVtYmVyW10gPT4ge1xuICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGlmIChzaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcbiAgICAgIGlmIChNYXRoLm1heCguLi5heGVzKSA+IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcyBpcyBvdXQgb2YgYm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGF4ZXMuZm9yRWFjaCgodiwgaSkgPT4gKG91dHB1dFNoYXBlW3ZdID0gc2l6ZXNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZXMuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZXNbaW5kZXhdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHNjYWxlSW5Qb2xpY3kgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWluKC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NQVhfVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgY2FzZSAnbm90X3NtYWxsZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWF4KC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NSU5fVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1heCguLi5zY2FsZXMsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKTtcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgY29uc3QgYWRqdXN0ZWRPdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChzY2FsZXNbdl0gPSBzY2FsZUluUG9saWN5KSk7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChhZGp1c3RlZE91dHB1dFNoYXBlW3ZdID0gTWF0aC5yb3VuZChpbnB1dFNoYXBlW3ZdICogc2NhbGVzW3ZdKSkpO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlcy5maWxsKHNjYWxlSW5Qb2xpY3ksIDAsIHNjYWxlcy5sZW5ndGgpO1xuICAgIGFkanVzdGVkT3V0cHV0U2hhcGUuZm9yRWFjaCgodiwgaSkgPT4gKGFkanVzdGVkT3V0cHV0U2hhcGVbaV0gPSBNYXRoLnJvdW5kKHYgKiBzY2FsZXNbaV0pKSk7XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke1xuICAgICAgb3V0cHV0LnR5cGUudmFsdWVcbiAgICB9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWA7XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCAnaScsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5vdXRwdXRfc2hhcGUnLCAnaScsIG91dHB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHt1c2VFeHRyYXBvbGF0aW9ufSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHtvdXRwdXQudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kgLSAxKSkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGUgPCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJyBpbnB1dF9pbmRleCcpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgfWA7XG5jb25zdCBjaGVja0lucHV0SW5kaWNlcyA9IChpbnB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWA7XG5cbmNvbnN0IHNldENoYW5uZWxBbmRCYXRjaEluZGljZXMgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBjaGFubmVsSWR4OiBudW1iZXIsXG4gIGJhdGNoSWR4OiBudW1iZXIsXG4gIHNwYWNpYWxEaW1zOiBudW1iZXIsXG4pOiBzdHJpbmcgPT5cbiAgaW5wdXQucmFuayA+IHNwYWNpYWxEaW1zXG4gICAgPyBgXG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgY2hhbm5lbElkeCwgJ2NoYW5uZWwnKX07XG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgYmF0Y2hJZHgsICdiYXRjaCcpfTtcbmBcbiAgICA6ICcnO1xuXG5jb25zdCBiaWxpbmVhckludGVycG9sYXRpb24gPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gIGNvbnN0IFtiYXRjaElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxuICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAyID8gWy0xLCAwLCAxLCAtMV0gOiBpc05jaHcgPyBbMCwgMiwgMywgMV0gOiBbMCwgMSwgMiwgM107XG4gIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgcmV0dXJuIGBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihyb3csICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIHdpZHRoSWR4LCBgbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzKGlucHV0LCBjaGFubmVsSWR4LCBiYXRjaElkeCwgMil9XG4gICAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIHJvdzoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2hlaWdodElkeH1dO1xuICAgICAgdmFyIGNvbDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske3dpZHRoSWR4fV07XG4gICAgICAke1xuICAgICAgICB1c2VFeHRyYXBvbGF0aW9uXG4gICAgICAgICAgPyBgaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgIH1gXG4gICAgICAgICAgOiAnJ1xuICAgICAgfTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMiA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgeDExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogJHtkVHlwZX0gPSBhYnMocm93IC0gJHtkVHlwZX0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoY29sIC0gJHtkVHlwZX0oY29sMSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWA7XG59O1xuXG5jb25zdCBiaWN1YmljSW50ZXJwb2xhdGlvbiA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgcm9pOiByZWFkb25seSBudW1iZXJbXSxcbiAgY3ViaWNDb2VmZkE6IG51bWJlcixcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXMyRCA9IGlucHV0U2hhcGUubGVuZ3RoID09PSAyO1xuICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICBjb25zdCBbaGVpZ2h0SWR4LCB3aWR0aElkeF0gPSBpczJEID8gWzAsIDFdIDogaXNOY2h3ID8gWzIsIDNdIDogWzEsIDJdO1xuICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gIGNvbnN0IGNyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gKGlkeDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBpZHggPT09IGhlaWdodElkeCA/ICdyb3cnIDogJ2NvbCc7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZuICR7ZGlyZWN0aW9ufUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke1xuICAgICAgICBvdXRwdXQudHlwZS5pbmRpY2VzXG4gICAgICB9KSAtPiAke2RUeXBlfSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGlkeCl9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7ZFR5cGV9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtzY2FsZXNbaWR4XX0sXG4gICAgICAgICR7b3V0cHV0U2hhcGVbaWR4XX0sICR7aW5wdXRTaGFwZVtpZHhdfSwgJHtyb2lbaWR4XX0sICR7cm9pW2lkeF19ICsgJHtpbnB1dFNoYXBlLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7dXNlRXh0cmFwb2xhdGlvbn0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke2lucHV0U2hhcGVbaWR4XX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHtkaXJlY3Rpb259OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4ICsgJHtkVHlwZX0oaSk7XG4gICAgICAgICAgaWYgKCR7ZGlyZWN0aW9ufSA8IDAgfHwgJHtkaXJlY3Rpb259ID49ICR7aW5wdXRTaGFwZVtpZHhdfSkge1xuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXhjbHVkZU91dHNpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlRXh0cmFwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtkaXJlY3Rpb259ID0gbWF4KDAsIG1pbigke2RpcmVjdGlvbn0sICR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKTtgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IGlucHV0X2luZGljZXM7XG4gICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzX2NvcHknLCBpZHgsIGB1MzIoJHtkaXJlY3Rpb259KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7XG4gICAgICAgICAgICBpZHggPT09IGhlaWdodElkeFxuICAgICAgICAgICAgICA/IGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlc19jb3B5JylcbiAgICAgICAgICAgICAgOiAncm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXNfY29weSwgb3V0cHV0X2luZGljZXMpJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiBgXG4gICAgJHtjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbihoZWlnaHRJZHgpfTtcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKHdpZHRoSWR4KX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7ZFR5cGV9KSAtPiBhcnJheTwke2RUeXBlfSwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7ZFR5cGV9ID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiAke2RUeXBlfSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke2RUeXBlfSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2N1YmljQ29lZmZBfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7XG4gICAgICBjdWJpY0NvZWZmQVxuICAgIH0pICogb25lUGx1c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgY29lZmZzWzFdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogYWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7Y3ViaWNDb2VmZkF9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHtjdWJpY0NvZWZmQX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xuICAgIGNvZWZmc1szXSA9ICgoJHtjdWJpY0NvZWZmQX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogdHdvTWludXNBYnNTICsgOCAqICR7XG4gICAgICBjdWJpY0NvZWZmQVxuICAgIH0pICogdHdvTWludXNBYnNTIC0gNCAqICR7Y3ViaWNDb2VmZkF9O1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cblxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTwke2RUeXBlfSwgND4sIGNvZWZzOiBhcnJheTwke2RUeXBlfSwgND4pIC0+ICR7ZFR5cGV9IHtcbiAgICB2YXIgY29lZnNTdW06ICR7ZFR5cGV9ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgO1xufTtcblxuY29uc3QgdHJpbGluZWFySW50ZXJwb2xhdGlvbiA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgY29uc3QgW2JhdGNoSWR4LCBkZXB0aElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxuICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAzID8gWy0xLCAwLCAxLCAyLCAtMV0gOiBpc05jaHcgPyBbMCwgMiwgMywgNCwgMV0gOiBbMCwgMSwgMiwgMywgNF07XG4gIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgcmV0dXJuIGBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGRlcHRoSWR4LCBgbWF4KDAsIG1pbihkZXB0aCwgJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKGhlaWdodCwgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKHdpZHRoLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7c2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyhpbnB1dCwgY2hhbm5lbElkeCwgYmF0Y2hJZHgsIDMpfVxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgIH1cblxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgZGVwdGg6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtkZXB0aElkeH1dO1xuICAgICAgdmFyIGhlaWdodDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2hlaWdodElkeH1dO1xuICAgICAgdmFyIHdpZHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgIHVzZUV4dHJhcG9sYXRpb25cbiAgICAgICAgICA/IGBpZiAoZGVwdGggPCAwIHx8IGRlcHRoID4gKCR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZVtoZWlnaHRJZHhdXG4gICAgICAgICAgICB9IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1gXG4gICAgICAgICAgOiAnJ1xuICAgICAgfTtcblxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xuICAgICAgd2lkdGggPSBtYXgoMCwgbWluKHdpZHRoLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAzID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xuXG4gICAgICB2YXIgeDExMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDExMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDEyMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgeDIxMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIxMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgZHgxOiAke2RUeXBlfSA9IGFicyhkZXB0aCAtICR7ZFR5cGV9KGRlcHRoMSkpO1xuICAgICAgdmFyIGR4MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7ZFR5cGV9ID0gYWJzKGhlaWdodCAtICR7ZFR5cGV9KGhlaWdodDEpKTtcbiAgICAgIHZhciBkeTI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGhlaWdodDIpIC0gaGVpZ2h0KTtcbiAgICAgIHZhciBkejE6ICR7ZFR5cGV9ID0gYWJzKHdpZHRoIC0gJHtkVHlwZX0od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfSh3aWR0aDIpIC0gd2lkdGgpO1xuICAgICAgaWYgKGRlcHRoMSA9PSBkZXB0aDIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcbiAgICAgICAgZHoxID0gMC41O1xuICAgICAgICBkejIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMTEgKiBkeDIgKiBkeTIgKiBkejIgKyB4MTEyICogZHgyICogZHkyICogZHoxICsgeDEyMSAqIGR4MiAqIGR5MSAqZHoyICsgeDEyMiAqIGR4MiAqIGR5MSAqIGR6MSArXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XG4gICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsXG4gIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxuICBzY2FsZXNJbnB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNpemVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgcm9pSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRUZW5zb3IuZGltcztcbiAgY29uc3Qgcm9pID0gdXBkYXRlUm9JKHJvaUlucHV0LCBhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcblxuICBsZXQgb3V0cHV0U2hhcGUgPSBpbml0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2NhbGVzSW5wdXQsIHNpemVzLCBhdHRyaWJ1dGVzLmF4ZXMpO1xuICBsZXQgc2NhbGVzID0gc2NhbGVzSW5wdXQuc2xpY2UoKTtcbiAgaWYgKHNjYWxlc0lucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHNjYWxlcyA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh2YWx1ZSA9PT0gMCA/IDEuMCA6IG91dHB1dFNoYXBlW2luZGV4XSAvIHZhbHVlKSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5ICE9PSAnc3RyZXRjaCcpIHtcbiAgICAgIG91dHB1dFNoYXBlID0gYWRqdXN0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2NhbGVzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0VGVuc29yLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUZW5zb3IuZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qgbm9TY2FsZSA9IGlucHV0U2hhcGUubGVuZ3RoID09PSBvdXRwdXRTaGFwZS5sZW5ndGggJiYgaW5wdXRTaGFwZS5ldmVyeSgoZCwgaSkgPT4gZCA9PT0gb3V0cHV0U2hhcGVbaV0pO1xuICBjb25zdCB1c2VFeHRyYXBvbGF0aW9uID0gYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgJHtcbiAgICAgICAgbm9TY2FsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6IGBcbiAgICAgICR7Z2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsIGRhdGFUeXBlKX07XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAke2NoZWNrSW5wdXRJbmRpY2VzKGlucHV0LCBpbnB1dFNoYXBlKX07XG4gICAgICAgICAgICAgICR7Z2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUsIG9wc2V0VmVyc2lvbiwgZGF0YVR5cGUpfTtcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZSxcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgICAgICBzY2FsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJvaS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbixcbiAgICAgICAgICAgICAgKX07XG4gICAgICAgICAgICAgIGA7XG4gICAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICR7Y2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0LCBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwgc2NhbGVzLmxlbmd0aCwgcm9pLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAzIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dHJpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGNhc2UgJ2N1YmljJzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiaWN1YmljSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgICAgaW5wdXRTaGFwZSxcbiAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgICAgICAgc2NhbGVzLFxuICAgICAgICAgICAgICAgICAgcm9pLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jdWJpY0NvZWZmQSxcbiAgICAgICAgICAgICAgICAgIHVzZUV4dHJhcG9sYXRpb24sXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZXhjbHVkZU91dHNpZGUsXG4gICAgICAgICAgICAgICAgKX1gO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVzaXplIG1vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSkoKX07XG4gICAgICBgXG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdzY2FsZXMnLCAnZjMyJywgc2NhbGVzLmxlbmd0aClcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgncm9pJywgJ2YzMicsIHJvaS5sZW5ndGgpXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICAgICR7XG4gICAgICAgICAgbm9TY2FsZVxuICAgICAgICAgICAgPyAnb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07J1xuICAgICAgICAgICAgOiBgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke1xuICAgICAgICAgICAgICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0ID8gJ2JpbGluZWFySW50ZXJwb2xhdGlvbicgOiAndHJpbGluZWFySW50ZXJwb2xhdGlvbidcbiAgICAgICAgICAgICAgfShvdXRwdXRfaW5kaWNlcyk7YDtcbiAgICAgICAgICAgIGNhc2UgJ2N1YmljJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHthdHRyaWJ1dGVzLm1vZGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbmBcbiAgICAgICAgfVxuICAgICAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUmVzaXplJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX18JHtvcHNldFZlcnNpb259fCR7c2NhbGVzLmxlbmd0aCA+IDAgPyBzY2FsZXMgOiAnJ318JHtcbiAgICAgICAgc2l6ZXMubGVuZ3RoID4gMCA/IHNpemVzIDogJydcbiAgICAgIH18JHtyb2kubGVuZ3RoID4gMCA/IHJvaSA6ICcnfXwke25vU2NhbGV9fCR7aW5wdXRTaGFwZX1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlcyB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiByb2kgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlciA9IGNvbnRleHQuY3VzdG9tRGF0YUJ1ZmZlcjtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcbiAgcmV0dXJuIG9wc2V0VmVyc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNpemUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgcm9pOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB0aGlzIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCBmMTYgZm9yIHJvaSB3aGVuIHBhc3NlZCBhcyBvcHRpb25hbCBpbnB1dC5cblxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcbiAgaWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzICE9PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSksIHtcbiAgICBpbnB1dHM6IFswXSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVzaXplQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGFzIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlO1xuICBjb25zdCBjdWJpY0NvZWZmQSA9IGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEgYXMgbnVtYmVyO1xuICBjb25zdCBleGNsdWRlT3V0c2lkZSA9IChhdHRyaWJ1dGVzLmV4Y2x1ZGVPdXRzaWRlIGFzIG51bWJlcikgIT09IDA7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIGNvbnN0IG1vZGU6IE1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZTtcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbnRpYWxpYXMsXG4gICAgYXhlcyxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICBjdWJpY0NvZWZmQSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICBleHRyYXBvbGF0aW9uVmFsdWUsXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxuICAgIG1vZGUsXG4gICAgbmVhcmVzdE1vZGUsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFdPUktHUk9VUF9TSVpFIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMge1xuICByZWFkb25seSBpbnRlcmxlYXZlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgbnVtSGVhZHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgcm90YXJ5RW1iZWRkaW5nRGltOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjYWxlOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IFtpbnB1dCwgcG9zaXRpb25JZHMsIGNvc0NhY2hlLCBzaW5DYWNoZV0gPSBpbnB1dHM7XG4gIGNvbnN0IHsgbnVtSGVhZHMsIHJvdGFyeUVtYmVkZGluZ0RpbSB9ID0gYXR0cmlidXRlcztcblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMgJiYgaW5wdXQuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtpbnB1dC5kaW1zLmxlbmd0aH1gKTtcbiAgfVxuICBpZiAoXG4gICAgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbXSkgJiZcbiAgICAhU2hhcGVVdGlsLmFyZUVxdWFsKHBvc2l0aW9uSWRzLmRpbXMsIFsxXSkgJiZcbiAgICBwb3NpdGlvbklkcy5kaW1zLmxlbmd0aCAhPT0gMlxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMCwgMSwgb3IgMiBkaW1lbnNpb25zLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zLmxlbmd0aH1gKTtcbiAgfVxuICBpZiAoY29zQ2FjaGUuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtjb3NDYWNoZS5kaW1zLmxlbmd0aH1gKTtcbiAgfVxuICBpZiAoc2luQ2FjaGUuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtzaW5DYWNoZS5kaW1zLmxlbmd0aH1gKTtcbiAgfVxuICBpZiAoIVNoYXBlVXRpbC5hcmVFcXVhbChjb3NDYWNoZS5kaW1zLCBzaW5DYWNoZS5kaW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7XG4gIH1cblxuICBpZiAocm90YXJ5RW1iZWRkaW5nRGltID4gMCAmJiBudW1IZWFkcyA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbnVtX2hlYWRzIG11c3QgYmUgcHJvdmlkZWQgaWYgcm90YXJ5X2VtYmVkZGluZ19kaW0gaXMgc3BlY2lmaWVkJyk7XG4gIH1cblxuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dC5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAyXTtcbiAgY29uc3QgbWF4U2VxdWVuY2VMZW5ndGggPSBjb3NDYWNoZS5kaW1zWzBdO1xuICBjb25zdCBoaWRkZW5TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0LmRpbXMsIDEpIC8gc2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGhlYWRTaXplID0gcm90YXJ5RW1iZWRkaW5nRGltID09PSAwID8gY29zQ2FjaGUuZGltc1sxXSAqIDIgOiBoaWRkZW5TaXplIC8gbnVtSGVhZHM7XG4gIGlmIChyb3RhcnlFbWJlZGRpbmdEaW0gPiBoZWFkU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncm90YXJ5X2VtYmVkZGluZ19kaW0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGVhZF9zaXplJyk7XG4gIH1cblxuICBpZiAocG9zaXRpb25JZHMuZGltcy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoYmF0Y2hTaXplICE9PSBwb3NpdGlvbklkcy5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAwIHNob3VsZCBiZSBvZiBzaXplIGJhdGNoX3NpemUsIGdvdCAke3Bvc2l0aW9uSWRzLmRpbXNbMF19YCk7XG4gICAgfVxuICAgIGlmIChzZXF1ZW5jZUxlbmd0aCAhPT0gcG9zaXRpb25JZHMuZGltc1sxXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgb2Ygc2l6ZSBzZXF1ZW5jZV9sZW5ndGgsIGdvdCAke3Bvc2l0aW9uSWRzLmRpbXNbMV19YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhlYWRTaXplIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSAmJiByb3RhcnlFbWJlZGRpbmdEaW0gLyAyICE9PSBjb3NDYWNoZS5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYElucHV0ICdjb3NfY2FjaGUnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBzYW1lIGFzIGhlYWRfc2l6ZSAvIDIgb3Igcm90YXJ5X2VtYmVkZGluZ19kaW0gLyAyLCBnb3QgJHtcbiAgICAgICAgY29zQ2FjaGUuZGltc1sxXVxuICAgICAgfWAsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChzZXF1ZW5jZUxlbmd0aCA+IG1heFNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB7IGludGVybGVhdmVkLCBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltLCBzY2FsZSB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRzWzBdLmRpbXNbMF07XG4gIGNvbnN0IGJhdGNoU3RyaWRlID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0c1swXS5kaW1zLCAxKTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGJhdGNoU3RyaWRlIC8gc2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gPSBpbnB1dHNbMl0uZGltc1sxXTtcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBoYWxmUm90YXJ5RW1iZWRkaW5nRGltICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcblxuICAvLyBSb3RhcnkgZW1iZWRkaW5ncyB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gYSBwYWlyLXdpc2UgZmFzaGlvbi4gSW4gYWNjb3JkYW5jZSwgdXNlIHRoZSBzaGFwZVxuICAvLyBbYmF0Y2ggc2l6ZSwgc2VxdWVuY2UgbGVuZ3RoLCBudW0gb2YgaGVhZHMsIG51bSBvZiBwYWlycyB0byByb3RhdGUgKyBudW0gb2YgZGltcyB0byBjb3B5XVxuICAvLyB0byB1bmZvbGQgdGhlIGdsb2JhbCBpbmRleCBpbiBzaGFkZXIuXG4gIGNvbnN0IGdsb2JhbFNoYXBlID0gbmV3IEFycmF5PG51bWJlcj4oXG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIGhpZGRlblNpemUgLyBoZWFkU2l6ZSxcbiAgICBoZWFkU2l6ZSAtIGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0sXG4gICk7XG4gIGNvbnN0IGdsb2JhbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZ2xvYmFsU2hhcGUpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTaGFwZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTdHJpZGVzIH0sXG5cbiAgICAvLyBzdHJpZGVzIGZvciBhZGRyZXNzaW5nIHRoZSBpbnB1dC9vdXRwdXQgdGVuc29yLCBpbiBwZXJtdXRhdGVkIG9yZGVyIHRvIGFsaWduIHdpdGggdGhlIHVuZm9sZGVkIGdsb2JhbCBpbmRleCxcbiAgICAvLyBpLmUuIEJTTkhcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzXG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFtiYXRjaFN0cmlkZSwgaGlkZGVuU2l6ZSwgaGVhZFNpemUsIDFdIH0pXG4gICAgICA6IFtdKSxcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0XG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oe1xuICAgICAgICAgIHR5cGU6IERhdGFUeXBlLnVpbnQzMixcbiAgICAgICAgICBkYXRhOiBbYmF0Y2hTdHJpZGUsIGhlYWRTaXplLCBzZXF1ZW5jZUxlbmd0aCAqIGhlYWRTaXplLCAxXSxcbiAgICAgICAgfSlcbiAgICAgIDogW10pLFxuXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBpbnB1dHNbMl0uZGltcywgaW5wdXRzWzNdLmRpbXMsIGlucHV0c1swXS5kaW1zKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IHBvc2l0aW9uSWRzID0gaW5wdXRWYXJpYWJsZSgncG9zaXRpb25faWRzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvc0NhY2hlID0gaW5wdXRWYXJpYWJsZSgnY29zX2NhY2hlJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IHNpbkNhY2hlID0gaW5wdXRWYXJpYWJsZSgnc2luX2NhY2hlJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG5cbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtcyhbXG4gICAgICB7IG5hbWU6ICdzY2FsZScsIHR5cGU6ICdmMzInIH0sXG4gICAgICB7IG5hbWU6ICdnbG9iYWxfc2hhcGUnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTaGFwZS5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2dsb2JhbF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2lucHV0X291dHB1dF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGggfSxcbiAgICBdKTtcblxuICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGUsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Y29zQ2FjaGUubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCdzaXplJyl9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3Bvc2l0aW9uSWRzLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdic25oLnh5Jywgb3V0cHV0VmFyaWFibGUoJycsIHBvc2l0aW9uSWRzLnR5cGUudGVuc29yLCAyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHtwb3NpdGlvbklkcy5nZXRCeU9mZnNldCgncG9zaXRpb25faWRzX2lkeCcpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke2ludGVybGVhdmVkfSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtpbnRlcmxlYXZlZH0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9IC1cbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtzaW5DYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaScsICdyZScpfVxuICAgICAgICAgICAgbGV0IGltID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9ICtcbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtjb3NDYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaicsICdpbScpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2snLCBpbnB1dC5nZXRCeU9mZnNldCgnaycpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1JvdGFyeUVtYmVkZGluZycsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICAgIGludGVybGVhdmVkLFxuICAgICAgfSkuY2FjaGVLZXksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnLCAncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoZ2xvYmFsU2hhcGUpIC8gV09SS0dST1VQX1NJWkUpIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgcm90YXJ5RW1iZWRkaW5nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNhc3RUb0YzMixcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMge1xuICBzaW1wbGlmaWVkOiBib29sZWFuO1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuJyk7XG4gIH1cblxuICBjb25zdCBpbnB1dDogVGVuc29yVmlldyA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2tpcDogVGVuc29yVmlldyA9IGlucHV0c1sxXTtcbiAgY29uc3QgZ2FtbWE6IFRlbnNvclZpZXcgPSBpbnB1dHNbMl07XG5cbiAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBza2lwLmRhdGFUeXBlIHx8IGlucHV0LmRhdGFUeXBlICE9PSBnYW1tYS5kYXRhVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlJyk7XG4gIH1cblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMgJiYgaW5wdXQuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGlmIChza2lwLmRpbXMubGVuZ3RoICE9PSAzICYmIHNraXAuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBiZSAyRCBvciAzRCcpO1xuICB9XG5cbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMl07XG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICB9XG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDJdICE9PSBzZXF1ZW5jZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZ2FtbWEuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbW1hIG11c3QgYmUgMUQnKTtcbiAgfVxuICBpZiAoZ2FtbWEuZGltc1tnYW1tYS5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICBjb25zdCBiZXRhOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzNdO1xuICAgIGlmIChiZXRhLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JldGEgbXVzdCBiZSAxRCcpO1xuICAgIH1cbiAgICBpZiAoYmV0YS5kaW1zW2JldGEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDQpIHtcbiAgICBjb25zdCBiaWFzOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzRdO1xuICAgIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpYXMgbXVzdCBiZSAxRCcpO1xuICAgIH1cbiAgICBpZiAoYmlhcy5kaW1zW2JpYXMuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMsXG4gIG91dHB1dENvdW50OiBudW1iZXIsXG4gIGlzVHJhaW5pbmc6IGJvb2xlYW4sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSBhdHRyaWJ1dGVzLnNpbXBsaWZpZWQ7XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gaW5wdXRTaXplO1xuICBjb25zdCBoaWRkZW5TaXplID0gaW5wdXRTaGFwZS5zbGljZSgtMSlbMF07XG4gIGNvbnN0IG1lYW5JbnZTdGREZXZEaW0gPSBpc1RyYWluaW5nID8gaW5wdXRTaGFwZS5zbGljZSgwLCAtMSkuY29uY2F0KDEpIDogW107XG4gIGNvbnN0IGhhc0JldGFJbnB1dCA9ICFzaW1wbGlmaWVkICYmIGlucHV0cy5sZW5ndGggPiAzO1xuICBjb25zdCBoYXNCaWFzSW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gNDtcbiAgY29uc3QgaGFzTWVhbk91dHB1dCA9IGlzVHJhaW5pbmcgJiYgb3V0cHV0Q291bnQgPiAxO1xuICBjb25zdCBoYXNJbnZTdGREZXZPdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMjtcbiAgY29uc3QgaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCA9IG91dHB1dENvdW50ID4gMztcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGhpZGRlblNpemUpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBjb21wb25lbnRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGhpZGRlblNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb24gfSxcbiAgXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXNBcnJheTogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdjb21wb25lbnRzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJyB9LFxuICAgIF07XG4gICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgaW5wdXRWYXJpYWJsZSgnc2tpcCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgaW5wdXRWYXJpYWJsZSgnZ2FtbWEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICBdO1xuICAgIGlmIChoYXNCZXRhSW5wdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JldGEnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGlmIChoYXNCaWFzSW5wdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbNF0uZGF0YVR5cGUsIGlucHV0c1s0XS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgaWYgKGhhc01lYW5PdXRwdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgfVxuICAgIGlmIChoYXNJbnZTdGREZXZPdXRwdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgfVxuICAgIGlmIChoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW5wdXRfc2tpcF9iaWFzX3N1bScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBjb25zdCB2ZWNEYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG4gICAgcmV0dXJuIGBcblxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc0FycmF5KS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc2hhcmVkIDogYXJyYXk8JHt2ZWNEYXRhVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NxdWFyZWRfc2hhcmVkIDogYXJyYXk8JHt2ZWNEYXRhVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3dvcmtncm91cFNpemUsIDEsIDFdKX1cbiAgICAgICAgbGV0IGl4ID0gbG9jYWxfaWQueDtcbiAgICAgICAgbGV0IGl5ID0gZ2xvYmFsX2lkLnggLyAke3dvcmtncm91cFNpemV9O1xuXG4gICAgICAgIGxldCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOiB1MzIgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSAvIHVuaWZvcm1zLmNvbXBvbmVudHM7XG4gICAgICAgIHZhciBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC8gJHt3b3JrZ3JvdXBTaXplfTtcbiAgICAgICAgbGV0IG9mZnNldCA9IGl4ICogc3RyaWRlICsgaXkgKiBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkO1xuICAgICAgICBsZXQgb2Zmc2V0MWQgPSBzdHJpZGUgKiBpeDtcbiAgICAgICAgaWYgKGl4ID09ICR7d29ya2dyb3VwU2l6ZSAtIDF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aGFzQmlhc0lucHV0ID8gJ2JpYXNbb2Zmc2V0MWQgKyBpXScgOiBkYXRhVHlwZSArICcoMC4wKSd9O1xuICAgICAgICAgIGxldCBpbnB1dF92YWx1ZSA9IHhbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRfdmFsdWUgKyBza2lwX3ZhbHVlICsgYmlhc192YWx1ZTtcbiAgICAgICAgICAke2hhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPyAnaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlOycgOiAnJ31cbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgZjMyX3ZhbHVlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICd2YWx1ZScpfTtcbiAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBmMzJfdmFsdWU7XG4gICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2Vfc2l6ZSA6IHUzMiA9ICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgIGZvciAodmFyIGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDE7ICBjdXJyX3NpemUgPiAwOyBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlX3NpemUgPSBjdXJyX3NpemUgKyAocmVkdWNlX3NpemUgJiAxKTtcbiAgICAgICAgICBpZiAoaXggPCBjdXJyX3NpemUpIHtcbiAgICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IHN1bV9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IHN1bV9zcXVhcmVkX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN1bSA9IHN1bV9zaGFyZWRbMF07XG4gICAgICAgIGxldCBzcXVhcmVfc3VtID0gc3VtX3NxdWFyZWRfc2hhcmVkWzBdO1xuICAgICAgICBsZXQgbWVhbiA9ICR7c3VtVmVjdG9yKCdzdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpO1xuICAgICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3N1bVZlY3Rvcignc3F1YXJlX3N1bScsIGNvbXBvbmVudHMpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgJHtcbiAgICAgICAgICBzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuICogbWVhbidcbiAgICAgICAgfSArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke2hhc01lYW5PdXRwdXQgPyAnbWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuOycgOiAnJ31cbiAgICAgICAgJHtoYXNJbnZTdGREZXZPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjsnIDogJyd9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAke3NpbXBsaWZpZWQgPyAnJyA6IGAtICR7ZGF0YVR5cGV9KG1lYW4pYH0pICpcbiAgICAgICAgICAgICR7ZGF0YVR5cGV9KGludl9zdGRfZGV2KSAqIGdhbW1hW29mZnNldDFkICsgaV1cbiAgICAgICAgICAgICR7aGFzQmV0YUlucHV0ID8gJysgYmV0YVtvZmZzZXQxZCArIGldJyA6ICcnfTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIH07XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XTtcbiAgaWYgKG91dHB1dENvdW50ID4gMSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuICBpZiAob3V0cHV0Q291bnQgPiAyKSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xuICB9XG4gIGlmIChvdXRwdXRDb3VudCA+IDMpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHtjb21wb25lbnRzfTske2hhc01lYW5PdXRwdXR9OyR7aGFzSW52U3RkRGV2T3V0cHV0fTske2hhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXR9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBpbnB1dHMubWFwKChfaW5wdXQsIF9pbmRleCkgPT4gJ3R5cGUnKSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0cyxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHtcbiAgICAgICAgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyBoaWRkZW5TaXplKSxcbiAgICAgIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2tpcExheWVyTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogaW5pdGlhbGl6ZSBpc1RyYWluaW5nIGZyb20gQ29tcHV0ZUNvbnRleHRcbiAgY29uc3QgaXNUcmFpbmluZyA9IGZhbHNlO1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIC8vIE1lYW4gYW5kIEludlN0ZERldiBhcmUgb25seSB1c2VkIGluIHRyYWluaW5nIG1vZGUgYW5kIGFyZSBub3QgcmVxdWlyZWQgZm9yIGluZmVyZW5jZS5cbiAgLy8gVGhleSBhcmUgYWRkZWQgaGVyZSBmb3IgY29tcGxldGVuZXNzIG9ubHkuXG4gIGNvbnN0IG91dHB1dHMgPSBbMF07XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMSkge1xuICAgIG91dHB1dHMucHVzaChpc1RyYWluaW5nID8gMSA6IC0zKTtcbiAgfVxuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDIpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDIgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAzKSB7XG4gICAgb3V0cHV0cy5wdXNoKDMpO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTa2lwTGF5ZXJOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIGNvbnRleHQub3V0cHV0Q291bnQsIGlzVHJhaW5pbmcpLCB7XG4gICAgb3V0cHV0cyxcbiAgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgc3RhcnRzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCB8fCBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmVuZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKTtcbiAgfVxuICBpbnB1dHMuc2xpY2UoMSkuZm9yRWFjaCgoXywgaWR4KSA9PiB7XG4gICAgaWYgKGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIgJiYgaW5wdXRzW2lkeCArIDFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke2lkeH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZWFkSW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGlkeDogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBpbnB1dDogbnVtYmVyW10gPSBbXTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPiBpZHgpIHtcbiAgICBpZiAoaW5wdXRzW2lkeF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgICBpbnB1dHNbaWR4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gaW5wdXQucHVzaChOdW1iZXIodikpKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyxcbik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHN0YXJ0czogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAxKTtcbiAgICBjb25zdCBlbmRzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDIpO1xuICAgIGxldCBheGVzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDMpO1xuICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXhlcyA9IFsuLi5BcnJheShpbnB1dHNbMF0uZGltcy5sZW5ndGgpLmtleXMoKV07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBzdGFydHMsIGVuZHMsIGF4ZXMgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbn07XG5cbmNvbnN0IGZpeFN0YXJ0RW5kVmFsdWVzID0gKFxuICB2YWx1ZTogbnVtYmVyLFxuICBpbmRleDogbnVtYmVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0ZXBzOiByZWFkb25seSBudW1iZXJbXSxcbik6IG51bWJlciA9PiB7XG4gIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgbmV3VmFsdWUgKz0gaW5wdXRTaGFwZVtheGVzW2luZGV4XV07XG4gIH1cbiAgaWYgKHN0ZXBzW2luZGV4XSA8IDApIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dIC0gMSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXdWYWx1ZSwgaW5wdXRTaGFwZVtheGVzW2luZGV4XV0pKTtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRpY2VzSW1wbCA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBzdHJpbmcgPT5cbiAgYGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke2lucHV0U2hhcGUubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RlcHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaWducycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGFydHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9pbmRleCcpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YDtcblxuY29uc3QgY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICBjb25zdCBheGVzID1cbiAgICBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMFxuICAgICAgPyBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKVxuICAgICAgOiBbLi4uQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpLmtleXMoKV07XG4gIGxldCBzdGVwcyA9IHJlYWRJbnB1dChpbnB1dHMsIDQpO1xuICBzdGVwcy5mb3JFYWNoKFxuICAgIChzdGVwKSA9PlxuICAgICAgc3RlcCAhPT0gMCB8fFxuICAgICAgKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGVwIGNhbm5vdCBiZSAwJyk7XG4gICAgICB9KSxcbiAgKTtcbiAgaWYgKHN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0ZXBzID0gQXJyYXkoYXhlcy5sZW5ndGgpLmZpbGwoMSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMubWFwKChzdGFydCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoc3RhcnQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoZW5kLCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xuXG4gIGlmIChheGVzLmxlbmd0aCAhPT0gc3RhcnRzLmxlbmd0aCB8fCBheGVzLmxlbmd0aCAhPT0gZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO1xuICB9XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFheGVzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgIHN0YXJ0cy5zcGxpY2UoaSwgMCwgMCk7XG4gICAgICAgIGVuZHMuc3BsaWNlKGksIDAsIGlucHV0U2hhcGVbaV0pO1xuICAgICAgICBzdGVwcy5zcGxpY2UoaSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNpZ25zID0gc3RlcHMubWFwKChzdGVwKSA9PiBNYXRoLnNpZ24oc3RlcCkpO1xuICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHN0ZXBzIHRvIHBvc2l0aXZlIHN0ZXBzIGFuZCByZXZlcnNlIHN0YXJ0cyBhbmQgZW5kc1xuICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpLCBhcnJheSkgPT4ge1xuICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgY29uc3QgbnVtU3RlcHMgPSAoZW5kc1tpXSAtIHN0YXJ0c1tpXSkgLyBzdGVwO1xuICAgICAgY29uc3QgbmV3RW5kID0gc3RhcnRzW2ldO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBuZXdFbmQgKyBudW1TdGVwcyAqIHN0ZXBzW2ldO1xuICAgICAgc3RhcnRzW2ldID0gbmV3U3RhcnQ7XG4gICAgICBlbmRzW2ldID0gbmV3RW5kO1xuICAgICAgYXJyYXlbaV0gPSAtc3RlcDtcbiAgICB9XG4gIH0pO1xuICAvLyBPdXRwdXQgcmFuayBpcyBleHBlY3RlZCB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0IHJhbmsuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgYXhlcy5mb3JFYWNoKChheGlzLCBfKSA9PiB7XG4gICAgb3V0cHV0U2hhcGVbYXhpc10gPSBNYXRoLmNlaWwoKGVuZHNbYXhpc10gLSBzdGFydHNbYXhpc10pIC8gc3RlcHNbYXhpc10pO1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySW5mbzogVGVuc29ySW5mbyA9IHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfTtcblxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgeyBuYW1lOiAnc3RhcnRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RhcnRzLmxlbmd0aCB9LFxuICAgIHsgbmFtZTogJ3NpZ25zJywgdHlwZTogJ2kzMicsIGxlbmd0aDogc2lnbnMubGVuZ3RoIH0sXG4gICAgeyBuYW1lOiAnc3RlcHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGVwcy5sZW5ndGggfSxcbiAgXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RhcnRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogc2lnbnMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RlcHMgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpLFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTbGljZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7c2lnbnMubGVuZ3RofV8ke3N0YXJ0cy5sZW5ndGh9XyR7c3RlcHMubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW291dHB1dFRlbnNvckluZm9dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTbGljZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHsgaW5wdXRzOiBbMF0gfSk7XG4gIC8vIGlmIChTaGFwZVV0aWwuc2l6ZShwcm9ncmFtLm91dHB1dHNbMF0uZGltcykgPiAwKSB7XG4gIC8vICAgY29udGV4dC5jb21wdXRlKHByb2dyYW1JbmZvTG9hZGVyLCB7aW5wdXRzOiBbMF19KTtcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICAvLyBUT0RPOiBzdXBwb3J0IGVtcHR5IG91dHB1dFxuICAvLyAgIHRocm93IG5ldyBFcnJvcignc2xpY2U6IG91dHB1dCBzaXplIGlzIDAnKTtcbiAgLy8gfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2xpY2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU2xpY2VBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGVuZHMgPSBhdHRyaWJ1dGVzLmVuZHMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGF4ZXMgPSBhdHRyaWJ1dGVzLmF4ZXMgYXMgbnVtYmVyW107XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBzdGFydHMsIGVuZHMsIGF4ZXMgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUT0RPOiB0aGlzIGlzIHRoZSBzYW1lIG5haXZlIGltcGxlbWVudGF0aW9uIHdlIHVzZSBmb3IgcmVkdWNlIHRoYXQgaGFzXG4vLyBwZXJmb3JtYW5jZSBsaW1pdGF0aW9ucyB3aGVuIHRoZSByZWR1Y2VkIGF4aXMgaXMgbG9uZy4gTmVlZCB0byBhZGRcbi8vIGEgb3B0aW1pemVkIGNvZGVwYXRoIGZvciB0aGlzLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmltcG9ydCB7XG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBTb2Z0bWF4QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgY3JlYXRlU29mdG1heFByb2dyYW1JbmZvID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuZGltcztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICBjb25zdCBXRyA9IDY0O1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcbiAgY29uc3QgaXNUcmFuc3Bvc2VSZXF1aXJlZCA9IGF4aXMgPCBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gIGxldCB0cmFuc3Bvc2VkSW5wdXQ6IFRlbnNvclZpZXc7XG4gIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xuXG4gIGlmIChpc1RyYW5zcG9zZVJlcXVpcmVkKSB7XG4gICAgcGVybSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0UmFuayB9LCAoXywgaSkgPT4gaSk7XG4gICAgcGVybVtheGlzXSA9IGlucHV0UmFuayAtIDE7XG4gICAgcGVybVtpbnB1dFJhbmsgLSAxXSA9IGF4aXM7XG5cbiAgICB0cmFuc3Bvc2VkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXQsIHBlcm0pLCB7XG4gICAgICBpbnB1dHM6IFtpbnB1dF0sXG4gICAgICBvdXRwdXRzOiBbLTFdLFxuICAgIH0pWzBdO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9zZWRJbnB1dCA9IGlucHV0O1xuICB9XG5cbiAgY29uc3QgdHJhbnNwb3NlZElucHV0U2hhcGUgPSB0cmFuc3Bvc2VkSW5wdXQuZGltcztcbiAgY29uc3QgY29scyA9IHRyYW5zcG9zZWRJbnB1dFNoYXBlW2lucHV0UmFuayAtIDFdO1xuICBjb25zdCByb3dzID0gb3V0cHV0U2l6ZSAvIGNvbHM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGNvbHMpO1xuICBjb25zdCBwYWNrZWRDb2xzID0gY29scyAvIGNvbXBvbmVudHM7XG5cbiAgY29uc3QgbWF4VmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksIG1heCgke25hbWV9LnosICR7bmFtZX0udykpYDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgIHJldHVybiBgbWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCAke25hbWV9LnopYDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUsIHRyYW5zcG9zZWRJbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSwgdHJhbnNwb3NlZElucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xuICBjb25zdCB0aHJlYWRNYXhEZWNsID1cbiAgICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUodHJhbnNwb3NlZElucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMidcbiAgICAgID8gYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2BcbiAgICAgIDogYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7dmFsdWVUeXBlfSwgJHtXR30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3RocmVhZE1heERlY2x9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnU29mdG1heCcsXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogdHJhbnNwb3NlZElucHV0U2hhcGUsIGRhdGFUeXBlOiB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogcm93cyB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWNrZWRDb2xzIH1dLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBpbnB1dHM6IFt0cmFuc3Bvc2VkSW5wdXRdLFxuICAgICAgb3V0cHV0czogW2lzVHJhbnNwb3NlUmVxdWlyZWQgPyAtMSA6IDBdLFxuICAgIH0sXG4gIClbMF07XG5cbiAgaWYgKGlzVHJhbnNwb3NlUmVxdWlyZWQpIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzdWx0LCBwZXJtKSwge1xuICAgICAgaW5wdXRzOiBbcmVzdWx0XSxcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY3JlYXRlU29mdG1heFByb2dyYW1JbmZvKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IGdldFJlcGVhdHMgPSAocmVwZWF0c1RlbnNvclZpZXc6IFRlbnNvclZpZXcpOiByZWFkb25seSBudW1iZXJbXSA9PlxuICBBcnJheS5mcm9tKHJlcGVhdHNUZW5zb3JWaWV3LmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMiAmJlxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDMyXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EJyk7XG4gIH1cblxuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IGdldFJlcGVhdHMoaW5wdXRzWzFdKTtcblxuICBpZiAocmVwZWF0cy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvcicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtpXSAqIHJlcGVhdHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgc2hhcGU/OiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IHNoYXBlID09IG51bGwgPyBnZXRSZXBlYXRzKGlucHV0c1sxXSkgOiBzaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCByZXBlYXRzKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2lucHV0LmluZGljZXMoLi4uaW5wdXRTaGFwZSl9O1xuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2lucHV0LmluZGljZXNHZXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2RpbV92YWx1ZScpfVxuICAgICAgfVxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKSl9XG4gICAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVGlsZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7cmVwZWF0c31gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRpbGUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVGlsZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzQnJvYWRjYXN0OiBib29sZWFuLFxuICB0eXBlT3V0cHV0OiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9kYXRhJywgdHlwZU91dHB1dCwgZGltc091dHB1dC5sZW5ndGgsIDQpO1xuICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYV9kYXRhJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIDQpO1xuICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYl9kYXRhJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIDQpO1xuICBjb25zdCBjID0gaW5wdXRWYXJpYWJsZSgnY19kYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIDQpO1xuXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGM6IHN0cmluZykgPT4gYHNlbGVjdCgke2J9LCAke2F9LCAke2N9KWA7XG4gIGlmICghaXNCcm9hZGNhc3QpIHtcbiAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgZXhwcmVzc2lvbihhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYV9kYXRhW2luZGV4X2Eke3h9XVtjb21wb25lbnRfYSR7eH1dYDtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJfZGF0YVtpbmRleF9iJHt4fV1bY29tcG9uZW50X2Ike3h9XWA7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgY29uc3QgZXhwcmVzc2lvbkMgPSBgYm9vbChjX2RhdGFbaW5kZXhfYyR7eH1dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7eH0gKiA4KSkpYDtcbiAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke3h9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7eH0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHt4fSA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke3h9ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHt4fSA9IG9mZnNldF9hJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike3h9ID0gb2Zmc2V0X2Ike3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7eH0gPSBvZmZzZXRfYyR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7eH0gPSBvZmZzZXRfYSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7eH0gPSBvZmZzZXRfYiR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7eH0gPSBvZmZzZXRfYyR7eH0gJSA0dTtcbiAgICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZXhwcmVzc2lvbihleHByZXNzaW9uQSwgZXhwcmVzc2lvbkIsIGV4cHJlc3Npb25DKX0pO1xuICAgICAgICAgIGA7XG4gICAgfTtcbiAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAwKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAzKX1cbiAgICAgICAgICBgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhjLCBhLCBiLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGRpbXNBID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IGRpbXNCID0gaW5wdXRzWzJdLmRpbXM7XG4gIGNvbnN0IGRpbXNDID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dERhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuXG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIShTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0EsIGRpbXNCKSAmJiBTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0IsIGRpbXNDKSk7XG4gIGxldCBvdXRwdXRTaGFwZSA9IGRpbXNBO1xuICBsZXQgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGRpbXNBKTtcbiAgLy8gVE9ETzogZGVhbCB3aXRoIHplcm8tc2l6ZWQgdGVuc29ycyAoZWcuIGRpbXM9WzEsMF0pXG5cbiAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZGltc0EsIGRpbXNCLCBmYWxzZSkhLCBkaW1zQywgZmFsc2UpO1xuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICAgIH1cbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZTtcbiAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICB9XG5cbiAgY29uc3QgdmVjU2l6ZSA9IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnV2hlcmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlcihzaGFkZXJIZWxwZXIsIGlucHV0cywgb3V0cHV0U2hhcGUsIGlzQnJvYWRjYXN0LCBvdXRwdXREYXRhVHlwZSksXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB2ZWNTaXplIH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXNDLCBkaW1zQSwgZGltc0IsIG91dHB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgd2hlcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgYXJnTWF4LCBhcmdNaW4sIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2FyZ21pbm1heCc7XG5pbXBvcnQgeyBhdHRlbnRpb24gfSBmcm9tICcuL29wcy9hdHRlbnRpb24nO1xuaW1wb3J0IHsgYmF0Y2hOb3JtIH0gZnJvbSAnLi9vcHMvYmF0Y2gtbm9ybSc7XG5pbXBvcnQgeyBiaWFzQWRkIH0gZnJvbSAnLi9vcHMvYmlhcy1hZGQnO1xuaW1wb3J0IHsgYmlhc1NwbGl0R2VsdSB9IGZyb20gJy4vb3BzL2JpYXMtc3BsaXQtZ2VsdSc7XG5pbXBvcnQgKiBhcyBiaW5hcnlPcHMgZnJvbSAnLi9vcHMvYmluYXJ5LW9wJztcbmltcG9ydCB7IGNvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29uY2F0JztcbmltcG9ydCB7IGNvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb252JztcbmltcG9ydCB7IGNvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb252LXRyYW5zcG9zZSc7XG5pbXBvcnQgeyBjdW1zdW0sIHBhcnNlQ3VtU3VtQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2N1bXN1bSc7XG5pbXBvcnQgeyBkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2RlcHRoLXRvLXNwYWNlJztcbmltcG9ydCB7IGVpbnN1bSwgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZWluc3VtJztcbmltcG9ydCB7IGV4cGFuZCB9IGZyb20gJy4vb3BzL2V4cGFuZCc7XG5pbXBvcnQgeyBmYXN0R2VsdSB9IGZyb20gJy4vb3BzL2Zhc3QtZ2VsdSc7XG5pbXBvcnQgeyBnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlcic7XG5pbXBvcnQgeyBnYXRoZXJCbG9ja1F1YW50aXplZCwgcGFyc2VHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nYXRoZXItYmxvY2stcXVhbnRpemVkJztcbmltcG9ydCB7IGdhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1lbGVtZW50cyc7XG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2VtbSc7XG5pbXBvcnQgeyBncm91cFF1ZXJ5QXR0ZW50aW9uIH0gZnJvbSAnLi9vcHMvZ3JvdXAtcXVlcnktYXR0ZW50aW9uJztcbmltcG9ydCB7IGluc3RhbmNlTm9ybSB9IGZyb20gJy4vb3BzL2luc3RhbmNlLW5vcm0nO1xuaW1wb3J0IHsgbGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvbGF5ZXItbm9ybSc7XG5pbXBvcnQgeyBtYXRNdWwgfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHsgbWF0TXVsTkJpdHMsIHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvbWF0bXVsbmJpdHMnO1xuaW1wb3J0IHsgbXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9tdWx0aWhlYWQtYXR0ZW50aW9uJztcbmltcG9ydCB7IHBhZCB9IGZyb20gJy4vb3BzL3BhZCc7XG5pbXBvcnQgKiBhcyBwb29sIGZyb20gJy4vb3BzL3Bvb2wnO1xuaW1wb3J0IHsgZGVxdWFudGl6ZUxpbmVhciwgcGFyc2VEZXF1YW50aXplTGluZWFyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL3F1YW50aXplLWxpbmVhcic7XG5pbXBvcnQgeyByYW5nZSB9IGZyb20gJy4vb3BzL3JhbmdlJztcbmltcG9ydCB7XG4gIHJlZHVjZUwxLFxuICByZWR1Y2VMMixcbiAgcmVkdWNlTG9nU3VtLFxuICByZWR1Y2VMb2dTdW1FeHAsXG4gIHJlZHVjZU1heCxcbiAgcmVkdWNlTWVhbixcbiAgcmVkdWNlTWluLFxuICByZWR1Y2VQcm9kLFxuICByZWR1Y2VTdW0sXG4gIHJlZHVjZVN1bVNxdWFyZSxcbn0gZnJvbSAnLi9vcHMvcmVkdWNlJztcbmltcG9ydCB7IHBhcnNlUmVzaXplQXR0cmlidXRlcywgcmVzaXplIH0gZnJvbSAnLi9vcHMvcmVzaXplJztcbmltcG9ydCB7IHJvdGFyeUVtYmVkZGluZyB9IGZyb20gJy4vb3BzL3JvdGFyeS1lbWJlZGRpbmcnO1xuaW1wb3J0IHsgc2tpcExheWVyTm9ybSB9IGZyb20gJy4vb3BzL3NraXAtbGF5ZXItbm9ybSc7XG5pbXBvcnQgeyBwYXJzZVNsaWNlQXR0cmlidXRlcywgc2xpY2UgfSBmcm9tICcuL29wcy9zbGljZSc7XG5pbXBvcnQgeyBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzLCBzb2Z0bWF4IH0gZnJvbSAnLi9vcHMvc29mdG1heCc7XG5pbXBvcnQgeyBwYXJzZVNwbGl0QXR0cmlidXRlcywgc3BsaXQgfSBmcm9tICcuL29wcy9zcGxpdCc7XG5pbXBvcnQgeyB0aWxlIH0gZnJvbSAnLi9vcHMvdGlsZSc7XG5pbXBvcnQgeyBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMsIHRyYW5zcG9zZSB9IGZyb20gJy4vb3BzL3RyYW5zcG9zZSc7XG5pbXBvcnQgKiBhcyB1bmFyeU9wcyBmcm9tICcuL29wcy91bmFyeS1vcCc7XG5pbXBvcnQgeyB3aGVyZSB9IGZyb20gJy4vb3BzL3doZXJlJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFJ1bkZ1bmN0aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGU/OiB1bmtub3duKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgUGFyc2VBdHRyaWJ1dGVGdW5jdGlvbiA9IChhdHRyaWJ1dGVSYXc6IHVua25vd24pID0+IHVua25vd247XG5leHBvcnQgdHlwZSBPcGVyYXRvckltcGxlbWVudGF0aW9uID0gW1J1bkZ1bmN0aW9uXSB8IFtSdW5GdW5jdGlvbiwgUGFyc2VBdHRyaWJ1dGVGdW5jdGlvbl07XG5cbmV4cG9ydCBjb25zdCBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUzogTWFwPHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbj4gPSBuZXcgTWFwKFtcbiAgWydBYnMnLCBbdW5hcnlPcHMuYWJzXV0sXG4gIFsnQWNvcycsIFt1bmFyeU9wcy5hY29zXV0sXG4gIFsnQWNvc2gnLCBbdW5hcnlPcHMuYWNvc2hdXSxcbiAgWydBZGQnLCBbYmluYXJ5T3BzLmFkZF1dLFxuICBbJ0FyZ01heCcsIFthcmdNYXgsIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxuICBbJ0FyZ01pbicsIFthcmdNaW4sIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxuICBbJ0FzaW4nLCBbdW5hcnlPcHMuYXNpbl1dLFxuICBbJ0FzaW5oJywgW3VuYXJ5T3BzLmFzaW5oXV0sXG4gIFsnQXRhbicsIFt1bmFyeU9wcy5hdGFuXV0sXG4gIFsnQXRhbmgnLCBbdW5hcnlPcHMuYXRhbmhdXSxcbiAgWydBdHRlbnRpb24nLCBbYXR0ZW50aW9uXV0sXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXG4gIFsnQXZlcmFnZVBvb2wnLCBbcG9vbC5hdmVyYWdlUG9vbCwgcG9vbC5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsIFtiYXRjaE5vcm1dXSxcbiAgWydCaWFzQWRkJywgW2JpYXNBZGRdXSxcbiAgWydCaWFzU3BsaXRHZWx1JywgW2JpYXNTcGxpdEdlbHVdXSxcbiAgWydDYXN0JywgW3VuYXJ5T3BzLmNhc3QsIHVuYXJ5T3BzLnBhcnNlQ2FzdEF0dHJpYnV0ZXNdXSxcbiAgWydDZWlsJywgW3VuYXJ5T3BzLmNlaWxdXSxcbiAgWydDbGlwJywgW3VuYXJ5T3BzLmNsaXBdXSxcbiAgWydDb25jYXQnLCBbY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXNdXSxcbiAgWydDb252JywgW2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdXSxcbiAgWydDb252VHJhbnNwb3NlJywgW2NvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXNdXSxcbiAgWydDb3MnLCBbdW5hcnlPcHMuY29zXV0sXG4gIFsnQ29zaCcsIFt1bmFyeU9wcy5jb3NoXV0sXG4gIFsnQ3VtU3VtJywgW2N1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzXV0sXG4gIFsnRGVwdGhUb1NwYWNlJywgW2RlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXV0sXG4gIFsnRGVxdWFudGl6ZUxpbmVhcicsIFtkZXF1YW50aXplTGluZWFyLCBwYXJzZURlcXVhbnRpemVMaW5lYXJBdHRyaWJ1dGVzXV0sXG4gIFsnRGl2JywgW2JpbmFyeU9wcy5kaXZdXSxcbiAgWydFaW5zdW0nLCBbZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXNdXSxcbiAgWydFbHUnLCBbdW5hcnlPcHMuZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ0VxdWFsJywgW2JpbmFyeU9wcy5lcXVhbF1dLFxuICBbJ0VyZicsIFt1bmFyeU9wcy5lcmZdXSxcbiAgWydFeHAnLCBbdW5hcnlPcHMuZXhwXV0sXG4gIFsnRXhwYW5kJywgW2V4cGFuZF1dLFxuICBbJ0Zhc3RHZWx1JywgW2Zhc3RHZWx1XV0sXG4gIFsnRmxvb3InLCBbdW5hcnlPcHMuZmxvb3JdXSxcbiAgWydGdXNlZENvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0dhdGhlcicsIFtnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlc11dLFxuICBbJ0dhdGhlckVsZW1lbnRzJywgW2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc11dLFxuICBbJ0dhdGhlckJsb2NrUXVhbnRpemVkJywgW2dhdGhlckJsb2NrUXVhbnRpemVkLCBwYXJzZUdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlc11dLFxuICBbJ0dlbHUnLCBbdW5hcnlPcHMuZ2VsdV1dLFxuICBbJ0dlbW0nLCBbZ2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgW3Bvb2wuZ2xvYmFsQXZlcmFnZVBvb2wsIHBvb2wucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHbG9iYWxNYXhQb29sJywgW3Bvb2wuZ2xvYmFsTWF4UG9vbCwgcG9vbC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnR3JlYXRlcicsIFtiaW5hcnlPcHMuZ3JlYXRlcl1dLFxuICBbJ0dyZWF0ZXJPckVxdWFsJywgW2JpbmFyeU9wcy5ncmVhdGVyT3JFcXVhbF1dLFxuICBbJ0dyb3VwUXVlcnlBdHRlbnRpb24nLCBbZ3JvdXBRdWVyeUF0dGVudGlvbl1dLFxuICBbJ0hhcmRTaWdtb2lkJywgW3VuYXJ5T3BzLmhhcmRTaWdtb2lkLCB1bmFyeU9wcy5wYXJzZUhhcmRTaWdtb2lkQXR0cmlidXRlc11dLFxuICBbJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsIFtpbnN0YW5jZU5vcm1dXSxcbiAgWydMYXllck5vcm1hbGl6YXRpb24nLCBbbGF5ZXJOb3JtXV0sXG4gIFsnTGVha3lSZWx1JywgW3VuYXJ5T3BzLmxlYWt5UmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydMZXNzJywgW2JpbmFyeU9wcy5sZXNzXV0sXG4gIFsnTGVzc09yRXF1YWwnLCBbYmluYXJ5T3BzLmxlc3NPckVxdWFsXV0sXG4gIFsnTG9nJywgW3VuYXJ5T3BzLmxvZ11dLFxuICBbJ01hdE11bCcsIFttYXRNdWxdXSxcbiAgWydNYXRNdWxOQml0cycsIFttYXRNdWxOQml0cywgcGFyc2VNYXRNdWxOQml0c0F0dHJpYnV0ZXNdXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTWF4UG9vbCcsIFtwb29sLm1heFBvb2wsIHBvb2wucGFyc2VNYXhQb29sQXR0cmlidXRlc11dLFxuICBbJ011bCcsIFtiaW5hcnlPcHMubXVsXV0sXG4gIFsnTXVsdGlIZWFkQXR0ZW50aW9uJywgW211bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzXV0sXG4gIFsnTmVnJywgW3VuYXJ5T3BzLm5lZ11dLFxuICBbJ05vdCcsIFt1bmFyeU9wcy5ub3RdXSxcbiAgWydQYWQnLCBbcGFkXV0sXG4gIFsnUG93JywgW2JpbmFyeU9wcy5wb3ddXSxcbiAgWydRdWlja0dlbHUnLCBbdW5hcnlPcHMucXVpY2tnZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ1JhbmdlJywgW3JhbmdlXV0sXG4gIFsnUmVjaXByb2NhbCcsIFt1bmFyeU9wcy5yZWNpcHJvY2FsXV0sXG4gIFsnUmVkdWNlTWluJywgW3JlZHVjZU1pbl1dLFxuICBbJ1JlZHVjZU1lYW4nLCBbcmVkdWNlTWVhbl1dLFxuICBbJ1JlZHVjZU1heCcsIFtyZWR1Y2VNYXhdXSxcbiAgWydSZWR1Y2VTdW0nLCBbcmVkdWNlU3VtXV0sXG4gIFsnUmVkdWNlUHJvZCcsIFtyZWR1Y2VQcm9kXV0sXG4gIFsnUmVkdWNlTDEnLCBbcmVkdWNlTDFdXSxcbiAgWydSZWR1Y2VMMicsIFtyZWR1Y2VMMl1dLFxuICBbJ1JlZHVjZUxvZ1N1bScsIFtyZWR1Y2VMb2dTdW1dXSxcbiAgWydSZWR1Y2VMb2dTdW1FeHAnLCBbcmVkdWNlTG9nU3VtRXhwXV0sXG4gIFsnUmVkdWNlU3VtU3F1YXJlJywgW3JlZHVjZVN1bVNxdWFyZV1dLFxuICBbJ1JlbHUnLCBbdW5hcnlPcHMucmVsdV1dLFxuICBbJ1Jlc2l6ZScsIFtyZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc11dLFxuICBbJ1JvdGFyeUVtYmVkZGluZycsIFtyb3RhcnlFbWJlZGRpbmddXSxcbiAgWydTaWdtb2lkJywgW3VuYXJ5T3BzLnNpZ21vaWRdXSxcbiAgWydTaW4nLCBbdW5hcnlPcHMuc2luXV0sXG4gIFsnU2luaCcsIFt1bmFyeU9wcy5zaW5oXV0sXG4gIFsnU2xpY2UnLCBbc2xpY2UsIHBhcnNlU2xpY2VBdHRyaWJ1dGVzXV0sXG4gIFsnU2tpcExheWVyTm9ybWFsaXphdGlvbicsIFtza2lwTGF5ZXJOb3JtXV0sXG4gIFsnU3BsaXQnLCBbc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXV0sXG4gIFsnU3FydCcsIFt1bmFyeU9wcy5zcXJ0XV0sXG4gIFsnU29mdG1heCcsIFtzb2Z0bWF4LCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzXV0sXG4gIFsnU3ViJywgW2JpbmFyeU9wcy5zdWJdXSxcbiAgWydUYW4nLCBbdW5hcnlPcHMudGFuXV0sXG4gIFsnVGFuaCcsIFt1bmFyeU9wcy50YW5oXV0sXG4gIFsnVGhyZXNob2xkZWRSZWx1JywgW3VuYXJ5T3BzLnRocmVzaG9sZGVkUmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydUaWxlJywgW3RpbGVdXSxcbiAgWydUcmFuc3Bvc2UnLCBbdHJhbnNwb3NlLCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdXSxcbiAgWydXaGVyZScsIFt3aGVyZV1dLFxuXSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgV2ViR3B1QmFja2VuZCB9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uL2xvZyc7XG5cbmltcG9ydCB7IGNyZWF0ZVNoYWRlckhlbHBlciB9IGZyb20gJy4vb3BzL2NvbW1vbic7XG5pbXBvcnQgeyBBcnRpZmFjdCwgR3B1RGF0YSwgUHJvZ3JhbUluZm8gfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBQcm9ncmFtTWFuYWdlciBpcyB0aGUgbWFpbiBjbGFzcyBiZWhpbmQgcnVubmluZyBjb21wdXRhdGlvbnNcbiAqIEl0IGJ1aWxkcyBQcm9ncmFtSW5mbydzIGludG8gQXJ0aWZhY3RzXG4gKiBJdCBjb21waWxlcyBnaXZlbiBQcm9ncmFtSW5mbydzIGludG8gV2ViR0wgUHJvcmFtcyAoY2FjaGVkIGFzIEFydGlmYWN0cylcbiAqIFVzZXMgdGhlIGFydGlmYWN0IHRvIHJ1biB0aGUgY29tcHV0YXRpb24gYnkgY2FsbGluZyBEcmF3IG9uXG4gKiB0aGUgV2ViR0wgZHJhd2luZyBidWZmZXJcbiAqIFByb2dyYW1NYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbWFwcyAoYmluZHMpIGlucHV0IHZhcmlhYmxlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBMb2NhdGlvbidzIGluIHRoZSBiaW5hcnkgcHJvZ3JhbVxuICovXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xuICByZXBvOiBNYXA8dW5rbm93biwgQXJ0aWZhY3Q+OyAvLyB0aGlzIHNob3VsZCBiZSBwZXItc2Vzc2lvbiBvYmplY3RcbiAgYXR0cmlidXRlc0JvdW5kOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMucmVwbyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IGZhbHNlO1xuICB9XG4gIGdldEFydGlmYWN0KGtleTogdW5rbm93bik6IEFydGlmYWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvLmdldChrZXkpO1xuICB9XG4gIHNldEFydGlmYWN0KGtleTogdW5rbm93biwgYXJ0aWZhY3Q6IEFydGlmYWN0KTogdm9pZCB7XG4gICAgdGhpcy5yZXBvLnNldChrZXksIGFydGlmYWN0KTtcbiAgfVxuICBydW4oXG4gICAgYnVpbGRBcnRpZmFjdDogQXJ0aWZhY3QsXG4gICAgaW5wdXRzOiBHcHVEYXRhW10sXG4gICAgb3V0cHV0czogR3B1RGF0YVtdLFxuICAgIGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICB1bmlmb3JtQnVmZmVyQmluZGluZzogR1BVQmluZGluZ1Jlc291cmNlIHwgdW5kZWZpbmVkLFxuICApOiB2b2lkIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBjb21wdXRlUGFzc0VuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IGlucHV0LmJ1ZmZlciB9IH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHsgYnVmZmVyOiBvdXRwdXQuYnVmZmVyIH0gfSk7XG4gICAgfVxuICAgIGlmICh1bmlmb3JtQnVmZmVyQmluZGluZykge1xuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB1bmlmb3JtQnVmZmVyQmluZGluZyB9KTtcbiAgICB9XG4gICAgY29uc3QgYmluZEdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICBsYXlvdXQ6IGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxcbiAgICAgIGVudHJpZXMsXG4gICAgICBsYWJlbDogYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xuICAgICAgY29uc3QgY29tbWFuZEluZm8gPSB7XG4gICAgICAgIGtlcm5lbElkOiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbElkISxcbiAgICAgICAgY29tcHV0ZVBpcGVsaW5lOiBidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSxcbiAgICAgICAgYmluZEdyb3VwLFxuICAgICAgICBkaXNwYXRjaEdyb3VwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgc2Vzc2lvbkNvbW1hbmRMaXN0IS5wdXNoKGNvbW1hbmRJbmZvKTtcbiAgICB9XG5cbiAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUpO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgYmluZEdyb3VwKTtcbiAgICBjb21wdXRlUGFzc0VuY29kZXIuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmRpc3BhdGNoR3JvdXApO1xuICAgIHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEpO1xuICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKztcblxuICAgIGlmIChcbiAgICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyIHx8XG4gICAgICB0aGlzLmJhY2tlbmQucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJ1xuICAgICkge1xuICAgICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcikge1xuICAgICAgdGhpcy5iYWNrZW5kLmZsdXNoKCk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyB0aGlzLnJlcG8uZm9yRWFjaChhID0+IHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oYS5wcm9ncmFtKSk7XG4gIH1cbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IEFydGlmYWN0IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW1JbmZvLm5hbWUpO1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XG4gICAgY29uc3QgZXh0ZW5zaW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoZGV2aWNlLmZlYXR1cmVzLmhhcygnc2hhZGVyLWYxNicpKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goJ2VuYWJsZSBmMTY7Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlckhlbHBlciA9IGNyZWF0ZVNoYWRlckhlbHBlcihub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemUsIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKTtcbiAgICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW1JbmZvLmdldFNoYWRlclNvdXJjZShzaGFkZXJIZWxwZXIpO1xuICAgIGNvbnN0IGNvZGUgPSBgJHtleHRlbnNpb25zLmpvaW4oJ1xcbicpfVxcbiR7c2hhZGVySGVscGVyLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XFxuJHt1c2VyQ29kZX1gO1xuICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBjb2RlLCBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZSB9KTtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gJHtwcm9ncmFtSW5mby5uYW1lfSBzaGFkZXIgY29kZTogJHtjb2RlfWApO1xuXG4gICAgY29uc3QgY29tcHV0ZVBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XG4gICAgICBjb21wdXRlOiB7IG1vZHVsZTogc2hhZGVyTW9kdWxlLCBlbnRyeVBvaW50OiAnbWFpbicgfSxcbiAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgbGFiZWw6IHByb2dyYW1JbmZvLm5hbWUsXG4gICAgfSk7XG5cbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtSW5mby5uYW1lKTtcbiAgICByZXR1cm4geyBwcm9ncmFtSW5mbywgY29tcHV0ZVBpcGVsaW5lLCB1bmlmb3JtVmFyaWFibGVzSW5mbzogc2hhZGVySGVscGVyLnZhcmlhYmxlc0luZm8gfTtcbiAgfVxuXG4gIG5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKFxuICAgIGRpc3BhdGNoR3JvdXA6IFJldHVyblR5cGU8UHJvZ3JhbUluZm9bJ2dldFJ1bkRhdGEnXT5bJ2Rpc3BhdGNoR3JvdXAnXSxcbiAgKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB4ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gZGlzcGF0Y2hHcm91cCA6IGRpc3BhdGNoR3JvdXAueDtcbiAgICBjb25zdCB5ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gMSA6IGRpc3BhdGNoR3JvdXAueSB8fCAxO1xuICAgIGNvbnN0IHogPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogZGlzcGF0Y2hHcm91cC56IHx8IDE7XG4gICAgY29uc3QgbGltaXRQZXJEaW1lbnNpb24gPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtcbiAgICBpZiAoeCA8PSBsaW1pdFBlckRpbWVuc2lvbiAmJiB5IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHogPD0gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB4ICogeSAqIHo7XG4gICAgbGV0IGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xuICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgZGlzcGF0Y2hBdmVyYWdlID0gTWF0aC5jZWlsKE1hdGguY2JydChzaXplKSk7XG4gICAgICBpZiAoZGlzcGF0Y2hBdmVyYWdlID4gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2Rpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2Rpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlLCAxXTtcbiAgICB9XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52LCBUZW5zb3IsIFRSQUNFLCBUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORCB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlLCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuaW1wb3J0IHsgY29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgeyBjcmVhdGVWaWV3LCBUZW5zb3JWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBjcmVhdGVHcHVEYXRhTWFuYWdlciwgZG93bmxvYWRHcHVEYXRhLCBHcHVEYXRhTWFuYWdlciB9IGZyb20gJy4vd2ViZ3B1L2dwdS1kYXRhLW1hbmFnZXInO1xuaW1wb3J0IHsgUnVuRnVuY3Rpb24sIFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTIH0gZnJvbSAnLi93ZWJncHUvb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQgeyBQcm9ncmFtTWFuYWdlciB9IGZyb20gJy4vd2ViZ3B1L3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge1xuICBBZGFwdGVySW5mbyxcbiAgQ29tcHV0ZUNvbnRleHQsXG4gIEdwdUFyY2hpdGVjdHVyZSxcbiAgR3B1RGF0YSxcbiAgR3B1VmVuZG9yLFxuICBQcm9ncmFtSW5mbyxcbiAgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksXG4gIFNlc3Npb25TdGF0ZSxcbiAgVGltZXN0YW1wUXVlcnksXG59IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcblxuaW50ZXJmYWNlIENvbW1hbmRJbmZvIHtcbiAgcmVhZG9ubHkga2VybmVsSWQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgY29tcHV0ZVBpcGVsaW5lOiBHUFVDb21wdXRlUGlwZWxpbmU7XG4gIHJlYWRvbmx5IGJpbmRHcm91cDogR1BVQmluZEdyb3VwO1xuICByZWFkb25seSBkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59XG5cbmludGVyZmFjZSBLZXJuZWxJbmZvIHtcbiAgcmVhZG9ubHkga2VybmVsVHlwZTogc3RyaW5nO1xuICByZWFkb25seSBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGtlcm5lbEVudHJ5OiBSdW5GdW5jdGlvbjtcbiAgcmVhZG9ubHkgYXR0cmlidXRlczogWygoYXR0cmlidXRlOiB1bmtub3duKSA9PiB1bmtub3duKSB8IHVuZGVmaW5lZCwgdW5rbm93bl07XG59XG5cbmludGVyZmFjZSBQZW5kaW5nS2VybmVsSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XG4gIHJlYWRvbmx5IHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbiAgcmVhZG9ubHkgb3V0cHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbn1cblxuY29uc3QgZ2V0UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lLZXkgPSAoXG4gIGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBpbnB1dERlcGVuZGVuY2llczogcmVhZG9ubHkgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSxcbik6IHN0cmluZyA9PiB7XG4gIGlmIChpbnB1dERlcGVuZGVuY2llcy5sZW5ndGggIT09IGlucHV0VGVuc29ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7aW5wdXREZXBlbmRlbmNpZXMubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke1xuICAgICAgICBpbnB1dFRlbnNvcnMubGVuZ3RoXG4gICAgICB9LmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0SW5mb3M6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdHlwZSA9IGlucHV0VGVuc29yc1tpXS5kYXRhVHlwZTtcbiAgICBzd2l0Y2ggKGlucHV0RGVwZW5kZW5jaWVzW2ldKSB7XG4gICAgICBjYXNlICdub25lJzoge1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3R5cGUnOiB7XG4gICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3JhbmsnOiB7XG4gICAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5sZW5ndGg7XG4gICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfTske3Jhbmt9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZGltcyc6IHtcbiAgICAgICAgY29uc3QgZGltcyA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmpvaW4oJywnKTtcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9OyR7ZGltc31gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7aW5wdXREZXBlbmRlbmNpZXNbaV19YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlucHV0SW5mb3Muam9pbignfCcpO1xufTtcblxuLyoqXG4gKiBnZXQgYSB1bmlxdWUga2V5IHJlcHJlc2VudGluZyB0aGUgcHJvZ3JhbSBmcm9tIHRoZSBwcm9ncmFtIGluZm8sIGlucHV0IHNoYXBlcyBhbmQgdHlwZXMuXG4gKlxuICogQHJldHVybnMgYSB1bmlxdWUga2V5IGlzIGEgc2hvcnRlciBzdHJpbmcgdGhhbiB0aGUgc2hhZGVyIHNvdXJjZSwgd2hpY2ggY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0byBpZGVudGlmeSBhXG4gKiBwcm9ncmFtLiBpZiB0aGUga2V5IGlzIHRoZSBzYW1lLCB0aGUgcHJvZ3JhbSBzaGFkZXIgc291cmNlIHNob3VsZCBiZSB0aGUgc2FtZSwgc28gd2UgY2FuIHJldXNlIHRoZSBwcm9ncmFtLlxuICpcbiAqL1xuY29uc3QgZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkgPSAoXG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbyxcbiAgaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGlzMURpbWVuc2lvbkRpc3BhdGNoOiBib29sZWFuLFxuKTogc3RyaW5nID0+IHtcbiAgLy8gZmluYWwga2V5IGZvcm1hdDpcbiAgLy8gPFBST0dSQU1fTkFNRT5bPFBST0dSQU1fQ1VTVE9NX0NBQ0hFX0hJTlQ+XTppczFEaW1lbnNpb25EaXNwYXRjaDo8SU5QVVRTX0lORk9fMD58PElOUFVUU19JTkZPXzE+fC4uLlxuICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgaWYgKHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5oaW50KSB7XG4gICAga2V5ICs9ICdbJyArIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlLmhpbnQgKyAnXSc7XG4gIH1cbiAga2V5ICs9XG4gICAgJzonICtcbiAgICBpczFEaW1lbnNpb25EaXNwYXRjaCArXG4gICAgYDoke2dldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5KFxuICAgICAgaW5wdXRUZW5zb3JzLFxuICAgICAgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzID8/XG4gICAgICAgIG5ldyBBcnJheTxQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeT4oaW5wdXRUZW5zb3JzLmxlbmd0aCkuZmlsbCgnZGltcycpLFxuICAgICl9YDtcbiAgcmV0dXJuIGtleTtcbn07XG5cbmNsYXNzIEFkYXB0ZXJJbmZvSW1wbCBpbXBsZW1lbnRzIEFkYXB0ZXJJbmZvIHtcbiAgcmVhZG9ubHkgYXJjaGl0ZWN0dXJlPzogc3RyaW5nO1xuICByZWFkb25seSB2ZW5kb3I/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlckluZm86IEdQVUFkYXB0ZXJJbmZvKSB7XG4gICAgaWYgKGFkYXB0ZXJJbmZvKSB7XG4gICAgICB0aGlzLmFyY2hpdGVjdHVyZSA9IGFkYXB0ZXJJbmZvLmFyY2hpdGVjdHVyZTtcbiAgICAgIHRoaXMudmVuZG9yID0gYWRhcHRlckluZm8udmVuZG9yO1xuICAgIH1cbiAgfVxuXG4gIGlzQXJjaGl0ZWN0dXJlKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlID09PSBhcmNoaXRlY3R1cmU7XG4gIH1cblxuICBpc1ZlbmRvcih2ZW5kb3I6IEdwdVZlbmRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZlbmRvciA9PT0gdmVuZG9yO1xuICB9XG59XG5cbi8qKlxuICogdGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBzdG9yZSBzdGF0dXMgYW5kIGJlaW5nIHVzZWQgYXMgYSBzaW5nbGV0b24gZm9yIEpTRVAuIEl0IHdpbGwgYmUgcGFzc2VkIHRvIGpzZXBJbml0KCkgYXNcbiAqIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc28gdGhhdCBpdCBpcyBzdG9yZWQgZm9yIGZ1dHVyZSB1c2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHcHVCYWNrZW5kIHtcbiAgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvSW1wbDtcbiAgZGV2aWNlOiBHUFVEZXZpY2U7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBHcHVEYXRhTWFuYWdlciB0byBtYW5hZ2UgYSBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyIG1hcHBpbmdcbiAgICovXG4gIGdwdURhdGFNYW5hZ2VyOiBHcHVEYXRhTWFuYWdlcjtcbiAgLyoqXG4gICAqIGFuIGluc3RhbmNlIG9mIFByb2dyYW1NYW5hZ2VyIHRvIGJ1aWxkIGFuZCBydW4gV2ViR1BVIGNvbXB1dGUgc2hhZGVyIHByb2dyYW0sIGFuZCBtYW5hZ2UgYSBQcm9ncmFtS2V5IC0+IFByb2dyYW1cbiAgICogYXJ0aWZhY3RzIG1hcHBpbmdcbiAgICovXG4gIHByb2dyYW1NYW5hZ2VyOiBQcm9ncmFtTWFuYWdlcjtcblxuICAvKipcbiAgICogcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBydW4uXG4gICAqIGBudWxsYCBtZWFucyBubyBzZXNzaW9uIGlzIGJlaW5nIHJ1bi5cbiAgICogb25seSB2YWxpZCB3aGVuIHNlc3Npb24ucnVuIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgY3VycmVudFNlc3Npb25JZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudGluZyB0aGUga2VybmVsIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBjb21wdXRlZCAoQ1BVIGNvZGUgcGVyc3BlY3RpdmUpLlxuICAgKiBgbnVsbGAgbWVhbnMgbm8ga2VybmVsIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgKiBvbmx5IG9uZSBrZXJuZWwgY2FuIGJlIGNvbXB1dGVkIGF0IGEgbW9tZW50LlxuICAgKi9cbiAgY3VycmVudEtlcm5lbElkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgLyoqXG4gICAqIGEgbGlzdCBvZiB0ZW1wb3JhcnkgR1BVIGRhdGEgZm9yIHRoZSBjdXJyZW50IGtlcm5lbC4gc2hvdWxkIHJlbGVhc2Ugd2hlbiB0aGUga2VybmVsIGRvbmUgY29tcHV0YXRpb24uXG4gICAqL1xuICBwcml2YXRlIHRlbXBvcmFyeURhdGE6IEdwdURhdGFbXTtcbiAgLyoqXG4gICAqIGEgS2VybmVsSUQgLT4gYSBHUFUgZGF0YSBsaXN0LCB3aGljaCBzdG9yZXMgcGVyc2lzdGVudCBHUFUgZGF0YSBvd25lZCBieSB0aGUgc3BlY2lmaWMga2VybmVsLlxuICAgKi9cbiAgcHJpdmF0ZSBrZXJuZWxQZXJzaXN0ZW50RGF0YTogTWFwPG51bWJlciwgR3B1RGF0YVtdPjtcbiAgLyoqXG4gICAqIGEgS2VybmVsSUQgLT4gYSBjdXN0b20gZGF0YSwgd2hpY2ggc3RvcmVzIGN1c3RvbSBkYXRhIG93bmVkIGJ5IHRoZSBzcGVjaWZpYyBrZXJuZWwuXG4gICAqL1xuICBwcml2YXRlIGtlcm5lbEN1c3RvbURhdGE6IE1hcDxudW1iZXIsIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9PjtcbiAgLyoqXG4gICAqIGdldCB0aGUgY3VzdG9tIGRhdGEgb2YgdGhlIGN1cnJlbnQga2VybmVsXG4gICAqL1xuICBnZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRLZXJuZWxJZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKScpO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gdGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIEtlcm5lbElEIC0+IGtlcm5lbEluZm8gbWFwcGluZ1xuICBrZXJuZWxzOiBNYXA8bnVtYmVyLCBLZXJuZWxJbmZvPjtcbiAgcHJpdmF0ZSBjb21tYW5kRW5jb2RlcjogR1BVQ29tbWFuZEVuY29kZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjb21wdXRlUGFzc0VuY29kZXI6IEdQVUNvbXB1dGVQYXNzRW5jb2RlciB8IG51bGwgPSBudWxsO1xuICBtYXhEaXNwYXRjaE51bWJlciA9IDE2O1xuICBwZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPSAwO1xuXG4gIC8vIGluZm8gb2Yga2VybmVscyBwZW5kaW5nIHN1Ym1pc3Npb24gZm9yIGEgc2luZ2xlIGJhdGNoXG4gIHByaXZhdGUgcGVuZGluZ0tlcm5lbHM6IFBlbmRpbmdLZXJuZWxJbmZvW10gPSBbXTtcbiAgLy8gcXVlcnlSZWFkQnVmZmVyIC0+IHBlbmRpbmdLZXJuZWxzIG1hcHBpbmcgZm9yIGFsbCB0aGUgYmF0Y2hlc1xuICBwcml2YXRlIHBlbmRpbmdRdWVyaWVzOiBNYXA8R1BVQnVmZmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBxdWVyeVJlc29sdmVCdWZmZXI/OiBHUFVCdWZmZXI7XG4gIHByaXZhdGUgcXVlcnlTZXQ/OiBHUFVRdWVyeVNldDtcbiAgcHJpdmF0ZSBxdWVyeVRpbWVCYXNlPzogYmlnaW50O1xuICBxdWVyeVR5cGU6IFRpbWVzdGFtcFF1ZXJ5O1xuXG4gIGVudjogRW52O1xuICBzZXNzaW9uU3RhdHVzOiBTZXNzaW9uU3RhdGUgPSAnZGVmYXVsdCc7XG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBDb21tYW5kSW5mb1tdIG1hcHBpbmcuIEl0J3MgdXNlZCB0byByZWNvcmQgYWxsIEdQVSBjb21tYW5kcyBmb3IgY29ycmVzcG9uZGluZyBzZXNzaW9uLlxuICAgKi9cbiAgY2FwdHVyZWRDb21tYW5kTGlzdDogTWFwPG51bWJlciwgQ29tbWFuZEluZm9bXT4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IFBlbmRpbmdLZXJuZWxJbmZvW10gbWFwcGluZyBmb3IgcHJvZmlsaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdLZXJuZWxzOiBNYXA8bnVtYmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gYSBNYXAgb2YgKElucHV0T3V0cHV0SW5kZXggLT4gW0lELCBHUFVCdWZmZXJdKSBtYXBwaW5nLlxuICAgKi9cbiAgc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFtudW1iZXIsIEdQVUJ1ZmZlcl0+PiA9IG5ldyBNYXAoKTtcblxuICBhc3luYyBpbml0aWFsaXplKGVudjogRW52LCBhZGFwdGVyOiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgY29uc3QgcmVxdWlyZWRGZWF0dXJlczogR1BVRmVhdHVyZU5hbWVbXSA9IFtdO1xuICAgIGNvbnN0IGRldmljZURlc2NyaXB0b3I6IEdQVURldmljZURlc2NyaXB0b3IgPSB7XG4gICAgICByZXF1aXJlZExpbWl0czoge1xuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLFxuICAgICAgICBtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6IGFkYXB0ZXIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxcbiAgICAgICAgbWF4QnVmZmVyU2l6ZTogYWRhcHRlci5saW1pdHMubWF4QnVmZmVyU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVosXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWRGZWF0dXJlcyxcbiAgICB9O1xuXG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnIGFzIEdQVUZlYXR1cmVOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCd0aW1lc3RhbXAtcXVlcnknKTtcbiAgICB9XG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdzaGFkZXItZjE2JykpIHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMucHVzaCgnc2hhZGVyLWYxNicpO1xuICAgIH1cblxuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKGRldmljZURlc2NyaXB0b3IpO1xuICAgIHRoaXMuYWRhcHRlckluZm8gPSBuZXcgQWRhcHRlckluZm9JbXBsKGFkYXB0ZXIuaW5mbyB8fCAoYXdhaXQgYWRhcHRlci5yZXF1ZXN0QWRhcHRlckluZm8oKSkpO1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIgPSBjcmVhdGVHcHVEYXRhTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMua2VybmVscyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YSA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCB1cCBmbGFncyBmb3IgbG9nZ2VyXG4gICAgY29uZmlndXJlTG9nZ2VyKGVudi5sb2dMZXZlbCEsICEhZW52LmRlYnVnKTtcblxuICAgIC8vIFRPRE86IHNldCB1cCBmbGFnc1xuXG4gICAgdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgIGlmIChldi5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2V2LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsICdkZXZpY2UnLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kZXZpY2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LCAnYWRhcHRlcicsIHtcbiAgICAgIHZhbHVlOiBhZGFwdGVyLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG5cbiAgICAvLyBpbml0IHF1ZXJ5VHlwZSwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZVxuICAgIHRoaXMuc2V0UXVlcnlUeXBlKCk7XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeVNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucXVlcnlTZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGdldENvbW1hbmRFbmNvZGVyKCk6IEdQVUNvbW1hbmRFbmNvZGVyIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21tYW5kRW5jb2RlcjtcbiAgfVxuXG4gIGdldENvbXB1dGVQYXNzRW5jb2RlcigpOiBHUFVDb21wdXRlUGFzc0VuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NEZXNjcmlwdG9yOiBHUFVDb21wdXRlUGFzc0Rlc2NyaXB0b3IgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJykge1xuICAgICAgICBjb21wdXRlUGFzc0Rlc2NyaXB0b3IudGltZXN0YW1wV3JpdGVzID0ge1xuICAgICAgICAgIHF1ZXJ5U2V0OiB0aGlzLnF1ZXJ5U2V0ISxcbiAgICAgICAgICBiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIsXG4gICAgICAgICAgZW5kT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpbkNvbXB1dGVQYXNzKGNvbXB1dGVQYXNzRGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlcjtcbiAgfVxuXG4gIGVuZENvbXB1dGVQYXNzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCk7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZmx1c2goKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbW1hbmRFbmNvZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuXG4gICAgdGhpcy5lbmRDb21wdXRlUGFzcygpO1xuICAgIGxldCBxdWVyeVJlYWRCdWZmZXI6IEdQVUJ1ZmZlcjtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQoXG4gICAgICAgIHRoaXMucXVlcnlTZXQhLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIsXG4gICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISxcbiAgICAgICAgMCxcbiAgICAgICk7XG5cbiAgICAgIHF1ZXJ5UmVhZEJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeyBzaXplOiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB9LFxuICAgICAgKTtcblxuICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQocXVlcnlSZWFkQnVmZmVyLCB0aGlzLnBlbmRpbmdLZXJuZWxzKTtcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciEsXG4gICAgICAgIDAsXG4gICAgICAgIHF1ZXJ5UmVhZEJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICogOCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTtcbiAgICB0aGlzLmNvbW1hbmRFbmNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA9IDA7XG5cbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgdm9pZCBxdWVyeVJlYWRCdWZmZXIhLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZERhdGEgPSBuZXcgQmlnVWludDY0QXJyYXkocXVlcnlSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xuICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVscyA9IHRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHF1ZXJ5UmVhZEJ1ZmZlcikhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZERhdGEubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm8gPSBwZW5kaW5nS2VybmVsc1tpXTtcbiAgICAgICAgICBjb25zdCBrZXJuZWxJZCA9IHBlbmRpbmdLZXJuZWxJbmZvLmtlcm5lbElkO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbEluZm8gPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICAgICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbEluZm8ua2VybmVsVHlwZTtcbiAgICAgICAgICBjb25zdCBrZXJuZWxOYW1lID0ga2VybmVsSW5mby5rZXJuZWxOYW1lO1xuICAgICAgICAgIGNvbnN0IHByb2dyYW1OYW1lID0gcGVuZGluZ0tlcm5lbEluZm8ucHJvZ3JhbU5hbWU7XG4gICAgICAgICAgY29uc3QgaW5wdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLmlucHV0VGVuc29yVmlld3M7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3MgPSBwZW5kaW5nS2VybmVsSW5mby5vdXRwdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyXTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lVTY0ID0gbWFwcGVkRGF0YVtpICogMiArIDFdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5VGltZUJhc2UgPSBzdGFydFRpbWVVNjQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gTnVtYmVyKHN0YXJ0VGltZVU2NCAtIHRoaXMucXVlcnlUaW1lQmFzZSk7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IE51bWJlcihlbmRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcblxuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc3RhcnRUaW1lKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZW5kVGltZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe1xuICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICBpbnB1dHNNZXRhZGF0YTogaW5wdXRUZW5zb3JWaWV3cy5tYXAoKHZhbHVlKSA9PiAoe1xuICAgICAgICAgICAgICAgIGRpbXM6IHZhbHVlLmRpbXMsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKSxcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICBvdXRwdXRzTWV0YWRhdGE6IG91dHB1dFRlbnNvclZpZXdzLm1hcCgodmFsdWUpID0+ICh7XG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIGtlcm5lbElkLFxuICAgICAgICAgICAgICBrZXJuZWxUeXBlLFxuICAgICAgICAgICAgICBrZXJuZWxOYW1lLFxuICAgICAgICAgICAgICBwcm9ncmFtTmFtZSxcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCBwcmludCB0aGUgcHJvZmlsaW5nIG1lc3NhZ2UgdG8gY29uc29sZVxuICAgICAgICAgICAgbGV0IGlucHV0U2hhcGVzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGlucHV0U2hhcGVzICs9IGBpbnB1dFske2l9XTogWyR7dmFsdWUuZGltc31dIHwgJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9LCBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0U2hhcGVzID0gJyc7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JWaWV3cy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBvdXRwdXRTaGFwZXMgKz0gYG91dHB1dFske2l9XTogWyR7dmFsdWUuZGltc31dIHwgJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9LCBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2tlcm5lbElkfXwke2tlcm5lbFR5cGV9fCR7a2VybmVsTmFtZX18JHtwcm9ncmFtTmFtZX1cIiAke2lucHV0U2hhcGVzfSR7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVzXG4gICAgICAgICAgICAgIH1leGVjdXRpb24gdGltZTogJHtlbmRUaW1lIC0gc3RhcnRUaW1lfSBuc2AsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBUUkFDRSgnR1BVJywgYCR7cHJvZ3JhbU5hbWV9Ojoke3N0YXJ0VGltZVU2NH06OiR7ZW5kVGltZVU2NH1gKTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeVJlYWRCdWZmZXIudW5tYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUocXVlcnlSZWFkQnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJ1biBhIFdlYkdQVSBwcm9ncmFtLlxuICAgKiBAcGFyYW0gcHJvZ3JhbSBhIFByb2dyYW1JbmZvIGluc3RhbmNlXG4gICAqIEBwYXJhbSBpbnB1dFRlbnNvclZpZXdzIGEgVGVuc29yVmlldyBhcnJheS4gZWFjaCBlbGVtZW50IHJlcHJlc2VudHMgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiBHUFUuXG4gICAqIEBwYXJhbSBvdXRwdXRJbmRpY2VzIGFuIGluZGljZXMgYXJyYXkuIGVhY2ggZWxlbWVudCBjYW4gYmUgZWl0aGVyIC0xICh0ZW1wb3JhcnkgZGF0YSksIC0yIChwZXJzaXN0ZW50IGRhdGEpIG9yIGFuXG4gICAqIGluZGV4IHRvIHRoZSBrZXJuZWwncyBvdXRwdXQuXG4gICAqIEBwYXJhbSBjcmVhdGVLZXJuZWxPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIHRvIGtlcm5lbCdzIG91dHB1dCB3aXRoIHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB2YWx1ZSBhcyBhIGludGVybWVkaWF0ZSB2YWx1ZSwgZWl0aGVyIHRlbXBvcmFyeVxuICAgKiBvciBwZXJzaXN0ZW50IChvd25lZCBieSB0aGUgY3VycmVudCBrZXJuZWwpXG4gICAqIEByZXR1cm5zIGEgVGVuc29yVmlldyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICovXG4gIHJ1bihcbiAgICBwcm9ncmFtOiBQcm9ncmFtSW5mbyxcbiAgICBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gICAgb3V0cHV0SW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgY3JlYXRlS2VybmVsT3V0cHV0OiAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFRlbnNvclZpZXcsXG4gICAgY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0OiAoZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFRlbnNvclZpZXcsXG4gICAgb3V0cHV0Q291bnQ6IG51bWJlcixcbiAgKTogVGVuc29yVmlld1tdIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW0ubmFtZSk7XG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIGlucHV0c1xuICAgIGNvbnN0IGlucHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JWaWV3cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZGF0YSA9IGlucHV0VGVuc29yVmlld3NbaV0uZGF0YTtcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cbiAgICAgIGlmIChkYXRhID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KGRhdGEpO1xuICAgICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke2RhdGF9YCk7XG4gICAgICB9XG4gICAgICBpbnB1dERhdGFzLnB1c2goZ3B1RGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvdXRwdXRzLCBkaXNwYXRjaEdyb3VwLCBwcm9ncmFtVW5pZm9ybXMgfSA9IHByb2dyYW0uZ2V0UnVuRGF0YShpbnB1dFRlbnNvclZpZXdzKTtcblxuICAgIC8vIGNoZWNrIG91dHB1dCBpbmRpY2VzXG4gICAgY29uc3QgdmFsaWRhdGVkT3V0cHV0SW5kaWNlcyA9IG91dHB1dEluZGljZXMubGVuZ3RoID09PSAwID8gb3V0cHV0cy5tYXAoKF8sIGkpID0+IGkpIDogb3V0cHV0SW5kaWNlcztcbiAgICBpZiAodmFsaWRhdGVkT3V0cHV0SW5kaWNlcy5sZW5ndGggIT09IG91dHB1dHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7dmFsaWRhdGVkT3V0cHV0SW5kaWNlcy5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtvdXRwdXRzLmxlbmd0aH0uYCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIG91dHB1dHNcbiAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3czogVGVuc29yVmlld1tdID0gW107XG4gICAgY29uc3Qgb3V0cHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gdmFsdWUgLTEgYW5kIC0yIGFyZSB1c2VkIGZvciBjcmVhdGluZyB0ZW1wb3JhcnkgYW5kIHBlcnNpc3RlbnQgb3V0cHV0cy5cbiAgICAgIC8vIHZhbHVlIC0zIGlzIHVzZWQgZm9yIHBsYWNlaG9sZGVyIG91dHB1dC4gU28gLTMsIC0yLCAtMSBhbmQgMCwgMSwgMiwgLi4uIGFyZSB2YWxpZFxuICAgICAgLy8gb3V0cHV0IGluZGljZXMuIHNlZSB0eXBlIGRlZmluaXRpb24gb2YgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKFxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcih2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldKSB8fFxuICAgICAgICB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldIDwgLTMgfHxcbiAgICAgICAgdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA+PSBvdXRwdXRDb3VudFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7dmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVGVtcG9yYXJ5ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTE7XG4gICAgICBjb25zdCBpc1BlcnNpc3RlbnQgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMjtcbiAgICAgIGNvbnN0IHRlbnNvclZpZXcgPVxuICAgICAgICBpc1RlbXBvcmFyeSB8fCBpc1BlcnNpc3RlbnRcbiAgICAgICAgICA/IGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dChvdXRwdXRzW2ldLmRhdGFUeXBlLCBvdXRwdXRzW2ldLmRpbXMpXG4gICAgICAgICAgOiBjcmVhdGVLZXJuZWxPdXRwdXQodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSwgb3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKTtcbiAgICAgIG91dHB1dFRlbnNvclZpZXdzLnB1c2godGVuc29yVmlldyk7XG4gICAgICAvLyBpZiB0ZW5zb3IgdmlldyBkYXRhIGlzIDAsIGl0IG1lYW5zIHRoZSBvdXRwdXQgaXMgemVyby1zaXplZCB0ZW5zb3IsIGFuZCB0aGVyZSBpcyBubyBHUFUgZGF0YSBmb3IgaXQuXG4gICAgICBpZiAodGVuc29yVmlldy5kYXRhID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHRlbnNvclZpZXcuZGF0YSk7XG4gICAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke3RlbnNvclZpZXcuZGF0YX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeURhdGEucHVzaChncHVEYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgICAgbGV0IHBlcnNpc3RlbnREYXRhID0gdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQhKTtcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgICAgIHBlcnNpc3RlbnREYXRhID0gW107XG4gICAgICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQhLCBwZXJzaXN0ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVyc2lzdGVudERhdGEucHVzaChncHVEYXRhKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dERhdGFzLnB1c2goZ3B1RGF0YSk7XG4gICAgfVxuXG4gICAgLy8gd2hlbiB0aGVyZSBhcmUgYW55IHplcm8tc2l6ZWQgdGVuc29yIGluIHRoZSBpbnB1dHMgb3Igb3V0cHV0cywgd2Ugc2hvdWxkIHJlcG9ydCBlcnJvciB1bmxlc3MgYWxsIG91dHB1dHMgYXJlXG4gICAgLy8gemVyby1zaXplZCB0ZW5zb3JzLlxuICAgIGlmIChpbnB1dERhdGFzLmxlbmd0aCAhPT0gaW5wdXRUZW5zb3JWaWV3cy5sZW5ndGggfHwgb3V0cHV0RGF0YXMubGVuZ3RoICE9PSBvdXRwdXRUZW5zb3JWaWV3cy5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIGFsbCBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcnVuIHRoZSBwcm9ncmFtLlxuICAgICAgaWYgKG91dHB1dERhdGFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtLm5hbWUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0VGVuc29yVmlld3M7XG4gICAgICB9XG4gICAgICAvLyBpZiBzb21lIG91dHB1dHMgYXJlIHplcm8tc2l6ZWQgdGVuc29ycywgcmVwb3J0IGFuIGVycm9yLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IHNvIGZhciB3ZSBkb24ndCBzZWUgYW55IHVzZSBjYXNlIHRoYXQgb3V0cHV0cyBpbmNsdWRlIGJvdGggemVyby1zaXplZCB0ZW5zb3JzIGFuZCBub24temVyby1zaXplZCB0ZW5zb3JzLlxuICAgICAgLy8gSWYgd2Ugc2VlIHN1Y2ggdXNlIGNhc2UsIHdlIG5lZWQgdG8gbWFrZSBhIGNoYW5nZSBoZXJlIHRvIHN1cHBvcnQgaXQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcm9ncmFtICR7cHJvZ3JhbS5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gbG9hZCB1bmlmb3Jtc1xuICAgIC8vIFRPRE86IGFkZCBjYWNoZSBmb3IgdW5pZm9ybSAoaXMgaXQgbmVjZXNzYXJ5PylcbiAgICAvL1xuICAgIGxldCB1bmlmb3JtQnVmZmVyQmluZGluZzogR1BVQmluZGluZ1Jlc291cmNlIHwgdW5kZWZpbmVkO1xuICAgIGlmIChwcm9ncmFtVW5pZm9ybXMpIHtcbiAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygdi5kYXRhID09PSAnbnVtYmVyJyA/IFt2LmRhdGFdIDogdi5kYXRhO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdub2ZcbiAgICAgICAgY29uc3Qgc2l6ZU9mRWxlbWVudCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDIgOiA0O1xuICAgICAgICBsZXQgc2l6ZU9mVmVjT3JNYXQ7XG4gICAgICAgIGxldCBiYXNlQWxpZ25tZW50O1xuICAgICAgICBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgICAgICAgYmFzZUFsaWdubWVudCA9IGRhdGEubGVuZ3RoID4gNCA/IDE2IDogZGF0YS5sZW5ndGggPiAyID8gOCA6IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudDtcbiAgICAgICAgICBzaXplT2ZWZWNPck1hdCA9IGRhdGEubGVuZ3RoID4gNCA/IDE2IDogc2l6ZU9mRWxlbWVudCAqIGRhdGEubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VBbGlnbm1lbnQgPSBkYXRhLmxlbmd0aCA8PSAyID8gZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50IDogMTY7XG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSAxNjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gTWF0aC5jZWlsKGN1cnJlbnRPZmZzZXQgLyBiYXNlQWxpZ25tZW50KSAqIGJhc2VBbGlnbm1lbnQ7XG4gICAgICAgIG9mZnNldHMucHVzaChjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgLy8gRm9yIG5vbi1mbG9hdDE2IHR5cGUsIHdoZW4gZGF0YS5sZW5ndGggPiA0LCB0aGUgdW5pZm9ybSB2YXJpYWJsZSBpcyBvZiB0eXBlIGFycmF5PHZlYzQ8aTMyfHUzMnxmMzI+LE4+LCB3aGVyZVxuICAgICAgICAvLyBOID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNCkgYW5kIFNpemVPZih2ZWM0PGkzMnx1MzJ8ZjMyPikgPSAxNi4gVGhlIHRvdGFsIGJ5dGUgbGVuZ3RoIGlzIE4gKlxuICAgICAgICAvLyBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pLiBGb3IgZmxvYXQxNiB0eXBlLCB3aGVuIGRhdGEubGVuZ3RoID4gNCwgdGhlIHVuaWZvcm0gdmFyaWFibGUgaXMgb2YgdHlwZVxuICAgICAgICAvLyBhcnJheTxtYXQyeDQ8ZjE2PixOPiwgd2hlcmUgTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDgpIGFuZCBTaXplT2YobWF0Mng0PGYxNj4pID0gMTYuIFRoZSB0b3RhbCBieXRlXG4gICAgICAgIC8vIGxlbmd0aCBpcyBOICogU2l6ZU9mKG1hdDJ4NDxmMTY+KS5cbiAgICAgICAgY29uc3QgZWxlbWVudFBlclZlY09yTWF0ID0gdi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gOCA6IDQ7XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz1cbiAgICAgICAgICBkYXRhLmxlbmd0aCA+IDQgPyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyBlbGVtZW50UGVyVmVjT3JNYXQpICogc2l6ZU9mVmVjT3JNYXQgOiBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gTWVldCBhbGlnbm1lbnQgb2Ygc3RydWN0IGhlcmU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XR1NMLyNhbGlnbm1lbnQtYW5kLXNpemUuIEZvciBzaW1wbGljaXR5LCBzZXRcbiAgICAgIC8vIG1heEFsaWdubWVudE9mRmllbGQgdG8gMTYgc2luY2UgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGhhcyBiZWVuIHJvdW5kZWQgdXAgdG8gMTYuXG4gICAgICBjb25zdCBtYXhBbGlnbm1lbnRPZkZpZWxkID0gMTY7XG4gICAgICBjdXJyZW50T2Zmc2V0ID0gTWF0aC5jZWlsKGN1cnJlbnRPZmZzZXQgLyBtYXhBbGlnbm1lbnRPZkZpZWxkKSAqIG1heEFsaWdubWVudE9mRmllbGQ7XG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdXJyZW50T2Zmc2V0KTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldHNbaV07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygdi5kYXRhID09PSAnbnVtYmVyJyA/IFt2LmRhdGFdIDogdi5kYXRhO1xuICAgICAgICBpZiAodi50eXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xuICAgICAgICAgIG5ldyBJbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS51aW50MzIpIHtcbiAgICAgICAgICBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICAgICAgICBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHYudHlwZSl9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1bmlmb3JtQnVmZmVyRGF0YSA9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGN1cnJlbnRPZmZzZXQsIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7XG4gICAgICB0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcih1bmlmb3JtQnVmZmVyRGF0YS5idWZmZXIsIDAsIGFycmF5QnVmZmVyLCAwLCBjdXJyZW50T2Zmc2V0KTtcbiAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh1bmlmb3JtQnVmZmVyRGF0YS5pZCk7XG4gICAgICB1bmlmb3JtQnVmZmVyQmluZGluZyA9IHsgb2Zmc2V0OiAwLCBzaXplOiBjdXJyZW50T2Zmc2V0LCBidWZmZXI6IHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlciB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwID0gdGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShkaXNwYXRjaEdyb3VwKTtcbiAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdID09PSAxO1xuICAgIC8vIGdldCBwcm9ncmFtIGluZm9cbiAgICBjb25zdCBrZXkgPSBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleShwcm9ncmFtLCBpbnB1dFRlbnNvclZpZXdzLCBpczFEaW1lbnNpb25EaXNwYXRjaCk7XG4gICAgbGV0IGFydGlmYWN0ID0gdGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChrZXkpO1xuICAgIGlmICghYXJ0aWZhY3QpIHtcbiAgICAgIGFydGlmYWN0ID0gdGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCk7XG4gICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KGtleSwgYXJ0aWZhY3QpO1xuICAgICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFthcnRpZmFjdF0ga2V5OiAke2tleX0sIHByb2dyYW1OYW1lOiAke3Byb2dyYW0ubmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSB1bmlmb3JtIHZhcmlhYmxlc1xuICAgIGlmIChwcm9ncmFtVW5pZm9ybXMgJiYgYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8pIHtcbiAgICAgIGlmIChwcm9ncmFtVW5pZm9ybXMubGVuZ3RoICE9PSBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBVbmlmb3JtIHZhcmlhYmxlcyBjb3VudCBtaXNtYXRjaDogZXhwZWN0ICR7YXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7XG4gICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXMubGVuZ3RoXG4gICAgICAgICAgfSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB1bmlmb3JtID0gcHJvZ3JhbVVuaWZvcm1zW2ldO1xuICAgICAgICBjb25zdCBhY3R1YWxUeXBlID0gdW5pZm9ybS50eXBlO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSB0eXBlb2YgdW5pZm9ybS5kYXRhID09PSAnbnVtYmVyJyA/IDEgOiB1bmlmb3JtLmRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBbdHlwZSwgbGVuZ3RoXSA9IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvW2ldO1xuICAgICAgICBpZiAoYWN0dWFsVHlwZSAhPT0gdHlwZSB8fCBhY3R1YWxMZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbmlmb3JtIHZhcmlhYmxlICR7aX0gbWlzbWF0Y2g6IGV4cGVjdCB0eXBlICR7dHlwZX0gd2l0aCBzaXplICR7bGVuZ3RofSwgZ290IHR5cGUgJHtcbiAgICAgICAgICAgICAgYWN0dWFsVHlwZVxuICAgICAgICAgICAgfSB3aXRoIHNpemUgJHthY3R1YWxMZW5ndGh9IGluIHByb2dyYW0gXCIke2FydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9XCIuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ2luZm8nLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHtwcm9ncmFtLm5hbWV9XCIgKGtleT0ke2tleX0pIHdpdGggJHtub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX14JHtcbiAgICAgICAgICBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXVxuICAgICAgICB9eCR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl19YCxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgfHwgdGhpcy5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xuICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm86IFBlbmRpbmdLZXJuZWxJbmZvID0ge1xuICAgICAgICBrZXJuZWxJZDogdGhpcy5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBwcm9ncmFtTmFtZTogYXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSxcbiAgICAgICAgaW5wdXRUZW5zb3JWaWV3cyxcbiAgICAgICAgb3V0cHV0VGVuc29yVmlld3MsXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcblxuICAgICAgaWYgKHRoaXMuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICAgICAgc2Vzc2lvblBlbmRpbmdLZXJuZWxzIS5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihhcnRpZmFjdCwgaW5wdXREYXRhcywgb3V0cHV0RGF0YXMsIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwLCB1bmlmb3JtQnVmZmVyQmluZGluZyk7XG5cbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtLm5hbWUpO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3JWaWV3cztcbiAgfVxuXG4gIHVwbG9hZChncHVEYXRhSWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKGdwdURhdGFJZCwgZGF0YSk7XG4gIH1cblxuICBtZW1jcHkoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkoc3JjLCBkc3QpO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBtYXkgYmUgY2hhbmdlZCBhZnRlciB0aGUgYXN5bmMgZnVuY3Rpb24gaXMgY2FsbGVkLiBzbyB3ZSB1c2UgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIGJ1ZmZlciBpcyB1cC10by1kYXRlLlxuICAgIGF3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQoZ3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXIpO1xuICB9XG5cbiAgYWxsb2Moc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZSkuaWQ7XG4gIH1cblxuICBmcmVlKHB0cjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHB0cik7XG4gIH1cblxuICBjcmVhdGVLZXJuZWwoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24sIGtlcm5lbE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG9wID0gV0VCR1BVX09QX1JFU09MVkVfUlVMRVMuZ2V0KGtlcm5lbFR5cGUpO1xuICAgIGlmICghb3ApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHtrZXJuZWxUeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbEluZm86IEtlcm5lbEluZm8gPSB7XG4gICAgICBrZXJuZWxUeXBlLFxuICAgICAga2VybmVsTmFtZSxcbiAgICAgIGtlcm5lbEVudHJ5OiBvcFswXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFtvcFsxXSwgYXR0cmlidXRlXSxcbiAgICB9O1xuICAgIHRoaXMua2VybmVscy5zZXQoa2VybmVsSWQsIGtlcm5lbEluZm8pO1xuICB9XG5cbiAgcmVsZWFzZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKHBlcnNpc3RlbnREYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIH1cblxuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIHRoaXMua2VybmVscy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG5cbiAgY29tcHV0ZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyLCBjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgZXJyb3JzOiBBcnJheTxQcm9taXNlPHN0cmluZyB8IG51bGw+Pik6IG51bWJlciB7XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke2tlcm5lbElkfWApO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsLmtlcm5lbFR5cGU7XG4gICAgY29uc3Qga2VybmVsTmFtZSA9IGtlcm5lbC5rZXJuZWxOYW1lO1xuICAgIGNvbnN0IGtlcm5lbEVudHJ5ID0ga2VybmVsLmtlcm5lbEVudHJ5O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBrZXJuZWwuYXR0cmlidXRlcztcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBrZXJuZWxJZDtcblxuICAgIC8vIHBhcnNlIGF0dHJpYnV0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKGF0dHJpYnV0ZXNbMF0pIHtcbiAgICAgIGF0dHJpYnV0ZXNbMV0gPSBhdHRyaWJ1dGVzWzBdKGF0dHJpYnV0ZXNbMV0pO1xuICAgICAgYXR0cmlidXRlc1swXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIuLi5gKTtcblxuICAgIGNvbnN0IHVzZUVycm9yU2NvcGUgPSB0aGlzLmVudi5kZWJ1ZztcblxuICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBpZiAodXNlRXJyb3JTY29wZSkge1xuICAgICAgICB0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZSgndmFsaWRhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBrZXJuZWxFbnRyeShjb250ZXh0LCBhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIHJldHVybiAwOyAvLyBPUlRfT0tcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgZmFpbGVkLiAke2V9YCkpO1xuICAgICAgcmV0dXJuIDE7IC8vIE9SVF9GQUlMXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh1c2VFcnJvclNjb3BlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgIHRoaXMuZGV2aWNlXG4gICAgICAgICAgICAucG9wRXJyb3JTY29wZSgpXG4gICAgICAgICAgICAudGhlbigoZXJyKSA9PlxuICAgICAgICAgICAgICBlcnIgPyBgR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCI6ICR7ZXJyLm1lc3NhZ2V9YCA6IG51bGwsXG4gICAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKSB7XG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vICNyZWdpb24gZXh0ZXJuYWwgYnVmZmVyXG4gIHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBidWZmZXI6IEdQVUJ1ZmZlciwgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQoc2Vzc2lvbklkLCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgYnVmZmVyIG1heSBiZSB1c2VyIGNyZWF0ZWQsIG9yIG1hbmFnZWQgYnkgR1BVIGRhdGEgbWFuYWdlci5cbiAgICAvLyBUaGUgR1BVIGRhdGEgbWFuYWdlciB3aWxsIG5vdCBtYW5hZ2UgdGhlc2UgYnVmZmVycy4gd2UgcmVnaXN0ZXIgdGhlbSBhcyBleHRlcm5hbCBidWZmZXJzLlxuICAgIC8vXG4gICAgLy8gVGhlIG1hcCBgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZ2AgaXMgdXNlZCB0byBzdG9yZSB0aGUgZGF0YSBJRCBhbmQgYnVmZmVyIGZvciBlYWNoIGlucHV0L291dHB1dC4gT25jZSBhXG4gICAgLy8gc3BlY2lmaWMgaW5wdXQvb3V0cHV0IGlzIHJlZ2lzdGVyZWQsIHRoZSBkYXRhIElEIHdpbGwgbm90IGNoYW5nZS5cbiAgICBjb25zdCBwcmV2aW91c0J1ZmZlciA9IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZ2V0KGluZGV4KTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXIsIHNpemUsIHByZXZpb3VzQnVmZmVyKTtcbiAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLnNldChpbmRleCwgW2lkLCBidWZmZXJdKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgdW5yZWdpc3RlckJ1ZmZlcnMoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAoc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZykge1xuICAgICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5mb3JFYWNoKChidWZmZXJJbmZvKSA9PiB0aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXJJbmZvWzBdKSk7XG4gICAgICB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXIoZ3B1RGF0YUlkOiBudW1iZXIpOiBHUFVCdWZmZXIge1xuICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChncHVEYXRhSWQpO1xuICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke2dwdURhdGFJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGdwdURhdGEuYnVmZmVyO1xuICB9XG4gIGNyZWF0ZURvd25sb2FkZXIoXG4gICAgZ3B1QnVmZmVyOiBHUFVCdWZmZXIsXG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIHR5cGU6IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMsXG4gICk6ICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcywgZ3B1QnVmZmVyLCBzaXplKTtcbiAgICAgIHJldHVybiBjcmVhdGVWaWV3KGRhdGEuYnVmZmVyLCB0eXBlKTtcbiAgICB9O1xuICB9XG4gIC8vICNlbmRyZWdpb25cbiAgd3JpdGVUaW1lc3RhbXAoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ2luc2lkZS1wYXNzZXMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAodGhpcy5jb21wdXRlUGFzc0VuY29kZXIgYXMgYW55KS53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LCBpbmRleCk7XG4gIH1cbiAgc2V0UXVlcnlUeXBlKCk6IHZvaWQge1xuICAgIHRoaXMucXVlcnlUeXBlID0gJ25vbmUnO1xuICAgIGlmIChcbiAgICAgIHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGUgPT09ICdkZWZhdWx0JyB8fFxuICAgICAgKHR5cGVvZiB0aGlzLmVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmVudi53YXNtLnRyYWNlIDogdGhpcy5lbnYudHJhY2UpXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdpbnNpZGUtcGFzc2VzJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdhdC1wYXNzZXMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyAmJiB0eXBlb2YgdGhpcy5xdWVyeVNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5xdWVyeVNldCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHtcbiAgICAgICAgICB0eXBlOiAndGltZXN0YW1wJyxcbiAgICAgICAgICBjb3VudDogdGhpcy5tYXhEaXNwYXRjaE51bWJlciAqIDIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgIHsgc2l6ZTogdGhpcy5tYXhEaXNwYXRjaE51bWJlciAqIDIgKiA4LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFIH0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FwdHVyZUJlZ2luKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlQmVnaW4nKTtcbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISwgW10pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISwgW10pO1xuICAgIH1cbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdjYXB0dXJpbmcnO1xuICB9XG4gIGNhcHR1cmVFbmQoKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ2NhcHR1cmVFbmQnKTtcbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcbiAgfVxuICByZXBsYXkoKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ3JlcGxheScpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdyZXBsYXlpbmcnO1xuICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICBjb25zdCBsZW5ndGggPSBzZXNzaW9uQ29tbWFuZExpc3QhLmxlbmd0aDtcbiAgICB0aGlzLnBlbmRpbmdLZXJuZWxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gdGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBzZXNzaW9uQ29tbWFuZExpc3QhW2ldO1xuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbW1hbmQuY29tcHV0ZVBpcGVsaW5lKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgY29tbWFuZC5iaW5kR3JvdXApO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3VwcyguLi5jb21tYW5kLmRpc3BhdGNoR3JvdXApO1xuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxKTtcbiAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKys7XG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2goc2Vzc2lvblBlbmRpbmdLZXJuZWxzIVtpXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5tYXhEaXNwYXRjaE51bWJlciB8fCB0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcbiAgICAgICAgdGhpcy5lbmRDb21wdXRlUGFzcygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcbiAgfVxuXG4gIG9uQ3JlYXRlU2Vzc2lvbigpOiB2b2lkIHtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpO1xuICB9XG5cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMudW5yZWdpc3RlckJ1ZmZlcnMoc2Vzc2lvbklkKTtcbiAgICBpZiAodGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuaGFzKHNlc3Npb25JZCkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZCk7XG4gIH1cblxuICBvblJ1blN0YXJ0KHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgIHRoaXMuc2V0UXVlcnlUeXBlKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgV2ViTk5CYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJubic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIndlYm5uLmQudHNcIiAvPlxuXG5leHBvcnQgdHlwZSBUZW5zb3JJZCA9IG51bWJlcjtcblxuLyoqXG4gKiBNYW5hZ2VzIFRlbnNvcklkIHRvIE1MVGVuc29yIG1hcHBpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yTWFuYWdlciB7XG4gIC8qKlxuICAgKiBSZXNlcnZlIGEgbmV3IFRlbnNvcklkLlxuICAgKi9cbiAgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkO1xuICAvKipcbiAgICogUmVsZWFzZSBhIFRlbnNvcklkLlxuICAgKi9cbiAgcmVsZWFzZVRlbnNvcklkKHRlbnNvcklkOiBUZW5zb3JJZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFbnN1cmUgYSBNTFRlbnNvciBpcyBjcmVhdGVkIGZvciB0aGUgVGVuc29ySWQuXG4gICAqL1xuICBlbnN1cmVUZW5zb3IoXG4gICAgdGVuc29ySWQ6IFRlbnNvcklkLFxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgY29weU9sZDogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxNTFRlbnNvcj47XG4gIC8qKlxuICAgKiBVcGxvYWQgZGF0YSB0byBhIE1MVGVuc29yLlxuICAgKi9cbiAgdXBsb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBEb3dubG9hZCBkYXRhIGZyb20gYSBNTFRlbnNvci5cbiAgICovXG4gIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdFRlbnNvcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCB0ZW5zb3JzIGZvciBhIGdpdmVuIHNlc3Npb24uXG4gICAqL1xuICByZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbjogbnVtYmVyKTogdm9pZDtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBNTFRlbnNvciB3aXRoIGEgZ2l2ZW4gTUxDb250ZXh0IGFuZCByZXR1cm4gYSBUZW5zb3JJZC5cbiAgICovXG4gIHJlZ2lzdGVyVGVuc29yKG1sQ29udGV4dDogTUxDb250ZXh0LCBtbFRlbnNvcjogTUxUZW5zb3IsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IG51bWJlcltdKTogVGVuc29ySWQ7XG59XG5cbmxldCB0ZW5zb3JHdWlkID0gMTtcbmNvbnN0IGNyZWF0ZU5ld1RlbnNvcklkID0gKCk6IFRlbnNvcklkID0+IHRlbnNvckd1aWQrKztcblxuLyoqXG4gKiBUZW5zb3JXcmFwcGVyIHdyYXBzIGFuIE1MVGVuc29yIGFuZCBwcm92aWRlcyBhIHdheSB0byB0cmFjayB0aGUgbGFzdCBzZXNzaW9uIHRoYXQgdXNlZCBpdC5cbiAqL1xuY2xhc3MgVGVuc29yV3JhcHBlciB7XG4gIC8vIFRoZSBpZCBvZiB0aGUgbGFzdCBzZXNzaW9uIHRoYXQgdXNlZCB0aGlzIHRlbnNvci5cbiAgcHVibGljIHNlc3Npb25JZDogbnVtYmVyO1xuXG4gIHByaXZhdGUgbWxDb250ZXh0OiBNTENvbnRleHQ7XG4gIHByaXZhdGUgbWxUZW5zb3I6IE1MVGVuc29yO1xuICBwcml2YXRlIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZTtcbiAgcHJpdmF0ZSB0ZW5zb3JTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IoZGVzY3JpcHRvcjoge1xuICAgIHNlc3Npb25JZDogbnVtYmVyO1xuICAgIGNvbnRleHQ6IE1MQ29udGV4dDtcbiAgICB0ZW5zb3I6IE1MVGVuc29yO1xuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZTtcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIH0pIHtcbiAgICB0aGlzLnNlc3Npb25JZCA9IGRlc2NyaXB0b3Iuc2Vzc2lvbklkO1xuICAgIHRoaXMubWxDb250ZXh0ID0gZGVzY3JpcHRvci5jb250ZXh0O1xuICAgIHRoaXMubWxUZW5zb3IgPSBkZXNjcmlwdG9yLnRlbnNvcjtcbiAgICB0aGlzLmRhdGFUeXBlID0gZGVzY3JpcHRvci5kYXRhVHlwZTtcbiAgICB0aGlzLnRlbnNvclNoYXBlID0gZGVzY3JpcHRvci5zaGFwZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdGVuc29yKCk6IE1MVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBNTE9wZXJhbmREYXRhVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVR5cGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNoYXBlKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JTaGFwZTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+ICdbV2ViTk5dIFRlbnNvcldyYXBwZXIuZGVzdHJveScpO1xuICAgIHRoaXMubWxUZW5zb3IuZGVzdHJveSgpO1xuICB9XG5cbiAgcHVibGljIHdyaXRlKGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLCBkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkKCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICBwdWJsaWMgYXN5bmMgcmVhZChkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBhc3luYyByZWFkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChkc3RCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IsIGRzdEJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpO1xuICB9XG5cbiAgcHVibGljIHNhbWVUeXBlQW5kU2hhcGUoZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVHlwZSA9PT0gZGF0YVR5cGUgJiYgdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGVbaV0pO1xuICB9XG59XG5cbi8qKlxuICogVGVuc29yVHJhY2tlciB0cmFja3MgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhLlxuICpcbiAqIFdlIG5lZWQgdG8gdHJhY2sgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhIGJlY2F1c2Ugd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIE1MVGVuc29yIHVudGlsXG4gKiB3ZSBrbm93IHRoZSBkYXRhIHR5cGUgYW5kIHNoYXBlLiBUaGlzIGlzIGJlY2F1c2UgV2ViTk4gb25seSBzdXBwb3J0IGNyZWF0aW5nIE1MVGVuc29ycyB3aXRoIGRhdGFUeXBlcyBhbmQgc2hhcGUuXG4gKi9cbmNsYXNzIFRlbnNvcklkVHJhY2tlciB7XG4gIHByaXZhdGUgYWN0aXZlVXBsb2FkPzogVWludDhBcnJheTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRlbnNvck1hbmFnZXI6IFRlbnNvck1hbmFnZXJJbXBsLFxuICAgIHByaXZhdGUgd3JhcHBlcj86IFRlbnNvcldyYXBwZXIsXG4gICkge31cblxuICBwdWJsaWMgZ2V0IHRlbnNvcldyYXBwZXIoKTogVGVuc29yV3JhcHBlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRlbnNvcldyYXBwZXIpIHtcbiAgICAgIHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlcik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGVuc3VyZVRlbnNvcihcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcbiAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICBpZiAodGhpcy53cmFwcGVyLnNhbWVUeXBlQW5kU2hhcGUoZGF0YVR5cGUsIHNoYXBlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb3B5T2xkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSBuZXcgVWludDhBcnJheShhd2FpdCB0aGlzLndyYXBwZXIucmVhZCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLndyYXBwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgdXNhZ2UgPSBNTFRlbnNvclVzYWdlLlJFQUQgfCBNTFRlbnNvclVzYWdlLldSSVRFO1xuICAgIHRoaXMud3JhcHBlciA9IGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5nZXRDYWNoZWRUZW5zb3IoZGF0YVR5cGUsIHNoYXBlLCB1c2FnZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBpZiAoY29weU9sZCAmJiB0aGlzLmFjdGl2ZVVwbG9hZCkge1xuICAgICAgdGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKTtcbiAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLndyYXBwZXIudGVuc29yO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZChkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgdGhpcy53cmFwcGVyLndyaXRlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFjdGl2ZVVwbG9hZCkge1xuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQuc2V0KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZVVwbG9hZCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZChkc3RCdWZmZXI/OiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAodGhpcy5hY3RpdmVVcGxvYWQpIHtcbiAgICAgIGlmIChkc3RCdWZmZXIpIHtcbiAgICAgICAgaWYgKGRzdEJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZHN0QnVmZmVyKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlci5idWZmZXIsIGRzdEJ1ZmZlci5ieXRlT2Zmc2V0LCBkc3RCdWZmZXIuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVVcGxvYWQuYnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMud3JhcHBlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuJyk7XG4gICAgfVxuICAgIGlmICghZHN0QnVmZmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnJlYWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlci5yZWFkKGRzdEJ1ZmZlcik7XG4gIH1cbn1cblxuY2xhc3MgVGVuc29yTWFuYWdlckltcGwgaW1wbGVtZW50cyBUZW5zb3JNYW5hZ2VyIHtcbiAgcHJpdmF0ZSB0ZW5zb3JUcmFja2Vyc0J5SWQ6IE1hcDxUZW5zb3JJZCwgVGVuc29ySWRUcmFja2VyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBmcmVlVGVuc29yczogVGVuc29yV3JhcHBlcltdID0gW107XG4gIHByaXZhdGUgZXh0ZXJuYWxUZW5zb3JzOiBTZXQ8VGVuc29yV3JhcHBlcj4gPSBuZXcgU2V0KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJOTkJhY2tlbmQpIHt9XG5cbiAgcHVibGljIHJlc2VydmVUZW5zb3JJZCgpOiBUZW5zb3JJZCB7XG4gICAgY29uc3QgdGVuc29ySWQgPSBjcmVhdGVOZXdUZW5zb3JJZCgpO1xuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0ZW5zb3JJZCwgbmV3IFRlbnNvcklkVHJhY2tlcih0aGlzKSk7XG4gICAgcmV0dXJuIHRlbnNvcklkO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW5zb3JUcmFja2VyID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcbiAgICBpZiAoIXRlbnNvclRyYWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHRlbnNvcklkKTtcbiAgICBpZiAodGVuc29yVHJhY2tlci50ZW5zb3JXcmFwcGVyKSB7XG4gICAgICB0aGlzLnJlbGVhc2VUZW5zb3IodGVuc29yVHJhY2tlci50ZW5zb3JXcmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxuICAgIHRlbnNvcklkOiBUZW5zb3JJZCxcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICAgc2hhcGU6IG51bWJlcltdLFxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcbiAgICBMT0dfREVCVUcoXG4gICAgICAndmVyYm9zZScsXG4gICAgICAoKSA9PlxuICAgICAgICBgW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvciB7dGVuc29ySWQ6ICR7dGVuc29ySWR9LCBkYXRhVHlwZTogJHtcbiAgICAgICAgICBkYXRhVHlwZVxuICAgICAgICB9LCBzaGFwZTogJHtzaGFwZX0sIGNvcHlPbGQ6ICR7Y29weU9sZH19YCxcbiAgICApO1xuICAgIGNvbnN0IHRlbnNvciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XG4gICAgaWYgKCF0ZW5zb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbnNvci5lbnN1cmVUZW5zb3IoZGF0YVR5cGUsIHNoYXBlLCBjb3B5T2xkKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgY29uc3QgdGVuc29yID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcbiAgICBpZiAoIXRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICB0ZW5zb3IudXBsb2FkKGRhdGEpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICBwdWJsaWMgYXN5bmMgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBhc3luYyBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+IGBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3RlbnNvcklkfSwgZHN0QnVmZmVyOiAke2RzdEJ1ZmZlcj8uYnl0ZUxlbmd0aH19YCxcbiAgICApO1xuICAgIGNvbnN0IHRlbnNvclRyYWNrZXIgPSB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodGVuc29ySWQpO1xuICAgIGlmICghdGVuc29yVHJhY2tlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yVHJhY2tlci5kb3dubG9hZChkc3RCdWZmZXIpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgdGVuc29yIG9mIHRoaXMuZnJlZVRlbnNvcnMpIHtcbiAgICAgIGlmICh0ZW5zb3Iuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgdGVuc29yLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmVlVGVuc29ycyA9IHRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKCh0ZW5zb3IpID0+IHRlbnNvci5zZXNzaW9uSWQgIT09IHNlc3Npb25JZCk7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJUZW5zb3IoXG4gICAgbWxDb250ZXh0OiBNTENvbnRleHQsXG4gICAgbWxUZW5zb3I6IE1MVGVuc29yLFxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvcklkIHtcbiAgICBjb25zdCB0ZW5zb3JJZCA9IGNyZWF0ZU5ld1RlbnNvcklkKCk7XG4gICAgLy8gRGVmYXVsdGluZyB0byBSRUFEIHwgV1JJVEUgaWYgdXNhZ2UgaXMgbm90IHByb3ZpZGVkLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBUZW5zb3JXcmFwcGVyKHtcbiAgICAgIHNlc3Npb25JZDogdGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsXG4gICAgICBjb250ZXh0OiBtbENvbnRleHQsXG4gICAgICB0ZW5zb3I6IG1sVGVuc29yLFxuICAgICAgZGF0YVR5cGUsXG4gICAgICBzaGFwZSxcbiAgICB9KTtcbiAgICB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodGVuc29ySWQsIG5ldyBUZW5zb3JJZFRyYWNrZXIodGhpcywgd3JhcHBlcikpO1xuICAgIHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZCh3cmFwcGVyKTtcbiAgICByZXR1cm4gdGVuc29ySWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIGNyZWF0ZSBhbiBNTFRlbnNvciB3aXRoIHRoZSBnaXZlbiBkYXRhIHR5cGUgYW5kIHNoYXBlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldENhY2hlZFRlbnNvcihcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHVzYWdlOiBNTFRlbnNvclVzYWdlRmxhZ3MsXG4gICAgd3JpdGFibGU6IGJvb2xlYW4sXG4gICAgcmVhZGFibGU6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8VGVuc29yV3JhcHBlcj4ge1xuICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCB0ZW5zb3JdIG9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKSB7XG4gICAgICBpZiAodGVuc29yLnNhbWVUeXBlQW5kU2hhcGUoZGF0YVR5cGUsIHNoYXBlKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5mcmVlVGVuc29ycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICB3cmFwcGVyLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQ7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gTUxDb250ZXh0LmNyZWF0ZVRlbnNvciB7ZGF0YVR5cGU6ICR7ZGF0YVR5cGV9LCBzaGFwZTogJHtzaGFwZX19YCk7XG4gICAgY29uc3QgdGVuc29yID0gYXdhaXQgY29udGV4dC5jcmVhdGVUZW5zb3Ioe1xuICAgICAgZGF0YVR5cGUsXG4gICAgICBzaGFwZSxcbiAgICAgIGRpbWVuc2lvbnM6IHNoYXBlLFxuICAgICAgdXNhZ2UsXG4gICAgICB3cml0YWJsZSxcbiAgICAgIHJlYWRhYmxlLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVGVuc29yV3JhcHBlcih7IHNlc3Npb25JZCwgY29udGV4dCwgdGVuc29yLCBkYXRhVHlwZSwgc2hhcGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSB0ZW5zb3IgZm9yIHJldXNlIHVubGVzcyBleHRlcm5hbC5cbiAgICovXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yKHRlbnNvcldyYXBwZXI6IFRlbnNvcldyYXBwZXIpIHtcbiAgICBpZiAodGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHRlbnNvcldyYXBwZXIpKSB7XG4gICAgICB0aGlzLmV4dGVybmFsVGVuc29ycy5kZWxldGUodGVuc29yV3JhcHBlcik7XG4gICAgfVxuICAgIHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0ZW5zb3JXcmFwcGVyKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yTWFuYWdlciA9ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIFRlbnNvck1hbmFnZXJJbXBsPik6IFRlbnNvck1hbmFnZXIgPT5cbiAgbmV3IFRlbnNvck1hbmFnZXJJbXBsKC4uLmFyZ3MpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIndlYm5uL3dlYm5uLmQudHNcIiAvPlxuXG5pbXBvcnQgeyBFbnYsIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuLi93YXNtLWZhY3RvcnknO1xuXG5pbXBvcnQgeyBjcmVhdGVWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBUZW5zb3JJZCwgY3JlYXRlVGVuc29yTWFuYWdlciB9IGZyb20gJy4vd2Vibm4vdGVuc29yLW1hbmFnZXInO1xuaW1wb3J0IHsgY29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5cbi8qXG4gKiBUZW5zb3JQcm90bzo6ZGF0YV90eXBlIHRvIFdlYk5OIE9wZXJhbmRUeXBlIG1hcHBpbmcuXG4gKi9cbmNvbnN0IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZSA9IG5ldyBNYXA8RGF0YVR5cGUsIE1MT3BlcmFuZERhdGFUeXBlPihbXG4gIFtEYXRhVHlwZS5mbG9hdCwgJ2Zsb2F0MzInXSxcbiAgW0RhdGFUeXBlLmZsb2F0MTYsICdmbG9hdDE2J10sXG4gIFtEYXRhVHlwZS5pbnQzMiwgJ2ludDMyJ10sXG4gIFtEYXRhVHlwZS51aW50MzIsICd1aW50MzInXSxcbiAgW0RhdGFUeXBlLmludDY0LCAnaW50NjQnXSxcbiAgW0RhdGFUeXBlLnVpbnQ2NCwgJ3VpbnQ2NCddLFxuICBbRGF0YVR5cGUuaW50OCwgJ2ludDgnXSxcbiAgW0RhdGFUeXBlLnVpbnQ4LCAndWludDgnXSxcbiAgW0RhdGFUeXBlLmJvb2wsICd1aW50OCddLFxuXSk7XG5cbi8qKlxuICogV2ViTk4gYmFja2VuZCBpbXBsZW1lbnRhdGlvbi4gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIE1MVGVuc29ycyBjcmVhdGVkIGJ5IHRoZSBiYWNrZW5kIGFuZCBrZWVwIHRyYWNrXG4gKiBvZiB0aGUgY3VycmVudCBNTENvbnRleHQgYmVpbmcgdXNlZCBieSB0aGUgc2Vzc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJOTkJhY2tlbmQge1xuICAvKipcbiAgICogVGVuc29yIG1hbmFnZXJzIGZvciBlYWNoIHNlc3Npb24uXG4gICAqL1xuICBwcml2YXRlIHRlbnNvck1hbmFnZXIgPSBjcmVhdGVUZW5zb3JNYW5hZ2VyKHRoaXMpO1xuICAvKipcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gTUxDb250ZXh0cy5cbiAgICovXG4gIHByaXZhdGUgbWxDb250ZXh0QnlTZXNzaW9uSWQgPSBuZXcgTWFwPG51bWJlciwgTUxDb250ZXh0PigpO1xuICAvKipcbiAgICogTWFwcyBmcm9tIE1MQ29udGV4dCB0byBzZXNzaW9uIGlkcy5cbiAgICovXG4gIHByaXZhdGUgc2Vzc2lvbklkc0J5TUxDb250ZXh0ID0gbmV3IE1hcDxNTENvbnRleHQsIFNldDxudW1iZXI+PigpO1xuICAvKipcbiAgICogQ3VycmVudCBzZXNzaW9uIGlkLlxuICAgKi9cbiAgcHJpdmF0ZSBhY3RpdmVTZXNzaW9uSWQ/OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZW52OiBFbnYpIHtcbiAgICBjb25maWd1cmVMb2dnZXIoZW52LmxvZ0xldmVsISwgISFlbnYuZGVidWcpO1xuICB9XG5cbiAgcHVibGljIGdldCBjdXJyZW50U2Vzc2lvbklkKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuYWN0aXZlU2Vzc2lvbklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlc3Npb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkO1xuICB9XG5cbiAgcHVibGljIG9uUnVuU3RhcnQoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VycmVudENvbnRleHQoKTogTUxDb250ZXh0IHtcbiAgICBjb25zdCBtbENvbnRleHQgPSB0aGlzLmdldE1MQ29udGV4dCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpO1xuICAgIGlmICghbWxDb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE1MQ29udGV4dCBmb3VuZCBmb3Igc2Vzc2lvbiAke3RoaXMuY3VycmVudFNlc3Npb25JZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1sQ29udGV4dDtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpOiB2b2lkIHtcbiAgICB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLnNldChzZXNzaW9uSWQsIG1sQ29udGV4dCk7XG4gICAgbGV0IHNlc3Npb25JZHMgPSB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobWxDb250ZXh0KTtcbiAgICBpZiAoIXNlc3Npb25JZHMpIHtcbiAgICAgIHNlc3Npb25JZHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQobWxDb250ZXh0LCBzZXNzaW9uSWRzKTtcbiAgICB9XG4gICAgc2Vzc2lvbklkcy5hZGQoc2Vzc2lvbklkKTtcbiAgfVxuXG4gIHB1YmxpYyBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgbWxDb250ZXh0ID0gdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQoc2Vzc2lvbklkKSE7XG4gICAgaWYgKCFtbENvbnRleHQpIHtcbiAgICAgIC8vIEN1cnJlbnQgc2Vzc2lvbiBpcyBub3QgYSBXZWJOTiBzZXNzaW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAgdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICBjb25zdCBzZXNzaW9uSWRzID0gdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG1sQ29udGV4dCkhO1xuICAgIHNlc3Npb25JZHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb25JZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZGVsZXRlKG1sQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1MQ29udGV4dChzZXNzaW9uSWQ6IG51bWJlcik6IE1MQ29udGV4dCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkIHtcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3RlbnNvcklkfX1gKTtcbiAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbnN1cmVUZW5zb3IoXG4gICAgdGVuc29ySWQ6IFRlbnNvcklkLFxuICAgIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsXG4gICAgZGltZW5zaW9uczogbnVtYmVyW10sXG4gICAgY29weU9sZDogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxNTFRlbnNvcj4ge1xuICAgIGNvbnN0IHdlYm5uRGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XG4gICAgaWYgKCF3ZWJubkRhdGFUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke29ubnhEYXRhVHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodGVuc29ySWQsIHdlYm5uRGF0YVR5cGUsIGRpbWVuc2lvbnMsIGNvcHlPbGQpO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZFRlbnNvcih0ZW5zb3JJZDogVGVuc29ySWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIXdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byB1cGxvYWQgdG8gYSBNTFRlbnNvciB3aGlsZSBzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgaXMgZmFsc2UnKTtcbiAgICB9XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gdXBsb2FkVGVuc29yIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRhdGE6ICR7ZGF0YS5ieXRlTGVuZ3RofX1gKTtcbiAgICB0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHRlbnNvcklkLCBkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZFRlbnNvcih0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodGVuc29ySWQsIGRzdEJ1ZmZlcik7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHRlbnNvcklkOiBUZW5zb3JJZCwgdHlwZTogVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzKTogKCkgPT4gUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGU+IHtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0ZW5zb3JJZCk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLCB0eXBlKTtcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyTUxUZW5zb3IodGVuc29yOiBNTFRlbnNvciwgb25ueERhdGFUeXBlOiBEYXRhVHlwZSwgZGltZW5zaW9uczogbnVtYmVyW10pOiBUZW5zb3JJZCB7XG4gICAgY29uc3Qgd2Vibm5EYXRhVHlwZSA9IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZS5nZXQob25ueERhdGFUeXBlKTtcbiAgICBpZiAoIXdlYm5uRGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7b25ueERhdGFUeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlZ2lzdGVyVGVuc29yKHRoaXMuY3VycmVudENvbnRleHQsIHRlbnNvciwgd2Vibm5EYXRhVHlwZSwgZGltZW5zaW9ucyk7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtXZWJOTl0gcmVnaXN0ZXJNTFRlbnNvciB7dGVuc29yOiAke3RlbnNvcn0sIGRhdGFUeXBlOiAke3dlYm5uRGF0YVR5cGV9LCBkaW1lbnNpb25zOiAke1xuICAgICAgICAgIGRpbWVuc2lvbnNcbiAgICAgICAgfX0gLT4ge3RlbnNvcklkOiAke2lkfX1gLFxuICAgICk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLy8gUmVnaXN0ZXIgV2ViTk4gQ29uc3RhbnQgb3BlcmFuZHMgZnJvbSBleHRlcm5hbCBkYXRhLlxuICBwdWJsaWMgcmVnaXN0ZXJNTENvbnN0YW50KFxuICAgIGV4dGVybmFsRmlsZVBhdGg6IHN0cmluZyxcbiAgICBkYXRhT2Zmc2V0OiBudW1iZXIsXG4gICAgZGF0YUxlbmd0aDogbnVtYmVyLFxuICAgIGJ1aWxkZXI6IE1MR3JhcGhCdWlsZGVyLFxuICAgIGRlc2M6IE1MT3BlcmFuZERlc2NyaXB0b3IsXG4gICAgbW91bnRlZEZpbGVzOiBNYXA8c3RyaW5nLCBVaW50OEFycmF5PiB8IHVuZGVmaW5lZCxcbiAgKTogTUxPcGVyYW5kIHtcbiAgICAvLyBJZiBhdmFpbGFibGUsIFwiTW9kdWxlLk1vdW50ZWRGaWxlc1wiIGlzIGEgTWFwIGZvciBhbGwgcHJlbG9hZGVkIGZpbGVzLlxuICAgIGlmICghbW91bnRlZEZpbGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsIG1vdW50ZWQgZmlsZXMgYXJlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgfVxuXG4gICAgbGV0IGZpbGVQYXRoID0gZXh0ZXJuYWxGaWxlUGF0aDtcbiAgICBpZiAoZXh0ZXJuYWxGaWxlUGF0aC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICBmaWxlUGF0aCA9IGV4dGVybmFsRmlsZVBhdGguc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlRGF0YSA9IG1vdW50ZWRGaWxlcy5nZXQoZmlsZVBhdGgpO1xuICAgIGlmICghZmlsZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtmaWxlUGF0aH0gbm90IGZvdW5kIGluIHByZWxvYWRlZCBmaWxlcy5gKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YU9mZnNldCArIGRhdGFMZW5ndGggPiBmaWxlRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dCBvZiBib3VuZHM6IGRhdGEgb2Zmc2V0IGFuZCBsZW5ndGggZXhjZWVkIHRoZSBleHRlcm5hbCBmaWxlIGRhdGEgc2l6ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBmaWxlRGF0YS5zbGljZShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YUxlbmd0aCkuYnVmZmVyO1xuICAgIGxldCBidWZmZXJWaWV3OiBBcnJheUJ1ZmZlclZpZXc7XG4gICAgc3dpdGNoIChkZXNjLmRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBCaWdJbnQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBCaWdVaW50NjRBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEludDhBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGVzYy5kYXRhVHlwZX0gaW4gY3JlYXRpbmcgV2ViTk4gQ29uc3RhbnQgZnJvbSBleHRlcm5hbCBkYXRhLmApO1xuICAgIH1cblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7ZGVzYy5kYXRhVHlwZX0sIHNoYXBlOiAke2Rlc2Muc2hhcGV9fX1gKTtcblxuICAgIHJldHVybiBidWlsZGVyLmNvbnN0YW50KGRlc2MsIGJ1ZmZlclZpZXcpO1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCk6IHZvaWQge1xuICAgIC8vIFVubGlrZSB0aGUgV2ViR1BVIGJhY2tlbmQsIHRoZSBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IG5lZWQgdG8gZmx1c2ggYW55IHBlbmRpbmcgb3BlcmF0aW9ucy5cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcywgRGF0YVR5cGUgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4uL3dhc20tdHlwZXMnO1xuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgQWRhcHRlckluZm8sIENvbXB1dGVDb250ZXh0LCBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcbmltcG9ydCB7IFdlYk5OQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC13ZWJubic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuY2xhc3MgVGVuc29yVmlld0ltcGwgaW1wbGVtZW50cyBUZW5zb3JWaWV3IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGRhdGFUeXBlOiBudW1iZXIsXG4gICAgcHVibGljIHJlYWRvbmx5IGRhdGE6IG51bWJlcixcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge31cblxuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwXG4gICAgICA/IG5ldyBGbG9hdDMyQXJyYXkoKVxuICAgICAgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwXG4gICAgICA/IG5ldyBCaWdJbnQ2NEFycmF5KClcbiAgICAgIDogbmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XG4gIH1cblxuICBnZXRJbnQzMkFycmF5KCk6IEludDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDAgPyBuZXcgSW50MzJBcnJheSgpIDogbmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XG4gIH1cblxuICBnZXRVaW50MTZBcnJheSgpOiBVaW50MTZBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYgJiYgdGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDE2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBVaW50MTZBcnJheSgpIDogbmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcge1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZShuZXdEaW1zKSAhPT0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldyBzaGFwZScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCB0aGlzLmRhdGFUeXBlLCB0aGlzLmRhdGEsIG5ld0RpbXMpO1xuICB9XG59XG5cbmNsYXNzIENvbXB1dGVDb250ZXh0SW1wbCBpbXBsZW1lbnRzIENvbXB1dGVDb250ZXh0IHtcbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xuICByZWFkb25seSBvcEtlcm5lbENvbnRleHQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG4gIGdldCBrZXJuZWxDdXN0b21EYXRhKCk6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IHtcbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhO1xuICB9XG4gIGdldCBjdXN0b21EYXRhQnVmZmVyKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LCB0aGlzLmN1c3RvbURhdGFPZmZzZXQgKyB0aGlzLmN1c3RvbURhdGFTaXplKTtcbiAgfVxuICBwcml2YXRlIGN1c3RvbURhdGFPZmZzZXQgPSAwO1xuICBwcml2YXRlIGN1c3RvbURhdGFTaXplID0gMDtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXG4gICAgcHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLFxuICAgIGNvbnRleHREYXRhT2Zmc2V0OiBudW1iZXIsXG4gICkge1xuICAgIHRoaXMuYWRhcHRlckluZm8gPSBiYWNrZW5kLmFkYXB0ZXJJbmZvO1xuICAgIGNvbnN0IGhlYXBVMzIgPSBtb2R1bGUuSEVBUFUzMjtcblxuICAgIC8vIGV4dHJhY3QgY29udGV4dCBkYXRhXG4gICAgbGV0IGRhdGFJbmRleCA9IGNvbnRleHREYXRhT2Zmc2V0ID4+PiAyO1xuICAgIHRoaXMub3BLZXJuZWxDb250ZXh0ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgY29uc3QgaW5wdXRDb3VudCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIHRoaXMub3V0cHV0Q291bnQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLmN1c3RvbURhdGFPZmZzZXQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLmN1c3RvbURhdGFTaXplID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG5cbiAgICBjb25zdCBpbnB1dHM6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGF0YSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGltID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07IGQrKykge1xuICAgICAgICBkaW1zLnB1c2goaGVhcFUzMltkYXRhSW5kZXgrK10pO1xuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2gobmV3IFRlbnNvclZpZXdJbXBsKG1vZHVsZSwgZGF0YVR5cGUsIGRhdGEsIGRpbXMpKTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gIH1cblxuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxuICAgICAgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLFxuICAgICAgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaLFxuICAgIF07XG4gIH1cblxuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZXNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplO1xuICB9XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdIHtcbiAgICAvLyBwcmVwYXJlIGlucHV0cy4gaW5wdXRzIHNob3VsZCBhbHdheXMgYmUgdmFsaWQgZGF0YS5cbiAgICBjb25zdCBtYXBwZWRJbnB1dHMgPVxuICAgICAgaW5wdXRzT3V0cHV0c01hcHBpbmc/LmlucHV0cz8ubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdudW1iZXInID8gdGhpcy5pbnB1dHNbaV0gOiBpKSkgPz8gdGhpcy5pbnB1dHM7XG4gICAgLy8gcHJlcGFyZSBvdXRwdXRzLlxuICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBpbnB1dHNPdXRwdXRzTWFwcGluZz8ub3V0cHV0cyA/PyBbXTtcbiAgICBjb25zdCBjcmVhdGVLZXJuZWxPdXRwdXQgPSAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+XG4gICAgICBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCB0aGlzLm91dHB1dChpbmRleCwgZGltcyksIGRpbXMpO1xuICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeU91dHB1dCA9IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBkaW1zKTtcbiAgICAgIGlmICghYnVmZmVyU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGFJZCA9IGJ1ZmZlclNpemUgPiAwID8gdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCA6IDA7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgZ3B1RGF0YUlkLCBkaW1zKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQucnVuKFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIG1hcHBlZElucHV0cyxcbiAgICAgIG91dHB1dEluZGljZXMsXG4gICAgICBjcmVhdGVLZXJuZWxPdXRwdXQsXG4gICAgICBjcmVhdGVUZW1wb3JhcnlPdXRwdXQsXG4gICAgICB0aGlzLm91dHB1dENvdW50LFxuICAgICk7XG4gIH1cblxuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxICsgZGltcy5sZW5ndGgpICogNCAvKiBzaXplb2Yoc2l6ZV90KSAqLyk7XG4gICAgICBsZXQgb2Zmc2V0ID0gZGF0YSA+PiAyO1xuICAgICAgdGhpcy5tb2R1bGUuSEVBUFUzMltvZmZzZXQrK10gPSBkaW1zLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm1vZHVsZS5IRUFQVTMyW29mZnNldCsrXSA9IGRpbXNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQhKHRoaXMub3BLZXJuZWxDb250ZXh0LCBpbmRleCwgZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske2luZGV4fV0gd2l0aCBkaW1zIFske2RpbXN9XS4gYCArXG4gICAgICAgICAgJ0lmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiAnICtcbiAgICAgICAgICBgRXJyb3I6ICR7ZX1gLFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIEpTRVAgd2l0aCBXZWJHUFUgYmFja2VuZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbG9hZGVkIGFuZCBpbml0aWFsaXplZCAoXCJfT3J0SW5pdFwiIGlzIGNhbGxlZCksIG9uY2UgZm9yXG4gKiBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgRVBzIGlmIHRoZXkgYXJlIHNwZWNpZmllZDpcbiAqIC0gXCJ3ZWJncHVcIlxuICogLSBcIndlYm5uXCJcbiAqXG4gKiBGb3IgV2ViR1BVLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHM6XG4gKiAgLSBXZWJHUFUgaXMgZW5hYmxlZCBpbiBidWlsZCAoQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgPT09IGZhbHNlKS5cbiAqICAtIFdlYkdQVSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC4gKGEgdmFsaWQgR1BVQWRhcHRlciBpcyBwYXNzZWQgaW4pXG4gKlxuICogRm9yIFdlYk5OLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHM6XG4gKiAtIFdlYk5OIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQID09PSBmYWxzZSkuXG4gKiAtIFdlYk5OIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAobmF2aWdhdG9yLm1sIGlzIG5vdCB1bmRlZmluZWQpXG4gKlxuICogSWYgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQsIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBlcnJvci4gVGhpcyB3aWxsIGludmFsaWRhdGVcbiAqICd3ZWJncHUnLyd3ZWJubicgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBFUCwgZWl0aGVyIFwid2ViZ3B1XCIgb3IgXCJ3ZWJublwiXG4gKiBAcGFyYW0gbW9kdWxlIC0gdGhlIE9SVCBXZWJBc3NlbWJseSBtb2R1bGVcbiAqIEBwYXJhbSBlbnYgLSB0aGUgT1JUIGVudmlyb25tZW50IHZhcmlhYmxlIChvcnQuZW52KVxuICogQHBhcmFtIGdwdUFkYXB0ZXIgLSB0aGUgcHJlLWNyZWF0ZWQgR1BVIGFkYXB0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXQgPSBhc3luYyAoXG4gIG5hbWU6ICd3ZWJncHUnIHwgJ3dlYm5uJyxcbiAgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxuICBlbnY6IEVudixcbiAgZ3B1QWRhcHRlcj86IEdQVUFkYXB0ZXIsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QganNlcEluaXQgPSBtb2R1bGUuanNlcEluaXQ7XG4gIGlmICghanNlcEluaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEpTRVAuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LicpO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgY29uc3QgYmFja2VuZCA9IG5ldyBXZWJHcHVCYWNrZW5kKCk7XG4gICAgYXdhaXQgYmFja2VuZC5pbml0aWFsaXplKGVudiwgZ3B1QWRhcHRlciEpO1xuXG4gICAganNlcEluaXQoJ3dlYmdwdScsIFtcbiAgICAgIC8vIGJhY2tlbmRcbiAgICAgIGJhY2tlbmQsXG5cbiAgICAgIC8vIGpzZXBBbGxvYygpXG4gICAgICAoc2l6ZTogbnVtYmVyKSA9PiBiYWNrZW5kLmFsbG9jKHNpemUpLFxuXG4gICAgICAvLyBqc2VwRnJlZSgpXG4gICAgICAocHRyOiBudW1iZXIpID0+IGJhY2tlbmQuZnJlZShwdHIpLFxuXG4gICAgICAvLyBqc2VwQ29weShzcmMsIGRzdCwgc2l6ZSwgaXNTb3VyY2VHcHUpXG4gICAgICAoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGlzU291cmNlR3B1ID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKGlzU291cmNlR3B1KSB7XG4gICAgICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke3NyY30sIGRzdD0ke2RzdH0sIHNpemU9JHtzaXplfWApO1xuICAgICAgICAgIGJhY2tlbmQubWVtY3B5KHNyYywgZHN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke3NyY30sIGdwdURhdGFJZD0ke2RzdH0sIHNpemU9JHtzaXplfWApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KHNyYyA+Pj4gMCwgKHNyYyA+Pj4gMCkgKyBzaXplKTtcbiAgICAgICAgICBiYWNrZW5kLnVwbG9hZChkc3QsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ29weUFzeW5jKHNyYywgZHN0LCBzaXplKVxuICAgICAgYXN5bmMgKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhT2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtncHVEYXRhSWR9LCBkYXRhT2Zmc2V0PSR7ZGF0YU9mZnNldH0sIHNpemU9JHtzaXplfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgYmFja2VuZC5kb3dubG9hZChncHVEYXRhSWQsICgpID0+IG1vZHVsZS5IRUFQVTguc3ViYXJyYXkoZGF0YU9mZnNldCA+Pj4gMCwgKGRhdGFPZmZzZXQgPj4+IDApICsgc2l6ZSkpO1xuICAgICAgfSxcblxuICAgICAgLy8ganNlcENyZWF0ZUtlcm5lbFxuICAgICAgKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duKSA9PlxuICAgICAgICBiYWNrZW5kLmNyZWF0ZUtlcm5lbChrZXJuZWxUeXBlLCBrZXJuZWxJZCwgYXR0cmlidXRlLCBtb2R1bGUuVVRGOFRvU3RyaW5nKG1vZHVsZS5fSnNlcEdldE5vZGVOYW1lIShrZXJuZWxJZCkpKSxcblxuICAgICAgLy8ganNlcFJlbGVhc2VLZXJuZWxcbiAgICAgIChrZXJuZWw6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlS2VybmVsKGtlcm5lbCksXG5cbiAgICAgIC8vIGpzZXBSdW5cbiAgICAgIChrZXJuZWw6IG51bWJlciwgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlciwgc2Vzc2lvbkhhbmRsZTogbnVtYmVyLCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nIHwgbnVsbD4+KSA9PiB7XG4gICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7c2Vzc2lvbkhhbmRsZX0sIGtlcm5lbD0ke2tlcm5lbH0sIGNvbnRleHREYXRhT2Zmc2V0PSR7Y29udGV4dERhdGFPZmZzZXR9YCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBDb21wdXRlQ29udGV4dEltcGwobW9kdWxlLCBiYWNrZW5kLCBjb250ZXh0RGF0YU9mZnNldCk7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbXB1dGVLZXJuZWwoa2VybmVsLCBjb250ZXh0LCBlcnJvcnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlQmVnaW5cbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUJlZ2luKCksXG4gICAgICAvLyBqc2VwQ2FwdHVyZUVuZFxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlRW5kKCksXG4gICAgICAvLyBqc2VwUmVwbGF5XG4gICAgICAoKSA9PiBiYWNrZW5kLnJlcGxheSgpLFxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgV2ViTk5CYWNrZW5kKGVudik7XG4gICAganNlcEluaXQoJ3dlYm5uJywgW1xuICAgICAgYmFja2VuZCxcbiAgICAgIC8vIGpzZXBSZXNlcnZlVGVuc29ySWRcbiAgICAgICgpID0+IGJhY2tlbmQucmVzZXJ2ZVRlbnNvcklkKCksXG4gICAgICAvLyBqc2VwUmVsZWFzZVRlbnNvcklkLFxuICAgICAgKHRlbnNvcklkOiBudW1iZXIpID0+IGJhY2tlbmQucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKSxcbiAgICAgIC8vIGpzZXBFbnN1cmVUZW5zb3JcbiAgICAgIGFzeW5jICh0ZW5zb3JJZDogbnVtYmVyLCBvbm54RGF0YVR5cGU6IG51bWJlciwgc2hhcGU6IG51bWJlcltdLCBjb3B5T2xkKSA9PlxuICAgICAgICBiYWNrZW5kLmVuc3VyZVRlbnNvcih0ZW5zb3JJZCwgb25ueERhdGFUeXBlLCBzaGFwZSwgY29weU9sZCksXG4gICAgICAvLyBqc2VwVXBsb2FkVGVuc29yXG4gICAgICAodGVuc29ySWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSkgPT4ge1xuICAgICAgICBiYWNrZW5kLnVwbG9hZFRlbnNvcih0ZW5zb3JJZCwgZGF0YSk7XG4gICAgICB9LFxuICAgICAgLy8ganNlcERvd25sb2FkVGVuc29yXG4gICAgICBhc3luYyAodGVuc29ySWQ6IG51bWJlciwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcikgPT4gYmFja2VuZC5kb3dubG9hZFRlbnNvcih0ZW5zb3JJZCwgZHN0QnVmZmVyKSxcbiAgICBdKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gV2ViTk4gQVBJIGN1cnJlbnRseSBkb2VzIG5vdCBoYXZlIGEgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGUuIFRoaXMgZmlsZSBpcyBhIHdvcmthcm91bmQgd2l0aCB0eXBlcyBnZW5lcmF0ZWQgZnJvbVxuLy8gV2ViTk4gQVBJIHNwZWNpZmljYXRpb24uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VibWFjaGluZWxlYXJuaW5nL3dlYm5uL2lzc3Vlcy82Nzdcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJqc2VwL3dlYm5uL3dlYm5uLmQudHNcIiAvPlxuXG5pbXBvcnQgeyBFbnYsIEluZmVyZW5jZVNlc3Npb24sIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7XG4gIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXG4gIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLFxuICBUZW5zb3JNZXRhZGF0YSxcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBzZXRSdW5PcHRpb25zIH0gZnJvbSAnLi9ydW4tb3B0aW9ucyc7XG5pbXBvcnQgeyBzZXRTZXNzaW9uT3B0aW9ucyB9IGZyb20gJy4vc2Vzc2lvbi1vcHRpb25zJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzLFxuICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0sXG4gIGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSxcbiAgaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUsXG4gIGxvZ0xldmVsU3RyaW5nVG9FbnVtLFxuICB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyxcbiAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0sXG4gIHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcixcbn0gZnJvbSAnLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuaW1wb3J0IHsgbG9hZEZpbGUgfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcblxuLy8gI3JlZ2lvbiBJbml0aWFsaXphdGlvbnNcblxuLyoqXG4gKiBUaGVyZSBhcmUgNCBkaWZmZXJlbnQgXCJpbml0aWFsaXphdGlvblwiIHN0ZXBzIGZvciBPUlQuIFRoZXkgaGFwcGVuIGluIGRpZmZlcmVudCBwbGFjZXMgYW5kIGRpZmZlcmVudCB0aW1lLlxuICpcbiAqIDEuIEphdmFTY3JpcHQgaW5pdGlhbGl6YXRpb24gZm9yIG9ubnhydW50aW1lLWNvbW1vbiBhbmQgb25ueHJ1bnRpbWUtd2ViLlxuICogICAgVGhpcyBpcyB0aGUgZmlyc3QgaW5pdGlhbGl6YXRpb24gc3RlcC4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgY2FsbHMgb25ueHJ1bnRpbWUtY29tbW9uJ3MgcmVnaXN0ZXJCYWNrZW5kKClcbiAqIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIGFsbCB0aGUgYXZhaWxhYmxlIGJhY2tlbmRzLiBUaGUgYmFja2VuZCByZWdpc3RyYXRpb24gaXMgdmVyeSBmYXN0LiBJdCBvbmx5XG4gKiByZWdpc3RlcnMgdGhlIGJhY2tlbmQgbmFtZSB3aXRoIHRoZSB1bmluaXRpYWxpemVkIGJhY2tlbmQgb2JqZWN0LiBObyBoZWF2eSBpbml0aWFsaXphdGlvbiBpcyBkb25lIGluIHRoaXMgc3RlcC5cbiAqICAgIFJlZmVyIHRvIHdlYi9saWIvaW5kZXgudHMgZm9yIHRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbi5cbiAqXG4gKiAyLiBXZWJBc3NlbWJseSBhcnRpZmFjdCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyB3aGVuIGFueSByZWdpc3RlcmVkIHdhc20gYmFja2VuZCBpcyB1c2VkIGZvciB0aGUgZmlyc3QgdGltZSAoaWUuIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXNcbiAqIGNhbGxlZCkuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlIGZvbGxvd2luZ3M6XG4gKiAgICAgLSBjcmVhdGUgYSBwcm94eSB3b3JrZXIgYW5kIG1ha2Ugc3VyZSB0aGUgcHJveHkgd29ya2VyIGlzIHJlYWR5IHRvIHJlY2VpdmUgbWVzc2FnZXMsIGlmIHByb3h5IGlzIGVuYWJsZWQuXG4gKiAgICAgLSBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uLCBsb2NhdGUgY29ycmVjdCBXZWJBc3NlbWJseSBhcnRpZmFjdCBwYXRoIGFuZCBjYWxsIHRoZSBFbXNjcmlwdGVuIGdlbmVyYXRlZFxuICogSmF2YVNjcmlwdCBjb2RlIHRvIGluaXRpYWxpemUgdGhlIFdlYkFzc2VtYmx5IHJ1bnRpbWUuXG4gKiAgICAgICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LXdhc20nLlxuICogICAgICAgICAtIGRvd25sb2FkaW5nIHRoZSAnb3J0LXdhc217Li4ufS53YXNtJyBmaWxlIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgICAgICAtIGlmIG11bHRpLXRocmVhZCBpcyBlbmFibGVkLCBvbmUgb3IgbW9yZSB3ZWJ3b3JrZXIgd2lsbCBiZSBjcmVhdGVkIHRvIGluaXRpYWxpemUgdGhlIFBUaHJlYWQgdGhyZWFkcG9vbC5cbiAqXG4gKiAzLiBPUlQgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgYWZ0ZXIgc3RlcCAyLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBwZXJmb3JtcyBPTk5YIFJ1bnRpbWUgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiBGdW5jdGlvbiBgX09ydEluaXQoKWAgaXMgY2FsbGVkIGluIHRoaXMgc3RlcC5cbiAqICAgICAtIGlmIHByb3h5IGlzIGVuYWJsZWQsIHRoaXMgc3RlcCBoYXBwZW5zIGluIHRoZSBwcm94eSB3b3JrZXIgdXNpbmcgbWVzc2FnZSAnaW5pdC1vcnQnLlxuICogICAgIC0gbG9nZ2luZyBsZXZlbCAob3J0LmVudi5sb2dMZXZlbCkgYW5kIHRocmVhZCBudW1iZXIgKG9ydC5lbnYud2FzbS5udW1UaHJlYWRzKSBhcmUgc2V0IGluIHRoaXMgc3RlcC5cbiAqXG4gKiA0LiBTZXNzaW9uIGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgMyBzdGVwcyAodGhleSBvbmx5IGNhbGxlZCBvbmNlKSxcbiAqIHRoaXMgc3RlcCB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2Vzc2lvbi4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVUkw6XG4gKiAgICAtIGRvd25sb2FkIHRoZSBtb2RlbCBkYXRhIGZyb20gdGhlIFVSTC5cbiAqICAgIC0gY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLiAocHJveHk6ICdjb3B5LWZyb20nKVxuICogICAgLSBkZXJlZmVyZW5jZSB0aGUgbW9kZWwgYnVmZmVyLiBUaGlzIHN0ZXAgYWxsb3dzIHRoZSBvcmlnaW5hbCBBcnJheUJ1ZmZlciB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxuICpcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVaW50OEFycmF5IG9iamVjdDpcbiAqICAgIC0gY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLiAocHJveHk6ICdjb3B5LWZyb20nKVxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICpcbiAqL1xuXG4vKipcbiAqIGluaXRpYWxpemUgT1JUIGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSBudW1UaHJlYWRzIFNldEdsb2JhbEludHJhT3BOdW1UaHJlYWRzKG51bVRocmVhZHMpXG4gKiBAcGFyYW0gbG9nZ2luZ0xldmVsIENyZWF0ZUVudihzdGF0aWNfY2FzdDxPcnRMb2dnaW5nTGV2ZWw+KGxvZ2dpbmdfbGV2ZWwpKVxuICovXG5jb25zdCBpbml0T3J0ID0gKG51bVRocmVhZHM6IG51bWJlciwgbG9nZ2luZ0xldmVsOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3QgZXJyb3JDb2RlID0gZ2V0SW5zdGFuY2UoKS5fT3J0SW5pdChudW1UaHJlYWRzLCBsb2dnaW5nTGV2ZWwpO1xuICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbml0aWFsaXplIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0gZW52IHBhc3NlZCBpbiB0aGUgZW52aXJvbm1lbnQgY29uZmlnIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSdW50aW1lID0gYXN5bmMgKGVudjogRW52KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIGluaXQgT1JUXG4gIGluaXRPcnQoZW52Lndhc20ubnVtVGhyZWFkcyEsIGxvZ0xldmVsU3RyaW5nVG9FbnVtKGVudi5sb2dMZXZlbCkpO1xufTtcblxuLyoqXG4gKiBwZXJmb3JtIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSBlbnZcbiAqIEBwYXJhbSBlcE5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRFcCA9IGFzeW5jIChlbnY6IEVudiwgZXBOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgY29uc3QgaW5pdEpzZXAgPSByZXF1aXJlKCcuL2pzZXAvaW5pdCcpLmluaXQ7XG5cbiAgICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJHUFUgYXZhaWxhYmlsaXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5ncHUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXIgfCBudWxsO1xuICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgbm90IHNldCwgcmVxdWVzdCBhIG5ldyBhZGFwdGVyLlxuICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSBlbnYud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnbG93LXBvd2VyJyAmJlxuICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZSAhPT0gJ2hpZ2gtcGVyZm9ybWFuY2UnXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlRmFsbGJhY2tBZGFwdGVyID0gZW52LndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtcbiAgICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2ZvcmNlRmFsbGJhY2tBZGFwdGVyfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoeyBwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyIH0pO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhZGFwdGVyIGlzIHNldCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5saW1pdHMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIGFkYXB0ZXIuZmVhdHVyZXMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIGFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYmdwdScsIGdldEluc3RhbmNlKCksIGVudiwgYWRhcHRlcik7XG4gICAgfVxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgIC8vIHBlcmZvcm0gV2ViTk4gYXZhaWxhYmlsaXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIShuYXZpZ2F0b3IgYXMgdW5rbm93biBhcyB7IG1sOiB1bmtub3duIH0pLm1sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9XG59O1xuXG4vLyAjZW5kcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIHZhbGlkIGRhdGEgbG9jYXRpb25zIGZvciBpbnB1dC9vdXRwdXQgdGVuc29ycy5cbiAqL1xudHlwZSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dCA9ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ2dwdS1idWZmZXInIHwgJ21sLXRlbnNvcic7XG5cbnR5cGUgSU9CaW5kaW5nU3RhdGUgPSB7XG4gIC8qKlxuICAgKiB0aGUgaGFuZGxlIG9mIElPIGJpbmRpbmcuXG4gICAqL1xuICByZWFkb25seSBoYW5kbGU6IG51bWJlcjtcblxuICAvKipcbiAgICogdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKlxuICAgKiB2YWx1ZSBpcyBvbmUgb2YgJ2NwdScsICdjcHUtcGlubmVkJywgJ2dwdS1idWZmZXInLCAnbWwtdGVuc29yJy5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uczogcmVhZG9ubHkgU3VwcG9ydGVkVGVuc29yRGF0YUxvY2F0aW9uRm9ySW5wdXRPdXRwdXRbXTtcblxuICAvKipcbiAgICogZW51bSB2YWx1ZSBvZiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOiByZWFkb25seSBudW1iZXJbXTtcbn07XG5cbi8qKlxuICogIHR1cGxlIGVsZW1lbnRzIGFyZTogSW5mZXJlbmNlU2Vzc2lvbiBJRDsgaW5wdXROYW1lc1VURjhFbmNvZGVkOyBvdXRwdXROYW1lc1VURjhFbmNvZGVkOyBiaW5kaW5nU3RhdGVcbiAqL1xudHlwZSBTZXNzaW9uTWV0YWRhdGEgPSBbXG4gIGluZmVyZW5jZVNlc3Npb25JZDogbnVtYmVyLFxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSxcbiAgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwsXG4gIGVuYWJsZUdyYXBoQ2FwdHVyZTogYm9vbGVhbixcbiAgaW5wdXRPdXRwdXRCb3VuZDogYm9vbGVhbixcbl07XG5cbmNvbnN0IGFjdGl2ZVNlc3Npb25zID0gbmV3IE1hcDxudW1iZXIsIFNlc3Npb25NZXRhZGF0YT4oKTtcblxuLyoqXG4gKiBnZXQgdGhlIGlucHV0L291dHB1dCBjb3VudCBvZiB0aGUgc2Vzc2lvbi5cbiAqIEBwYXJhbSBzZXNzaW9uSGFuZGxlIHRoZSBoYW5kbGUgcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uLiBzaG91bGQgYmUgbm9uLXplcm8uXG4gKiBAcmV0dXJucyBhIHR1cGxlIGluY2x1ZGluZyAyIG51bWJlcnMsIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgY291bnQgYW5kIG91dHB1dCBjb3VudC5cbiAqL1xuY29uc3QgZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQgPSAoc2Vzc2lvbkhhbmRsZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg4KTtcbiAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRJbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUsIGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyA0KTtcbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIik7XG4gICAgfVxuICAgIHJldHVybiBbd2FzbS5IRUFQMzJbZGF0YU9mZnNldCAvIDRdLCB3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNCArIDFdXTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogYWxsb2NhdGUgdGhlIG1lbW9yeSBhbmQgbWVtY3B5IHRoZSBleHRlcm5hbCBidWZmZXIuXG4gKlxuICogQHBhcmFtIG1vZGVsIC0gdGhlIGV4dGVybmFsIGJ1ZmZlciBjb250YWluaW5nIHRoZSBtb2RlbCBkYXRhLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcC5cbiAqIEByZXR1cm5zIGEgMi1lbGVtZW50cyB0dXBsZSAtIHRoZSBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBhbGxvY2F0ZWQgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyID0gKG1vZGVsOiBVaW50OEFycmF5KTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBtb2RlbERhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MobW9kZWwuYnl0ZUxlbmd0aCk7XG4gIGlmIChtb2RlbERhdGFPZmZzZXQgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7bW9kZWwuYnl0ZUxlbmd0aH0uYCk7XG4gIH1cbiAgd2FzbS5IRUFQVTguc2V0KG1vZGVsLCBtb2RlbERhdGFPZmZzZXQpO1xuICByZXR1cm4gW21vZGVsRGF0YU9mZnNldCwgbW9kZWwuYnl0ZUxlbmd0aF07XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBhbiBpbmZlcmVuY2Ugc2Vzc2lvbiBmcm9tIGEgbW9kZWwgZGF0YSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG1vZGVsRGF0YSAtIGVpdGhlciBhIFVpbnQ4QXJyYXkgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbW9kZWwgZGF0YSwgb3IgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YSBidWZmZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyBhbiBvcHRpb25hbCBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSAzLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgW3Nlc3Npb24gaGFuZGxlLCBpbnB1dCBuYW1lcywgb3V0cHV0IG5hbWVzXVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWxEYXRhOiBVaW50OEFycmF5IHwgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gbW9kZWxEYXRhO1xuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBbbW9kZWxEYXRhLmJ5dGVPZmZzZXQsIG1vZGVsRGF0YS5ieXRlTGVuZ3RoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihtb2RlbERhdGEpO1xuICB9XG5cbiAgbGV0IHNlc3Npb25IYW5kbGUgPSAwO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcbiAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcblxuICB0cnkge1xuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBvcHRpb25zLmV4dGVybmFsRGF0YSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgbG9hZEZpbGUodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuZGF0YSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgd2FzbS5tb3VudEV4dGVybmFsRGF0YSEocGF0aCwgZGF0YSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdhaXQgZm9yIGFsbCBleHRlcm5hbCBkYXRhIGZpbGVzIHRvIGJlIGxvYWRlZFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIG9wdGlvbnM/LmV4ZWN1dGlvblByb3ZpZGVycyA/PyBbXSkge1xuICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gdHlwZW9mIHByb3ZpZGVyID09PSAnc3RyaW5nJyA/IHByb3ZpZGVyIDogcHJvdmlkZXIubmFtZTtcbiAgICAgIGlmIChwcm92aWRlck5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgICAgd2FzbS5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciBpcyBhbHJlYWR5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IHByb3ZpZGVyIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IGdwdURldmljZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXZWJHcHUpPy5ncHVEZXZpY2U7XG4gICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8uZGV2aWNlVHlwZTtcbiAgICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGNvbnRleHQgYXMgTUxDb250ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3B1RGV2aWNlKSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoZ3B1RGV2aWNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHsgZGV2aWNlVHlwZSwgcG93ZXJQcmVmZXJlbmNlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXNzaW9uSGFuZGxlID0gYXdhaXQgd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbihtb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aCwgc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIGlmIChzZXNzaW9uSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO1xuICAgIH1cblxuICAgIHdhc20uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCk7XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IE1MQ29udGV4dCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uXG4gICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgIHdhc20uanNlcFJlZ2lzdGVyTUxDb250ZXh0IShzZXNzaW9uSGFuZGxlLCB3YXNtLmN1cnJlbnRDb250ZXh0KTtcbiAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgW2lucHV0Q291bnQsIG91dHB1dENvdW50XSA9IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUpO1xuXG4gICAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gISFvcHRpb25zPy5lbmFibGVHcmFwaENhcHR1cmU7XG5cbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldElucHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBpbnB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRPdXRwdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcblxuICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnZ3B1LWJ1ZmZlcicpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID1cbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IG9wdGlvbnMucHJlZmVycmVkT3V0cHV0TG9jYXRpb25cbiAgICAgICAgICAgIDogKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdScpO1xuICAgICAgICBpZiAobG9jYXRpb24gIT09ICdjcHUnICYmIGxvY2F0aW9uICE9PSAnY3B1LXBpbm5lZCcgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJyAmJiBsb2NhdGlvbiAhPT0gJ21sLXRlbnNvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmVycmVkIHRvIGJlIG9uIEdQVS5cbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnNvbWUoKGwpID0+IGwgPT09ICdncHUtYnVmZmVyJyB8fCBsID09PSAnbWwtdGVuc29yJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAoKGwpID0+IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSGFuZGxlLCBbXG4gICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcbiAgICAgIGJpbmRpbmdTdGF0ZSxcbiAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcbiAgICAgIGZhbHNlLFxuICAgIF0pO1xuICAgIHJldHVybiBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lcywgb3V0cHV0TmFtZXNdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgIHdhc20udW5tb3VudEV4dGVybmFsRGF0YT8uKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcblxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9IChcbiAgdGVuc29yOiBUZW5zb3JNZXRhZGF0YSB8IG51bGwsXG4gIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLFxuICBhbGxvY3M6IG51bWJlcltdLFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiB2b2lkID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xuXG4gIGxldCByYXdEYXRhOiBudW1iZXI7XG4gIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gIGlmIChkYXRhVHlwZSA9PT0gJ3N0cmluZycgJiYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgfHwgbG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgfVxuXG4gIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aW5kZXh9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcbiAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgIH1cbiAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XG4gICAgY29uc3QgbWxUZW5zb3IgPSB0ZW5zb3JbMl0ubWxUZW5zb3IgYXMgTUxUZW5zb3I7XG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcblxuICAgIGNvbnN0IHJlZ2lzdGVyTUxUZW5zb3IgPSB3YXNtLmpzZXBSZWdpc3Rlck1MVGVuc29yO1xuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgfVxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKG1sVGVuc29yLCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgZGF0YUJ5dGVMZW5ndGggPSA0ICogZGF0YS5sZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgbGV0IGRhdGFJbmRleCA9IHJhd0RhdGEgLyA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK10gPSBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgYWxsb2NzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XG4gIHRyeSB7XG4gICAgbGV0IGRpbUluZGV4ID0gZGltc09mZnNldCAvIDQ7XG4gICAgZGltcy5mb3JFYWNoKChkKSA9PiAod2FzbS5IRUFQMzJbZGltSW5kZXgrK10gPSBkKSk7XG4gICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRhdGFCeXRlTGVuZ3RoLFxuICAgICAgZGltc09mZnNldCxcbiAgICAgIGRpbXMubGVuZ3RoLFxuICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGxvY2F0aW9uKSxcbiAgICApO1xuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICB9XG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMV07XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzJdO1xuICBjb25zdCBpb0JpbmRpbmdTdGF0ZSA9IHNlc3Npb25bM107XG4gIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9IHNlc3Npb25bNF07XG4gIGNvbnN0IGlucHV0T3V0cHV0Qm91bmQgPSBzZXNzaW9uWzVdO1xuXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEluZGljZXMubGVuZ3RoO1xuXG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgaW5wdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBvdXRwdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE91dHB1dEFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGlucHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3QgaW5wdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuXG4gIHRyeSB7XG4gICAgLy8gV2ViTk4gYmFja2VuZCBuZWVkcyB0aGUgYWN0aXZlIHNlc3Npb24gdG8gY2hlY2sgTUxUZW5zb3JzIHdpdGggdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICB3YXNtLmpzZXBPblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBpbnB1dFRlbnNvcnNbaV0sXG4gICAgICAgIGlucHV0VGVuc29ySGFuZGxlcyxcbiAgICAgICAgaW5wdXRPdXRwdXRBbGxvY3MsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRWYWx1ZXNJbmRleCA9IGlucHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0TmFtZXNJbmRleCA9IG91dHB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRCaW5kSW5wdXQoaGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBpbnB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlLWFsbG9jYXRlZCBvdXRwdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG91dHB1dFRlbnNvcnNbaV0/LlszXTsgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICB0cnVlLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yQ29kZTogbnVtYmVyO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICAgIGlucHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIGlucHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dENvdW50LFxuICAgICAgICBvdXRwdXROYW1lc09mZnNldCxcbiAgICAgICAgb3V0cHV0Q291bnQsXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgcnVuT3B0aW9uc0hhbmRsZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNCArIGldO1xuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgLy8gc3RhY2sgYWxsb2NhdGUgNCBwb2ludGVyIHZhbHVlXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiA0KTtcblxuICAgICAgbGV0IGtlZXBPdXRwdXRUZW5zb3IgPSBmYWxzZTtcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZSB8IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YU9mZnNldCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRUZW5zb3JEYXRhKFxuICAgICAgICAgIHRlbnNvcixcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA4LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyAxMixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7aX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbnNvckRhdGFJbmRleCA9IHRlbnNvckRhdGFPZmZzZXQgLyA0O1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc0xlbmd0aCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkaW1zLnB1c2god2FzbS5IRUFQVTMyW2RpbXNPZmZzZXQgLyA0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX09ydEZyZWUoZGltc09mZnNldCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgICAgIHR5cGUgPSB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhkYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGEgY2VydGFpbiBvdXRwdXQncyBwcmVmZXJyZWQgbG9jYXRpb24gaXMgR1BVIGJ1dCB0aGUgdGVuc29yIGlzIGVtcHR5LCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBhIENQVVxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCdWZmZXIgPSB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBidWZmZXJTaXplLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuc3VyZVRlbnNvciA9IHdhc20uanNlcEVuc3VyZVRlbnNvcjtcbiAgICAgICAgICAgIGlmICghZW5zdXJlVGVuc29yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKHRlbnNvclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGhhcyBiZWVuIHBhcnRpdGlvbmVkLCB0aGUgb3V0cHV0IHRlbnNvciBtYXkgaGF2ZSBub3QgYmVlbiBjcmVhdGVkLiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZVxuICAgICAgICAgICAgLy8gZW5zdXJlVGVuc29yIHRvIGdldC9jcmVhdGUgdGhlIE1MVGVuc29yLiBJbiB3aGljaCBjYXNlLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgdGhlIGRhdGEgaWYgYSBuZXcgdGVuc29yXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgY29uc3QgbWxUZW5zb3IgPSBhd2FpdCBlbnN1cmVUZW5zb3IoZGF0YU9mZnNldCwgZGF0YVR5cGUsIGRpbXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWxUZW5zb3IsXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlciEoZGF0YU9mZnNldCwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS5qc2VwUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnbWwtdGVuc29yJyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzaXplKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkuc2V0KFxuICAgICAgICAgICAgICB3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUgJiYgIWVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgd2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICBmYWxzZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcblxuICAgIGlucHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKCh2KSA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIGlucHV0T3V0cHV0QWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuXG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuICB9XG59O1xuXG4vKipcbiAqIGVuZCBwcm9maWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vzc2lvbiBpZCcpO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuXG4gIC8vIHByb2ZpbGUgZmlsZSBuYW1lIGlzIG5vdCB1c2VkIHlldCwgYnV0IGl0IG11c3QgYmUgZnJlZWQuXG4gIGNvbnN0IHByb2ZpbGVGaWxlTmFtZSA9IHdhc20uX09ydEVuZFByb2ZpbGluZyhzZXNzaW9uSGFuZGxlKTtcbiAgaWYgKHByb2ZpbGVGaWxlTmFtZSA9PT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKTtcbiAgfVxuICB3YXNtLl9PcnRGcmVlKHByb2ZpbGVGaWxlTmFtZSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMgPSAodGVuc29yczogcmVhZG9ubHkgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSk6IEFycmF5QnVmZmVyTGlrZVtdID0+IHtcbiAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJMaWtlW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGVuc29ycykge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpICYmICdidWZmZXInIGluIGRhdGEpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXJzO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52LCBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgT3J0V2FzbU1lc3NhZ2UsXG4gIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXG4gIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLFxuICBUZW5zb3JNZXRhZGF0YSxcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vd2FzbS1jb3JlLWltcGwnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5IH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgaW1wb3J0UHJveHlXb3JrZXIgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBwcm94eVdvcmtlcjogV29ya2VyIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG50eXBlIFByb21pc2VDYWxsYmFja3M8VCA9IHZvaWQ+ID0gW3Jlc29sdmU6IChyZXN1bHQ6IFQpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZF07XG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlZENhbGxiYWNrcy5zZXQodHlwZSwgW2NhbGxiYWNrc10pO1xuICB9XG59O1xuXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZXIgbm90IHJlYWR5Jyk7XG4gIH1cbn07XG5cbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XG4gICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcG9yYXJ5T2JqZWN0VXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5pdC1lcCc6XG4gICAgY2FzZSAnY29weS1mcm9tJzpcbiAgICBjYXNlICdjcmVhdGUnOlxuICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgIGNhc2UgJ3J1bic6XG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVswXShldi5kYXRhLm91dCEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XG5cbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJveHlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcbiAgICAgICAgICBpbml0V2FzbUNhbGxiYWNrcyA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC13YXNtJywgaW46IGVudiB9O1xuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IG9iamVjdFVybDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcbiAgICAgIGF3YWl0IGNvcmUuaW5pdFJ1bnRpbWUoZW52KTtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jIChlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdpbml0LWVwJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LWVwJywgaW46IHsgZXBOYW1lLCBlbnYgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSBhc3luYyAoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjb3B5LWZyb20nLCBpbjogeyBidWZmZXIgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyIHwgVWludDhBcnJheSxcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIHVuc3VwcG9ydGVkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjcmVhdGUnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NyZWF0ZScsIGluOiB7IG1vZGVsLCBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSB9IH07XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XG4gICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ3JlbGVhc2UnLCBpbjogc2Vzc2lvbklkIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXG4gICAgaWYgKGlucHV0cy5zb21lKCh0KSA9PiB0WzNdICE9PSAnY3B1JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb3V0cHV0cyBsb2NhdGlvblxuICAgIGlmIChvdXRwdXRzLnNvbWUoKHQpID0+IHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3J1bicsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ3J1bicsXG4gICAgICAgIGluOiB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9LFxuICAgICAgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBjb3JlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKHNlcmlhbGl6YWJsZUlucHV0cykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLnJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdlbmQtcHJvZmlsaW5nJywgaW46IHNlc3Npb25JZCB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIEluZmVyZW5jZVNlc3Npb24sXG4gIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLFxuICBTZXNzaW9uSGFuZGxlcixcbiAgVGVuc29yLFxuICBUUkFDRV9GVU5DX0JFR0lOLFxuICBUUkFDRV9GVU5DX0VORCxcbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW4gfSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHsgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSB9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgeyBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIgfSwgJ2dwdS1idWZmZXInXTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvciB9LCAnbWwtdGVuc29yJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgaWYgKCFpc01MVGVuc29yU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1sVGVuc29yLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tTUxUZW5zb3IobWxUZW5zb3IsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oXG4gICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yIHwgbnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuL3dhc20vd2FzbS11dGlscy1pbXBvcnQnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmIChlbnYud2FzbS5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiAnICtcbiAgICAgICAgJ25vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUKSB7XG4gICAgLy8gb3ZlcndyaXRlIHdhc20gcGF0aHMgb3ZlcnJpZGUgaWYgbm90IHNldFxuICAgIGlmIChlbnYud2FzbS53YXNtUGF0aHMgPT09IHVuZGVmaW5lZCAmJiBzY3JpcHRTcmMgJiYgc2NyaXB0U3JjLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIGVudi53YXNtLndhc21QYXRocyA9IHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgV2ViQXNzZW1ibHkgYmFja2VuZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXG4gICAqIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkIHdpdGggYSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKi9cbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xuICAgIGluaXRpYWxpemVGbGFncygpO1xuXG4gICAgLy8gaW5pdCB3YXNtXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSgpO1xuXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0aWFsaXplT3J0RXAoYmFja2VuZE5hbWUpO1xuICB9XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7IHJlZ2lzdGVyQmFja2VuZCwgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjEuMC1kZXYuMjAyNDEwMjQtZDljYTg0ZWY5Nic7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFnQk0sVUFDQSwwQkFZTyxpQkF3Q1AsZ0NBd0NPO0FBN0diOzs7QUFnQkEsSUFBTSxXQUFxQyxvQkFBSSxJQUFHO0FBQ2xELElBQU0sMkJBQXFDLENBQUE7QUFZcEMsSUFBTSxrQkFBa0IsQ0FBQyxNQUFjLFNBQWtCLGFBQTBCO0FBQ3hGLFVBQUksV0FBVyxPQUFPLFFBQVEsU0FBUyxjQUFjLE9BQU8sUUFBUSxrQ0FBa0MsWUFBWTtBQUNoSCxjQUFNLGlCQUFpQixTQUFTLElBQUksSUFBSTtBQUN4QyxZQUFJLG1CQUFtQixRQUFXO0FBQ2hDLG1CQUFTLElBQUksTUFBTSxFQUFFLFNBQVMsU0FBUSxDQUFFO21CQUMvQixl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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTNUQsTUFBTSxLQUFLLGFBQW9DO0FBRTdDLHdCQUFnQjtBQUdoQixjQUFNLG1DQUFtQztBQUd6QyxjQUFNLGdCQUFnQixXQUFXO0FBQUEsTUFDbkM7QUFBQSxNQVNBLE1BQU0sOEJBQ0osY0FDQSxTQUNrQztBQUNsQyxjQUFNLFVBQVUsSUFBSSxxQ0FBcUM7QUFDekQsY0FBTSxRQUFRLFVBQVUsY0FBYyxPQUFPO0FBQzdDLGVBQU8sUUFBUSxRQUFRLE9BQU87QUFBQSxNQUNoQztBQUFBLElBQ0Y7QUFFTyxJQUFNLGNBQWMsSUFBSSw4QkFBOEI7QUFBQTtBQUFBOzs7QUM3RjdEO0FBQ0E7QUFHQTs7O0FDUE8sSUFBTUMsV0FBVTs7O0FES3ZCLElBQU8sY0FBUTtBQUtmLElBQUksT0FBMkI7QUFDN0IsUUFBTSxnQkFBZ0IsS0FBNEI7QUFDbEQsa0JBQWdCLFNBQVMsZUFBZSxHQUFHO0FBQzdDO0FBRUEsSUFBSSxNQUEwQjtBQUM1QixRQUFNQyxlQUFjLDBEQUEwQjtBQUM5QyxNQUFJLE1BQTBCO0FBQzVCLG9CQUFnQixVQUFVQSxjQUFhLENBQUM7QUFDeEMsb0JBQWdCLFNBQVNBLGNBQWEsQ0FBQztBQUFBLEVBQ3pDO0FBQ0Esa0JBQWdCLE9BQU9BLGNBQWEsRUFBRTtBQUN0QyxrQkFBZ0IsUUFBUUEsY0FBYSxFQUFFO0FBQ3pDO0FBRUEsT0FBTyxlQUFlQyxLQUFJLFVBQVUsT0FBTyxFQUFFLE9BQU9DLFVBQVMsWUFBWSxLQUFLLENBQUM7IiwKICAibmFtZXMiOiBbImkiLCAiZW52IiwgIlRlbnNvciIsICJUZW5zb3IiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAiZW52IiwgIndhc20iLCAid2FzbSIsICJ3YXNtIiwgImxvY2F0aW9uIiwgInBhZCIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAidHJhbnNwb3NlIiwgIm91dHB1dFZhcmlhYmxlIiwgImlubmVyRWxlbWVudFNpemUiLCAicGFkIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImNvbnZJbnB1dHMiLCAidHJhbnNwb3NlZFdlaWdodCIsICJpbm5lckVsZW1lbnRTaXplIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJ0ZW5zb3IiLCAiZW52IiwgIndhc20iLCAiZW52IiwgImVudiIsICJ3YXNtIiwgImxvY2F0aW9uIiwgInRlbnNvciIsICJlcnJvckNvZGUiLCAiaSIsICJpbml0aWFsaXppbmciLCAiaW5pdGlhbGl6ZWQiLCAiYWJvcnRlZCIsICJjb3B5RnJvbUV4dGVybmFsQnVmZmVyIiwgImNyZWF0ZVNlc3Npb24iLCAicmVsZWFzZVNlc3Npb24iLCAicnVuIiwgImVuZFByb2ZpbGluZyIsICJlbnYiLCAiVGVuc29yIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJ2ZXJzaW9uIiwgIndhc21CYWNrZW5kIiwgImVudiIsICJ2ZXJzaW9uIl0KfQo=
